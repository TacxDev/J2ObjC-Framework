//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/platform/libcore/ojluni/src/main/java/javax/net/ssl/SSLSocketFactory.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_JavaxNetSslSSLSocketFactory")
#ifdef RESTRICT_JavaxNetSslSSLSocketFactory
#define INCLUDE_ALL_JavaxNetSslSSLSocketFactory 0
#else
#define INCLUDE_ALL_JavaxNetSslSSLSocketFactory 1
#endif
#undef RESTRICT_JavaxNetSslSSLSocketFactory
#ifdef INCLUDE_JavaxNetSslDefaultSSLSocketFactory
#define INCLUDE_JavaxNetSslSSLSocketFactory 1
#endif

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (JavaxNetSslSSLSocketFactory_) && (INCLUDE_ALL_JavaxNetSslSSLSocketFactory || defined(INCLUDE_JavaxNetSslSSLSocketFactory))
#define JavaxNetSslSSLSocketFactory_

#define RESTRICT_JavaxNetSocketFactory 1
#define INCLUDE_JavaxNetSocketFactory 1
#include "javax/net/SocketFactory.h"

@class IOSObjectArray;
@class JavaIoInputStream;
@class JavaLangBoolean;
@class JavaLangInteger;
@class JavaNetSocket;

/*!
 @brief <code>SSLSocketFactory</code>s create <code>SSLSocket</code>s.
 @since 1.4
 - seealso: SSLSocket
 @author David Brownell
 */
@interface JavaxNetSslSSLSocketFactory : JavaxNetSocketFactory

#pragma mark Public

/*!
 @brief Constructor is used only by subclasses.
 */
- (instancetype __nonnull)init;

/*!
 @brief Creates a server mode <code>Socket</code> layered over an
  existing connected socket, and is able to read data which has
  already been consumed/removed from the <code>Socket</code>'s
  underlying <code>InputStream</code>.
 <p>
  This method can be used by a server application that needs to
  observe the inbound data but still create valid SSL/TLS
  connections: for example, inspection of Server Name Indication
  (SNI) extensions (See section 3 of <A HREF="http://www.ietf.org/rfc/rfc6066.txt">
 TLS Extensions
  (RFC6066)</A>).  Data that has been already removed from the
  underlying <code>InputStream</code> should be loaded into the 
 <code>consumed</code> stream before this method is called, perhaps
  using a <code>java.io.ByteArrayInputStream</code>.  When this 
 <code>Socket</code> begins handshaking, it will read all of the data in 
 <code>consumed</code> until it reaches <code>EOF</code>, then all further
  data is read from the underlying <code>InputStream</code> as
  usual. 
 <p>
  The returned socket is configured using the socket options
  established for this factory, and is set to use server mode when
  handshaking (see <code>SSLSocket.setUseClientMode(boolean)</code>).
 @param s the existing socket
 @param consumed the consumed inbound network data that has already been
           removed from the existing 
 <code>Socket</code>          <code>InputStream</code>
  .  This parameter may be          <code>null</code>  if no data has been removed.
 @param autoClose close the underlying socket when this socket is closed.
 @return the <code>Socket</code> compliant with the socket options
          established for this factory
 @throw IOExceptionif an I/O error occurs when creating the socket
 @throw UnsupportedOperationExceptionif the underlying provider
          does not implement the operation
 @throw NullPointerExceptionif <code>s</code> is <code>null</code>
 @since 1.8
 */
- (JavaNetSocket *)createSocketWithJavaNetSocket:(JavaNetSocket *)s
                           withJavaIoInputStream:(JavaIoInputStream *)consumed
                                     withBoolean:(jboolean)autoClose;

/*!
 @brief Returns a socket layered over an existing socket connected to the named
  host, at the given port.This constructor can be used when tunneling SSL
  through a proxy or when negotiating the use of SSL over an existing
  socket.
 The host and port refer to the logical peer destination.
  This socket is configured using the socket options established for
  this factory.
 @param s the existing socket
 @param host the server host
 @param port the server port
 @param autoClose close the underlying socket when this socket is closed
 @return a socket connected to the specified host and port
 @throw IOExceptionif an I/O error occurs when creating the socket
 @throw NullPointerExceptionif the parameter s is null
 */
- (JavaNetSocket *)createSocketWithJavaNetSocket:(JavaNetSocket *)s
                                    withNSString:(NSString *)host
                                         withInt:(jint)port
                                     withBoolean:(jboolean)autoClose;

/*!
 @brief Returns the default SSL socket factory.
 <p>The first time this method is called, the security property
  "ssl.SocketFactory.provider" is examined. If it is non-null, a class by
  that name is loaded and instantiated. If that is successful and the
  object is an instance of SSLSocketFactory, it is made the default SSL
  socket factory. 
 <p>Otherwise, this method returns 
 <code>SSLContext.getDefault().getSocketFactory()</code>. If that
  call fails, an inoperative factory is returned.
 @return the default <code>SocketFactory</code>
 - seealso: SSLContext#getDefault
 */
+ (JavaxNetSocketFactory *)getDefault;

/*!
 @brief Returns the list of cipher suites which are enabled by default.
 Unless a different list is enabled, handshaking on an SSL connection
  will use one of these cipher suites.  The minimum quality of service
  for these defaults requires confidentiality protection and server
  authentication (that is, no anonymous cipher suites).
 - seealso: #getSupportedCipherSuites()
 @return array of the cipher suites enabled by default
 */
- (IOSObjectArray *)getDefaultCipherSuites;

/*!
 @brief Returns the names of the cipher suites which could be enabled for use
  on an SSL connection.Normally, only a subset of these will actually
  be enabled by default, since this list may include cipher suites which
  do not meet quality of service requirements for those defaults.
 Such
  cipher suites are useful in specialized applications. 
 <p class="caution">Applications should not blindly enable all supported
  cipher suites.  The supported cipher suites can include signaling cipher suite
  values that can cause connection problems if enabled inappropriately. 
 <p>The proper way to use this method is to either check if a specific cipher
  suite is supported via <code>Arrays.asList(getSupportedCipherSuites()).contains(...)</code>
  or to filter a desired list of cipher suites to only the supported ones via 
 <code>desiredSuiteSet.retainAll(Arrays.asList(getSupportedCipherSuites()))</code>.
 - seealso: #getDefaultCipherSuites()
 @return an array of cipher suite names
 */
- (IOSObjectArray *)getSupportedCipherSuites;

#pragma mark Package-Private

+ (NSString *)getSecurityPropertyWithNSString:(NSString *)name;

@end

J2OBJC_STATIC_INIT(JavaxNetSslSSLSocketFactory)

inline jboolean JavaxNetSslSSLSocketFactory_get_DEBUG(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT jboolean JavaxNetSslSSLSocketFactory_DEBUG;
J2OBJC_STATIC_FIELD_PRIMITIVE_FINAL(JavaxNetSslSSLSocketFactory, DEBUG, jboolean)

FOUNDATION_EXPORT void JavaxNetSslSSLSocketFactory_init(JavaxNetSslSSLSocketFactory *self);

FOUNDATION_EXPORT JavaxNetSocketFactory *JavaxNetSslSSLSocketFactory_getDefault(void);

FOUNDATION_EXPORT NSString *JavaxNetSslSSLSocketFactory_getSecurityPropertyWithNSString_(NSString *name);

J2OBJC_TYPE_LITERAL_HEADER(JavaxNetSslSSLSocketFactory)

#endif

#if !defined (JavaxNetSslDefaultSSLSocketFactory_) && (INCLUDE_ALL_JavaxNetSslSSLSocketFactory || defined(INCLUDE_JavaxNetSslDefaultSSLSocketFactory))
#define JavaxNetSslDefaultSSLSocketFactory_

@class IOSObjectArray;
@class JavaLangBoolean;
@class JavaLangException;
@class JavaLangInteger;
@class JavaNetInetAddress;
@class JavaNetSocket;

@interface JavaxNetSslDefaultSSLSocketFactory : JavaxNetSslSSLSocketFactory

#pragma mark Public

- (JavaNetSocket *)createSocket;

- (JavaNetSocket *)createSocketWithJavaNetInetAddress:(JavaNetInetAddress *)address
                                              withInt:(jint)port;

- (JavaNetSocket *)createSocketWithJavaNetInetAddress:(JavaNetInetAddress *)address
                                              withInt:(jint)port
                               withJavaNetInetAddress:(JavaNetInetAddress *)clientAddress
                                              withInt:(jint)clientPort;

- (JavaNetSocket *)createSocketWithJavaNetSocket:(JavaNetSocket *)s
                                    withNSString:(NSString *)host
                                         withInt:(jint)port
                                     withBoolean:(jboolean)autoClose;

- (JavaNetSocket *)createSocketWithNSString:(NSString *)host
                                    withInt:(jint)port;

- (JavaNetSocket *)createSocketWithNSString:(NSString *)host
                                    withInt:(jint)port
                     withJavaNetInetAddress:(JavaNetInetAddress *)clientAddress
                                    withInt:(jint)clientPort;

- (IOSObjectArray *)getDefaultCipherSuites;

- (IOSObjectArray *)getSupportedCipherSuites;

#pragma mark Package-Private

- (instancetype __nonnull)initPackagePrivateWithJavaLangException:(JavaLangException *)reason;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaxNetSslDefaultSSLSocketFactory)

FOUNDATION_EXPORT void JavaxNetSslDefaultSSLSocketFactory_initPackagePrivateWithJavaLangException_(JavaxNetSslDefaultSSLSocketFactory *self, JavaLangException *reason);

FOUNDATION_EXPORT JavaxNetSslDefaultSSLSocketFactory *new_JavaxNetSslDefaultSSLSocketFactory_initPackagePrivateWithJavaLangException_(JavaLangException *reason) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaxNetSslDefaultSSLSocketFactory *create_JavaxNetSslDefaultSSLSocketFactory_initPackagePrivateWithJavaLangException_(JavaLangException *reason);

J2OBJC_TYPE_LITERAL_HEADER(JavaxNetSslDefaultSSLSocketFactory)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif
#pragma pop_macro("INCLUDE_ALL_JavaxNetSslSSLSocketFactory")
