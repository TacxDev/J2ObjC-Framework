//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/platform/libcore/ojluni/src/main/java/java/util/concurrent/atomic/AtomicLong.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_JavaUtilConcurrentAtomicAtomicLong")
#ifdef RESTRICT_JavaUtilConcurrentAtomicAtomicLong
#define INCLUDE_ALL_JavaUtilConcurrentAtomicAtomicLong 0
#else
#define INCLUDE_ALL_JavaUtilConcurrentAtomicAtomicLong 1
#endif
#undef RESTRICT_JavaUtilConcurrentAtomicAtomicLong

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (JavaUtilConcurrentAtomicAtomicLong_) && (INCLUDE_ALL_JavaUtilConcurrentAtomicAtomicLong || defined(INCLUDE_JavaUtilConcurrentAtomicAtomicLong))
#define JavaUtilConcurrentAtomicAtomicLong_

#define RESTRICT_JavaIoSerializable 1
#define INCLUDE_JavaIoSerializable 1
#include "java/io/Serializable.h"

@class JavaLangBoolean;
@class JavaLangDouble;
@class JavaLangFloat;
@class JavaLangInteger;
@class JavaLangLong;
@protocol JavaUtilFunctionLongBinaryOperator;
@protocol JavaUtilFunctionLongUnaryOperator;

/*!
 @brief A <code>long</code> value that may be updated atomically.See the 
 <code>VarHandle</code> specification for descriptions of the properties
  of atomic accesses.
 An <code>AtomicLong</code> is used in applications
  such as atomically incremented sequence numbers, and cannot be used
  as a replacement for a <code>java.lang.Long</code>. However, this class
  does extend <code>Number</code> to allow uniform access by tools and
  utilities that deal with numerically-based classes.
 @since 1.5
 @author Doug Lea
 */
@interface JavaUtilConcurrentAtomicAtomicLong : NSNumber < JavaIoSerializable >

#pragma mark Public

/*!
 @brief Creates a new AtomicLong with initial value <code>0</code>.
 */
- (instancetype __nonnull)init;

/*!
 @brief Creates a new AtomicLong with the given initial value.
 @param initialValue the initial value
 */
- (instancetype __nonnull)initWithLongLong:(jlong)initialValue;

/*!
 @brief Atomically updates (with memory effects as specified by <code>VarHandle.compareAndSet</code>
 ) the current value with the results of
  applying the given function to the current and given values,
  returning the updated value.The function should be
  side-effect-free, since it may be re-applied when attempted
  updates fail due to contention among threads.
 The function is
  applied with the current value as its first argument, and the
  given update as the second argument.
 @param x the update value
 @param accumulatorFunction a side-effect-free function of two arguments
 @return the updated value
 @since 1.8
 */
- (jlong)accumulateAndGetWithLong:(jlong)x
withJavaUtilFunctionLongBinaryOperator:(id<JavaUtilFunctionLongBinaryOperator>)accumulatorFunction;

/*!
 @brief Atomically adds the given value to the current value,
  with memory effects as specified by <code>VarHandle.getAndAdd</code>.
 @param delta the value to add
 @return the updated value
 */
- (jlong)addAndGetWithLong:(jlong)delta;

/*!
 @brief Atomically sets the value to <code>newValue</code>
  if the current value <code>== expectedValue</code>,
  with memory effects as specified by <code>VarHandle.compareAndSet</code>.
 @param expectedValue the expected value
 @param newValue the new value
 @return <code>true</code> if successful. False return indicates that
  the actual value was not equal to the expected value.
 */
- (jboolean)compareAndSetWithLong:(jlong)expect
                         withLong:(jlong)update;

/*!
 @brief Atomically decrements the current value,
  with memory effects as specified by <code>VarHandle.getAndAdd</code>.
 <p>Equivalent to <code>addAndGet(-1)</code>.
 @return the updated value
 */
- (jlong)decrementAndGet;

/*!
 @brief Returns the current value of this <code>AtomicLong</code> as a <code>double</code>
  after a widening primitive conversion,
  with memory effects as specified by <code>VarHandle.getVolatile</code>.
 */
- (jdouble)doubleValue;

/*!
 @brief Returns the current value of this <code>AtomicLong</code> as a <code>float</code>
  after a widening primitive conversion,
  with memory effects as specified by <code>VarHandle.getVolatile</code>.
 */
- (jfloat)floatValue;

/*!
 @brief Returns the current value,
  with memory effects as specified by <code>VarHandle.getVolatile</code>.
 @return the current value
 */
- (jlong)get;

/*!
 @brief Atomically updates (with memory effects as specified by <code>VarHandle.compareAndSet</code>
 ) the current value with the results of
  applying the given function to the current and given values,
  returning the previous value.The function should be
  side-effect-free, since it may be re-applied when attempted
  updates fail due to contention among threads.
 The function is
  applied with the current value as its first argument, and the
  given update as the second argument.
 @param x the update value
 @param accumulatorFunction a side-effect-free function of two arguments
 @return the previous value
 @since 1.8
 */
- (jlong)getAndAccumulateWithLong:(jlong)x
withJavaUtilFunctionLongBinaryOperator:(id<JavaUtilFunctionLongBinaryOperator>)accumulatorFunction;

/*!
 @brief Atomically adds the given value to the current value,
  with memory effects as specified by <code>VarHandle.getAndAdd</code>.
 @param delta the value to add
 @return the previous value
 */
- (jlong)getAndAddWithLong:(jlong)delta;

/*!
 @brief Atomically decrements the current value,
  with memory effects as specified by <code>VarHandle.getAndAdd</code>.
 <p>Equivalent to <code>getAndAdd(-1)</code>.
 @return the previous value
 */
- (jlong)getAndDecrement;

/*!
 @brief Atomically increments the current value,
  with memory effects as specified by <code>VarHandle.getAndAdd</code>.
 <p>Equivalent to <code>getAndAdd(1)</code>.
 @return the previous value
 */
- (jlong)getAndIncrement;

/*!
 @brief Atomically sets the value to <code>newValue</code> and returns the old value,
  with memory effects as specified by <code>VarHandle.getAndSet</code>.
 @param newValue the new value
 @return the previous value
 */
- (jlong)getAndSetWithLong:(jlong)newValue;

/*!
 @brief Atomically updates (with memory effects as specified by <code>VarHandle.compareAndSet</code>
 ) the current value with the results of
  applying the given function, returning the previous value.The
  function should be side-effect-free, since it may be re-applied
  when attempted updates fail due to contention among threads.
 @param updateFunction a side-effect-free function
 @return the previous value
 @since 1.8
 */
- (jlong)getAndUpdateWithJavaUtilFunctionLongUnaryOperator:(id<JavaUtilFunctionLongUnaryOperator>)updateFunction;

- (NSUInteger)hash;

/*!
 @brief Atomically increments the current value,
  with memory effects as specified by <code>VarHandle.getAndAdd</code>.
 <p>Equivalent to <code>addAndGet(1)</code>.
 @return the updated value
 */
- (jlong)incrementAndGet;

/*!
 @brief Returns the current value of this <code>AtomicLong</code> as an <code>int</code>
  after a narrowing primitive conversion,
  with memory effects as specified by <code>VarHandle.getVolatile</code>.
 */
- (jint)intValue;

- (jboolean)isEqual:(id)obj;

/*!
 @brief Sets the value to <code>newValue</code>,
  with memory effects as specified by <code>VarHandle.setRelease</code>.
 @param newValue the new value
 @since 1.6
 */
- (void)lazySetWithLong:(jlong)newValue;

/*!
 @brief Returns the current value of this <code>AtomicLong</code> as a <code>long</code>,
  with memory effects as specified by <code>VarHandle.getVolatile</code>.
 Equivalent to <code>get()</code>.
 */
- (jlong)longLongValue;

/*!
 @brief Sets the value to <code>newValue</code>,
  with memory effects as specified by <code>VarHandle.setVolatile</code>.
 @param newValue the new value
 */
- (void)setWithLong:(jlong)newValue;

/*!
 @brief Returns the String representation of the current value.
 @return the String representation of the current value
 */
- (NSString *)description;

/*!
 @brief Atomically updates (with memory effects as specified by <code>VarHandle.compareAndSet</code>
 ) the current value with the results of
  applying the given function, returning the updated value.The
  function should be side-effect-free, since it may be re-applied
  when attempted updates fail due to contention among threads.
 @param updateFunction a side-effect-free function
 @return the updated value
 @since 1.8
 */
- (jlong)updateAndGetWithJavaUtilFunctionLongUnaryOperator:(id<JavaUtilFunctionLongUnaryOperator>)updateFunction;

/*!
 @brief Possibly atomically sets the value to <code>newValue</code>
  if the current value <code>== expectedValue</code>,
  with memory effects as specified by <code>VarHandle.weakCompareAndSetPlain</code>.
 @param expectedValue the expected value
 @param newValue the new value
 @return <code>true</code> if successful
 - seealso: #weakCompareAndSetPlain
 */
- (jboolean)weakCompareAndSetWithLong:(jlong)expect
                             withLong:(jlong)update;

#pragma mark Package-Private

@end

J2OBJC_STATIC_INIT(JavaUtilConcurrentAtomicAtomicLong)

/*!
 @brief Records whether the underlying JVM supports lockless
  compareAndSet for longs.While the intrinsic compareAndSetLong
  method works in either case, some constructions should be
  handled at Java level to avoid locking user-visible locks.
 */
inline jboolean JavaUtilConcurrentAtomicAtomicLong_get_VM_SUPPORTS_LONG_CAS(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT jboolean JavaUtilConcurrentAtomicAtomicLong_VM_SUPPORTS_LONG_CAS;
J2OBJC_STATIC_FIELD_PRIMITIVE_FINAL(JavaUtilConcurrentAtomicAtomicLong, VM_SUPPORTS_LONG_CAS, jboolean)

FOUNDATION_EXPORT void JavaUtilConcurrentAtomicAtomicLong_initWithLongLong_(JavaUtilConcurrentAtomicAtomicLong *self, jlong initialValue);

FOUNDATION_EXPORT JavaUtilConcurrentAtomicAtomicLong *new_JavaUtilConcurrentAtomicAtomicLong_initWithLongLong_(jlong initialValue) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentAtomicAtomicLong *create_JavaUtilConcurrentAtomicAtomicLong_initWithLongLong_(jlong initialValue);

FOUNDATION_EXPORT void JavaUtilConcurrentAtomicAtomicLong_init(JavaUtilConcurrentAtomicAtomicLong *self);

FOUNDATION_EXPORT JavaUtilConcurrentAtomicAtomicLong *new_JavaUtilConcurrentAtomicAtomicLong_init(void) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilConcurrentAtomicAtomicLong *create_JavaUtilConcurrentAtomicAtomicLong_init(void);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilConcurrentAtomicAtomicLong)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif
#pragma pop_macro("INCLUDE_ALL_JavaUtilConcurrentAtomicAtomicLong")
