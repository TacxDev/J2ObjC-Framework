//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/platform/libcore/ojluni/src/main/java/java/util/Locale.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_JavaUtilLocale")
#ifdef RESTRICT_JavaUtilLocale
#define INCLUDE_ALL_JavaUtilLocale 0
#else
#define INCLUDE_ALL_JavaUtilLocale 1
#endif
#undef RESTRICT_JavaUtilLocale

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (JavaUtilLocale_) && (INCLUDE_ALL_JavaUtilLocale || defined(INCLUDE_JavaUtilLocale))
#define JavaUtilLocale_

#define RESTRICT_JavaIoSerializable 1
#define INCLUDE_JavaIoSerializable 1
#include "java/io/Serializable.h"

@class IOSObjectArray;
@class JavaLangBoolean;
@class JavaLangCharacter;
@class JavaLangInteger;
@class JavaLangLong;
@class JavaUtilLocale_Category;
@class JavaUtilLocale_FilteringMode;
@class SunUtilLocaleBaseLocale;
@class SunUtilLocaleLocaleExtensions;
@protocol JavaUtilCollection;
@protocol JavaUtilList;
@protocol JavaUtilSet;

/*!
 @brief A <code>Locale</code> object represents a specific geographical, political,
  or cultural region.An operation that requires a <code>Locale</code> to perform
  its task is called <em>locale-sensitive</em> and uses the <code>Locale</code>
  to tailor information for the user.
 For example, displaying a number
  is a locale-sensitive operation&mdash; the number should be formatted
  according to the customs and conventions of the user's native country,
  region, or culture. 
 <p> The <code>Locale</code> class implements IETF BCP 47 which is composed of 
 <a href="http://tools.ietf.org/html/rfc4647">RFC 4647 "Matching of Language
  Tags"</a> and <a href="http://tools.ietf.org/html/rfc5646">RFC 5646 "Tags
  for Identifying Languages"</a> with support for the LDML (UTS#35, "Unicode
  Locale Data Markup Language") BCP 47-compatible extensions for locale data
  exchange. 
 <p> A <code>Locale</code> object logically consists of the fields
  described below. 
 <dl>
    <dt><a name="def_language"><b>language</b></a></dt>
    <dd>ISO 639 alpha-2 or alpha-3 language code, or registered
    language subtags up to 8 alpha letters (for future enhancements).
    When a language has both an alpha-2 code and an alpha-3 code, the
    alpha-2 code must be used.  You can find a full list of valid
    language codes in the IANA Language Subtag Registry (search for
    "Type: language").  The language field is case insensitive, but   
 <code>Locale</code> always canonicalizes to lower case.</dd>
    <dd>Well-formed language values have the form
    <code>[a-zA-Z]{2,8}</code>.  Note that this is not the the full
    BCP47 language production, since it excludes extlang.  They are
    not needed since modern three-letter language codes replace
    them.</dd>
    <dd>Example: "en" (English), "ja" (Japanese), "kok" (Konkani)</dd>
    <dt><a name="def_script"><b>script</b></a></dt>
    <dd>ISO 15924 alpha-4 script code.  You can find a full list of
    valid script codes in the IANA Language Subtag Registry (search
    for "Type: script").  The script field is case insensitive, but   
 <code>Locale</code> always canonicalizes to title case (the first
    letter is upper case and the rest of the letters are lower
    case).</dd>
    <dd>Well-formed script values have the form
    <code>[a-zA-Z]{4}</code></dd>
    <dd>Example: "Latn" (Latin), "Cyrl" (Cyrillic)</dd>
    <dt><a name="def_region"><b>country (region)</b></a></dt>
    <dd>ISO 3166 alpha-2 country code or UN M.49 numeric-3 area code.
    You can find a full list of valid country and region codes in the
    IANA Language Subtag Registry (search for "Type: region").  The
    country (region) field is case insensitive, but   
 <code>Locale</code> always canonicalizes to upper case.</dd>
    <dd>Well-formed country/region values have
    the form <code>[a-zA-Z]{2} | [0-9]{3}</code></dd>
    <dd>Example: "US" (United States), "FR" (France), "029"
    (Caribbean)</dd>
    <dt><a name="def_variant"><b>variant</b></a></dt>
    <dd>Any arbitrary value used to indicate a variation of a
    <code>Locale</code>.  Where there are two or more variant values
    each indicating its own semantics, these values should be ordered
    by importance, with most important first, separated by
    underscore('_').  The variant field is case sensitive.</dd>
    <dd>Note: IETF BCP 47 places syntactic restrictions on variant
    subtags.  Also BCP 47 subtags are strictly used to indicate
    additional variations that define a language or its dialects that
    are not covered by any combinations of language, script and
    region subtags.  You can find a full list of valid variant codes
    in the IANA Language Subtag Registry (search for "Type: variant").   
 <p>However, the variant field in <code>Locale</code> has
    historically been used for any kind of variation, not just
    language variations.  For example, some supported variants
    available in Java SE Runtime Environments indicate alternative
    cultural behaviors such as calendar type or number script.  In
    BCP 47 this kind of information, which does not identify the
    language, is supported by extension subtags or private use
    subtags.</dd>
    <dd>Well-formed variant values have the form <code>SUBTAG
    (('_'|'-') SUBTAG)*</code> where <code>SUBTAG =
    [0-9][0-9a-zA-Z]{3} | [0-9a-zA-Z]{5,8}</code>. (Note: BCP 47 only
    uses hyphen ('-') as a delimiter, this is more lenient).</dd>
    <dd>Example: "polyton" (Polytonic Greek), "POSIX"</dd>
    <dt><a name="def_extensions"><b>extensions</b></a></dt>
    <dd>A map from single character keys to string values, indicating
    extensions apart from language identification.  The extensions in   
 <code>Locale</code> implement the semantics and syntax of BCP 47
    extension subtags and private use subtags. The extensions are
    case insensitive, but <code>Locale</code> canonicalizes all
    extension keys and values to lower case. Note that extensions
    cannot have empty values.</dd>
    <dd>Well-formed keys are single characters from the set
    <code>[0-9a-zA-Z]</code>.  Well-formed values have the form
    <code>SUBTAG ('-' SUBTAG)*</code> where for the key 'x'
    <code>SUBTAG = [0-9a-zA-Z]{1,8}</code> and for other keys
    <code>SUBTAG = [0-9a-zA-Z]{2,8}</code> (that is, 'x' allows
    single-character subtags).</dd>
    <dd>Example: key="u"/value="ca-japanese" (Japanese Calendar),
    key="x"/value="java-1-7"</dd>
  </dl>
  
 <b>Note:</b> Although BCP 47 requires field values to be registered
  in the IANA Language Subtag Registry, the <code>Locale</code> class
  does not provide any validation features.  The <code>Builder</code>
  only checks if an individual field satisfies the syntactic
  requirement (is well-formed), but does not validate the value
  itself.  See <code>Builder</code> for details. 
 <h3><a name="def_locale_extension">Unicode locale/language extension</a></h3>
  
 <p>UTS#35, "Unicode Locale Data Markup Language" defines optional
  attributes and keywords to override or refine the default behavior
  associated with a locale.  A keyword is represented by a pair of
  key and type.  For example, "nu-thai" indicates that Thai local
  digits (value:"thai") should be used for formatting numbers
  (key:"nu"). 
 <p>The keywords are mapped to a BCP 47 extension value using the
  extension key 'u' (<code>UNICODE_LOCALE_EXTENSION</code>).  The above
  example, "nu-thai", becomes the extension "u-nu-thai".code 
 <p>Thus, when a <code>Locale</code> object contains Unicode locale
  attributes and keywords, 
 <code>getExtension(UNICODE_LOCALE_EXTENSION)</code> will return a
  String representing this information, for example, "nu-thai".  The 
 <code>Locale</code> class also provides <code>getUnicodeLocaleAttributes</code>
 , <code>getUnicodeLocaleKeys</code>, and 
 <code>getUnicodeLocaleType</code> which allow you to access Unicode
  locale attributes and key/type pairs directly.  When represented as
  a string, the Unicode Locale Extension lists attributes
  alphabetically, followed by key/type sequences with keys listed
  alphabetically (the order of subtags comprising a key's type is
  fixed when the type is defined) 
 <p>A well-formed locale key has the form 
 <code>[0-9a-zA-Z]{2}</code>.  A well-formed locale type has the
  form <code>"" | [0-9a-zA-Z]{3,8} ('-' [0-9a-zA-Z]{3,8})*</code> (it
  can be empty, or a series of subtags 3-8 alphanums in length).  A
  well-formed locale attribute has the form 
 <code>[0-9a-zA-Z]{3,8}</code> (it is a single subtag with the same
  form as a locale type subtag). 
 <p>The Unicode locale extension specifies optional behavior in
  locale-sensitive services.  Although the LDML specification defines
  various keys and values, actual locale-sensitive service
  implementations in a Java Runtime Environment might not support any
  particular Unicode locale attributes or key/type pairs. 
 <h4>Creating a Locale</h4>
  
 <p>There are several different ways to create a <code>Locale</code>
  object. 
 <h5>Builder</h5>
  
 <p>Using <code>Builder</code> you can construct a <code>Locale</code> object
  that conforms to BCP 47 syntax. 
 <h5>Constructors</h5>
  
 <p>The <code>Locale</code> class provides three constructors: 
 <blockquote>
  @code

      <code>Locale(String language)</code>
      <code>Locale(String language, String country)</code>
      <code>Locale(String language, String country, String variant)</code>
   
@endcode
  </blockquote>
  These constructors allow you to create a <code>Locale</code> object
  with language, country and variant, but you cannot specify
  script or extensions. 
 <h5>Factory Methods</h5>
  
 <p>The method <code>forLanguageTag</code> creates a <code>Locale</code>
  object for a well-formed BCP 47 language tag. 
 <h5>Locale Constants</h5>
  
 <p>The <code>Locale</code> class provides a number of convenient constants
  that you can use to create <code>Locale</code> objects for commonly used
  locales. For example, the following creates a <code>Locale</code> object
  for the United States: 
 <blockquote>
  @code

      Locale.US 
  
@endcode
  </blockquote>
  
 <h4><a name="LocaleMatching">Locale Matching</a></h4>
  
 <p>If an application or a system is internationalized and provides localized
  resources for multiple locales, it sometimes needs to find one or more
  locales (or language tags) which meet each user's specific preferences. Note
  that a term "language tag" is used interchangeably with "locale" in this
  locale matching documentation. 
 <p>In order to do matching a user's preferred locales to a set of language
  tags, <a href="http://tools.ietf.org/html/rfc4647">RFC 4647 Matching of
  Language Tags</a> defines two mechanisms: filtering and lookup. 
 <em>Filtering</em> is used to get all matching locales, whereas 
 <em>lookup</em> is to choose the best matching locale.
  Matching is done case-insensitively. These matching mechanisms are described
  in the following sections. 
 <p>A user's preference is called a <em>Language Priority List</em> and is
  expressed as a list of language ranges. There are syntactically two types of
  language ranges: basic and extended. See 
 <code>Locale.LanguageRange</code> for details. 
 <h5>Filtering</h5>
  
 <p>The filtering operation returns all matching language tags. It is defined
  in RFC 4647 as follows:
  "In filtering, each language range represents the least specific language
  tag (that is, the language tag with fewest number of subtags) that is an
  acceptable match. All of the language tags in the matching set of tags will
  have an equal or greater number of subtags than the language range. Every
  non-wildcard subtag in the language range will appear in every one of the
  matching language tags." 
 <p>There are two types of filtering: filtering for basic language ranges
  (called "basic filtering") and filtering for extended language ranges
  (called "extended filtering"). They may return different results by what
  kind of language ranges are included in the given Language Priority List. 
 <code>Locale.FilteringMode</code> is a parameter to specify how filtering should
  be done. 
 <h5>Lookup</h5>
  
 <p>The lookup operation returns the best matching language tags. It is
  defined in RFC 4647 as follows:
  "By contrast with filtering, each language range represents the most
  specific tag that is an acceptable match.  The first matching tag found,
  according to the user's priority, is considered the closest match and is the
  item returned." 
 <p>For example, if a Language Priority List consists of two language ranges, 
 <code>"zh-Hant-TW"</code> and <code>"en-US"</code>, in prioritized order, lookup
  method progressively searches the language tags below in order to find the
  best matching language tag. 
 <blockquote>
  @code

     1. zh-Hant-TW
     2. zh-Hant
     3. zh
     4. en-US
     5. en 
  
@endcode
  </blockquote>
  If there is a language tag which matches completely to a language range
  above, the language tag is returned. 
 <p><code>"*"</code> is the special language range, and it is ignored in lookup. 
 <p>If multiple language tags match as a result of the subtag <code>'*'</code>
  included in a language range, the first matching language tag returned by
  an <code>Iterator</code> over a <code>Collection</code> of language tags is treated as
  the best matching one. 
 <h4>Use of Locale</h4>
  
 <p>Once you've created a <code>Locale</code> you can query it for information
  about itself. Use <code>getCountry</code> to get the country (or region)
  code and <code>getLanguage</code> to get the language code.
  You can use <code>getDisplayCountry</code> to get the
  name of the country suitable for displaying to the user. Similarly,
  you can use <code>getDisplayLanguage</code> to get the name of
  the language suitable for displaying to the user. Interestingly, the 
 <code>getDisplayXXX</code> methods are themselves locale-sensitive
  and have two versions: one that uses the default 
 <code>DISPLAY</code> locale and one
  that uses the locale specified as an argument. 
 <p>The Java Platform provides a number of classes that perform locale-sensitive
  operations. For example, the <code>NumberFormat</code> class formats
  numbers, currency, and percentages in a locale-sensitive manner. Classes
  such as <code>NumberFormat</code> have several convenience methods
  for creating a default object of that type. For example, the 
 <code>NumberFormat</code> class provides these three convenience methods
  for creating a default <code>NumberFormat</code> object: 
 <blockquote>
  @code

      NumberFormat.getInstance()
      NumberFormat.getCurrencyInstance()
      NumberFormat.getPercentInstance() 
  
@endcode
  </blockquote>
  Each of these methods has two variants; one with an explicit locale
  and one without; the latter uses the default 
 <code>FORMAT</code> locale: 
 <blockquote>
  @code

      NumberFormat.getInstance(myLocale)
      NumberFormat.getCurrencyInstance(myLocale)
      NumberFormat.getPercentInstance(myLocale) 
  
@endcode
  </blockquote>
  A <code>Locale</code> is the mechanism for identifying the kind of object
  (<code>NumberFormat</code>) that you would like to get. The locale is 
 <STRONG>just</STRONG> a mechanism for identifying objects, 
 <STRONG>not</STRONG> a container for the objects themselves. 
 <h4>Compatibility</h4>
  
 <p>In order to maintain compatibility with existing usage, Locale's
  constructors retain their behavior prior to the Java Runtime
  Environment version 1.7.  The same is largely true for the 
 <code>toString</code> method. Thus Locale objects can continue to
  be used as they were. In particular, clients who parse the output
  of toString into language, country, and variant fields can continue
  to do so (although this is strongly discouraged), although the
  variant field will have additional information in it if script or
  extensions are present. 
 <p>In addition, BCP 47 imposes syntax restrictions that are not
  imposed by Locale's constructors. This means that conversions
  between some Locales and BCP 47 language tags cannot be made without
  losing information. Thus <code>toLanguageTag</code> cannot
  represent the state of locales whose language, country, or variant
  do not conform to BCP 47. 
 <p>Because of these issues, it is recommended that clients migrate
  away from constructing non-conforming locales and use the 
 <code>forLanguageTag</code> and <code>Locale.Builder</code> APIs instead.
  Clients desiring a string representation of the complete locale can
  then always rely on <code>toLanguageTag</code> for this purpose. 
 <h5><a name="special_cases_constructor">Special cases</a></h5>
  
 <p>For compatibility reasons, two
  non-conforming locales are treated as special cases.  These are 
 <b><tt>ja_JP_JP</tt></b> and <b><tt>th_TH_TH</tt></b>. These are ill-formed
  in BCP 47 since the variants are too short. To ease migration to BCP 47,
  these are treated specially during construction.  These two cases (and only
  these) cause a constructor to generate an extension, all other values behave
  exactly as they did prior to Java 7. 
 <p>Java has used <tt>ja_JP_JP</tt> to represent Japanese as used in
  Japan together with the Japanese Imperial calendar. This is now
  representable using a Unicode locale extension, by specifying the
  Unicode locale key <tt>ca</tt> (for "calendar") and type 
 <tt>japanese</tt>. When the Locale constructor is called with the
  arguments "ja", "JP", "JP", the extension "u-ca-japanese" is
  automatically added. 
 <p>Java has used <tt>th_TH_TH</tt> to represent Thai as used in
  Thailand together with Thai digits. This is also now representable using
  a Unicode locale extension, by specifying the Unicode locale key 
 <tt>nu</tt> (for "number") and value <tt>thai</tt>. When the Locale
  constructor is called with the arguments "th", "TH", "TH", the
  extension "u-nu-thai" is automatically added. 
 <h5>Serialization</h5>
  
 <p>During serialization, writeObject writes all fields to the output
  stream, including extensions. 
 <p>During deserialization, readResolve adds extensions as described
  in <a href="#special_cases_constructor">Special Cases</a>, only
  for the two cases th_TH_TH and ja_JP_JP. 
 <h5>Legacy language codes</h5>
  
 <p>Locale's constructor has always converted three language codes to
  their earlier, obsoleted forms: <tt>he</tt> maps to <tt>iw</tt>,
  <tt>yi</tt> maps to <tt>ji</tt>, and <tt>id</tt> maps to 
 <tt>in</tt>.  This continues to be the case, in order to not break
  backwards compatibility. 
 <p>The APIs added in 1.7 map between the old and new language codes,
  maintaining the old codes internal to Locale (so that 
 <code>getLanguage</code> and <code>toString</code> reflect the old
  code), but using the new codes in the BCP 47 language tag APIs (so
  that <code>toLanguageTag</code> reflects the new one). This
  preserves the equivalence between Locales no matter which code or
  API is used to construct them. Java's default resource bundle
  lookup mechanism also implements this mapping, so that resources
  can be named using either convention, see <code>ResourceBundle.Control</code>.
  
 <h5>Three-letter language/country(region) codes</h5>
  
 <p>The Locale constructors have always specified that the language
  and the country param be two characters in length, although in
  practice they have accepted any length.  The specification has now
  been relaxed to allow language codes of two to eight characters and
  country (region) codes of two to three characters, and in
  particular, three-letter language codes and three-digit region
  codes as specified in the IANA Language Subtag Registry.  For
  compatibility, the implementation still does not impose a length
  constraint. 
 <a name="locale_data"></a><h4>Locale data</h4>
  <p>Note that locale data comes solely from ICU. User-supplied locale service providers (using
  the <code>java.text.spi</code> or <code>java.util.spi</code> mechanisms) are not supported. 
 <p>Here are the versions of ICU (and the corresponding CLDR and Unicode versions) used in
  various Android releases: 
 <table BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
  <tr><td>Android 1.5 (Cupcake)/Android 1.6 (Donut)/Android 2.0 (Eclair)</td>
      <td>ICU 3.8</td>
      <td><a href="http://cldr.unicode.org/index/downloads/cldr-1-5">CLDR 1.5</a></td>
      <td><a href="http://www.unicode.org/versions/Unicode5.0.0/">Unicode 5.0</a></td></tr>
  <tr><td>Android 2.2 (Froyo)</td>
      <td>ICU 4.2</td>
      <td><a href="http://cldr.unicode.org/index/downloads/cldr-1-7">CLDR 1.7</a></td>
      <td><a href="http://www.unicode.org/versions/Unicode5.1.0/">Unicode 5.1</a></td></tr>
  <tr><td>Android 2.3 (Gingerbread)/Android 3.0 (Honeycomb)</td>
      <td>ICU 4.4</td>
      <td><a href="http://cldr.unicode.org/index/downloads/cldr-1-8">CLDR 1.8</a></td>
      <td><a href="http://www.unicode.org/versions/Unicode5.2.0/">Unicode 5.2</a></td></tr>
  <tr><td>Android 4.0 (Ice Cream Sandwich)</td>
      <td><a href="http://site.icu-project.org/download/46">ICU 4.6</a></td>
      <td><a href="http://cldr.unicode.org/index/downloads/cldr-1-9">CLDR 1.9</a></td>
      <td><a href="http://www.unicode.org/versions/Unicode6.0.0/">Unicode 6.0</a></td></tr>
  <tr><td>Android 4.1 (Jelly Bean)</td>
      <td><a href="http://site.icu-project.org/download/48">ICU 4.8</a></td>
      <td><a href="http://cldr.unicode.org/index/downloads/cldr-2-0">CLDR 2.0</a></td>
      <td><a href="http://www.unicode.org/versions/Unicode6.0.0/">Unicode 6.0</a></td></tr>
  <tr><td>Android 4.3 (Jelly Bean MR2)</td>
      <td><a href="http://site.icu-project.org/download/50">ICU 50</a></td>
      <td><a href="http://cldr.unicode.org/index/downloads/cldr-22-1">CLDR 22.1</a></td>
      <td><a href="http://www.unicode.org/versions/Unicode6.2.0/">Unicode 6.2</a></td></tr>
  <tr><td>Android 4.4 (KitKat)</td>
      <td><a href="http://site.icu-project.org/download/51">ICU 51</a></td>
      <td><a href="http://cldr.unicode.org/index/downloads/cldr-23">CLDR 23</a></td>
      <td><a href="http://www.unicode.org/versions/Unicode6.2.0/">Unicode 6.2</a></td></tr>
  <tr><td>Android 5.0 (Lollipop)</td>
      <td><a href="http://site.icu-project.org/download/53">ICU 53</a></td>
      <td><a href="http://cldr.unicode.org/index/downloads/cldr-25">CLDR 25</a></td>
      <td><a href="http://www.unicode.org/versions/Unicode6.3.0/">Unicode 6.3</a></td></tr>
  <tr><td>Android 6.0 (Marshmallow)</td>
      <td><a href="http://site.icu-project.org/download/55">ICU 55.1</a></td>
      <td><a href="http://cldr.unicode.org/index/downloads/cldr-27">CLDR 27.0.1</a></td>
      <td><a href="http://www.unicode.org/versions/Unicode7.0.0/">Unicode 7.0</a></td></tr>
  <tr><td>Android 7.0 (Nougat)</td>
      <td><a href="http://site.icu-project.org/download/56">ICU 56.1</a></td>
      <td><a href="http://cldr.unicode.org/index/downloads/cldr-28">CLDR 28</a></td>
      <td><a href="http://www.unicode.org/versions/Unicode8.0.0/">Unicode 8.0</a></td></tr>
  <tr><td>Android 8.0 (Oreo)</td>
      <td><a href="http://site.icu-project.org/download/58">ICU 58.2</a></td>
      <td><a href="http://cldr.unicode.org/index/downloads/cldr-30">CLDR 30.0.3</a></td>
      <td><a href="http://www.unicode.org/versions/Unicode9.0.0/">Unicode 9.0</a></td></tr>
  <tr><td>Android 9.0 (Pie)</td>
      <td><a href="http://site.icu-project.org/download/60">ICU 60.2</a></td>
      <td><a href="http://cldr.unicode.org/index/downloads/cldr-32">CLDR 32.0.1</a></td>
      <td><a href="http://www.unicode.org/versions/Unicode10.0.0/">Unicode 10.0</a></td></tr>
  <tr><td>Android 10.0 (Q)</td>
      <td><a href="http://site.icu-project.org/download/63">ICU 63.2</a></td>
      <td><a href="http://cldr.unicode.org/index/downloads/cldr-34">CLDR 34</a></td>
      <td><a href="http://www.unicode.org/versions/Unicode11.0.0/">Unicode 11.0</a></td></tr>
  </table>
  
 <a name="default_locale"></a><h4>Be wary of the default locale</h4>
  <p>Note that there are many convenience methods that automatically use the default locale, but
  using them may lead to subtle bugs. 
 <p>The default locale is appropriate for tasks that involve presenting data to the user. In
  this case, you want to use the user's date/time formats, number
  formats, rules for conversion to lowercase, and so on. In this case, it's safe to use the
  convenience methods. 
 <p>The default locale is <i>not</i> appropriate for machine-readable output. The best choice
  there is usually <code>Locale.US</code>&nbsp;&ndash; this locale is guaranteed to be available on all
  devices, and the fact that it has no surprising special cases and is frequently used (especially
  for computer-computer communication) means that it tends to be the most efficient choice too. 
 <p>A common mistake is to implicitly use the default locale when producing output meant to be
  machine-readable. This tends to work on the developer's test devices (especially because so many
  developers use en_US), but fails when run on a device whose user is in a more complex locale. 
 <p>For example, if you're formatting integers some locales will use non-ASCII decimal
  digits. As another example, if you're formatting floating-point numbers some locales will use 
 <code>','</code> as the decimal point and <code>'.'</code> for digit grouping. That's correct for
  human-readable output, but likely to cause problems if presented to another
  computer (<code>Double.parseDouble</code> can't parse such a number, for example).
  You should also be wary of the <code>String.toLowerCase</code> and 
 <code>String.toUpperCase</code> overloads that don't take a <code>Locale</code>: in Turkey, for example,
  the characters <code>'i'</code> and <code>'I'</code> won't be converted to <code>'I'</code> and <code>'i'</code>.
  This is the correct behavior for Turkish text (such as user input), but inappropriate for, say,
  HTTP headers.
 - seealso: Builder
 - seealso: ResourceBundle
 - seealso: java.text.Format
 - seealso: java.text.NumberFormat
 - seealso: java.text.Collator
 @author Mark Davis
 @since 1.1
 */
@interface JavaUtilLocale : NSObject < NSCopying, JavaIoSerializable >

#pragma mark Public

/*!
 @brief Construct a locale from a language code.
 This constructor normalizes the language value to lowercase. 
 <p>
  <b>Note:</b>
  <ul>
  <li>ISO 639 is not a stable standard; some of the language codes it defines
  (specifically "iw", "ji", and "in") have changed.  This constructor accepts both the
  old codes ("iw", "ji", and "in") and the new codes ("he", "yi", and "id"), but all other
  API on Locale will return only the OLD codes. 
 <li>For backward compatibility reasons, this constructor does not make
  any syntactic checks on the input. 
 </ul>
 @param language An ISO 639 alpha-2 or alpha-3 language code, or a language subtag  up to 8 characters in length.  See the 
  <code> Locale </code>  class description about  valid language values.
 @throw NullPointerExceptionthrown if argument is null.
 @since 1.4
 */
- (instancetype __nonnull)initWithNSString:(NSString *)language;

/*!
 @brief Construct a locale from language and country.
 This constructor normalizes the language value to lowercase and
  the country value to uppercase. 
 <p>
  <b>Note:</b>
  <ul>
  <li>ISO 639 is not a stable standard; some of the language codes it defines
  (specifically "iw", "ji", and "in") have changed.  This constructor accepts both the
  old codes ("iw", "ji", and "in") and the new codes ("he", "yi", and "id"), but all other
  API on Locale will return only the OLD codes. 
 <li>For backward compatibility reasons, this constructor does not make
  any syntactic checks on the input. 
 </ul>
 @param language An ISO 639 alpha-2 or alpha-3 language code, or a language subtag  up to 8 characters in length.  See the 
  <code> Locale </code>  class description about  valid language values.
 @param country An ISO 3166 alpha-2 country code or a UN M.49 numeric-3 area code.  See the 
  <code> Locale </code>  class description about valid country values.
 @throw NullPointerExceptionthrown if either argument is null.
 */
- (instancetype __nonnull)initWithNSString:(NSString *)language
                              withNSString:(NSString *)country;

/*!
 @brief Construct a locale from language, country and variant.
 This constructor normalizes the language value to lowercase and
  the country value to uppercase. 
 <p>
  <b>Note:</b>
  <ul>
  <li>ISO 639 is not a stable standard; some of the language codes it defines
  (specifically "iw", "ji", and "in") have changed.  This constructor accepts both the
  old codes ("iw", "ji", and "in") and the new codes ("he", "yi", and "id"), but all other
  API on Locale will return only the OLD codes. 
 <li>For backward compatibility reasons, this constructor does not make
  any syntactic checks on the input. 
 <li>The two cases ("ja", "JP", "JP") and ("th", "TH", "TH") are handled specially,
  see <a href="#special_cases_constructor">Special Cases</a> for more information. 
 </ul>
 @param language An ISO 639 alpha-2 or alpha-3 language code, or a language subtag  up to 8 characters in length.  See the 
  <code> Locale </code>  class description about  valid language values.
 @param country An ISO 3166 alpha-2 country code or a UN M.49 numeric-3 area code.  See the 
  <code> Locale </code>  class description about valid country values.
 @param variant Any arbitrary value used to indicate a variation of a  <code> Locale </code>
  .  See the  <code> Locale </code>  class description for the details.
 @throw NullPointerExceptionthrown if any argument is null.
 */
- (instancetype __nonnull)initWithNSString:(NSString *)language
                              withNSString:(NSString *)country
                              withNSString:(NSString *)variant;

/*!
 */
+ (NSString *)adjustLanguageCodeWithNSString:(NSString *)languageCode;

/*!
 @brief Overrides Cloneable.
 */
- (id __nonnull)java_clone;

/*!
 @brief Returns true if this Locale is equal to another object.A Locale is
  deemed equal to another Locale with identical language, script, country,
  variant and extensions, and unequal to all other objects.
 @return true if this Locale is equal to the specified object.
 */
- (jboolean)isEqual:(id)obj;

/*!
 @brief Returns a list of matching <code>Locale</code> instances using the filtering
  mechanism defined in RFC 4647.This is equivalent to 
 <code>filter(List, Collection, FilteringMode)</code> when <code>mode</code> is 
 <code>FilteringMode.AUTOSELECT_FILTERING</code>.
 @param priorityList user's Language Priority List in which each language      tag is sorted in descending order based on priority or weight
 @param locales<code>Locale</code>  instances used for matching
 @return a list of <code>Locale</code> instances for matching language tags
      sorted in descending order based on priority or weight, or an empty
      list if nothing matches. The list is modifiable.
 @throw NullPointerExceptionif <code>priorityList</code> or <code>locales</code>
      is <code>null</code>
 @since 1.8
 */
+ (id<JavaUtilList> __nonnull)filterWithJavaUtilList:(id<JavaUtilList>)priorityList
                              withJavaUtilCollection:(id<JavaUtilCollection>)locales;

/*!
 @brief Returns a list of matching <code>Locale</code> instances using the filtering
  mechanism defined in RFC 4647.
 @param priorityList user's Language Priority List in which each language      tag is sorted in descending order based on priority or weight
 @param locales<code>Locale</code>  instances used for matching
 @param mode filtering mode
 @return a list of <code>Locale</code> instances for matching language tags
      sorted in descending order based on priority or weight, or an empty
      list if nothing matches. The list is modifiable.
 @throw NullPointerExceptionif <code>priorityList</code> or <code>locales</code>
      is <code>null</code>
 @throw IllegalArgumentExceptionif one or more extended language ranges
      are included in the given list when     
 <code>FilteringMode.REJECT_EXTENDED_RANGES</code> is specified
 @since 1.8
 */
+ (id<JavaUtilList> __nonnull)filterWithJavaUtilList:(id<JavaUtilList>)priorityList
                              withJavaUtilCollection:(id<JavaUtilCollection>)locales
                    withJavaUtilLocale_FilteringMode:(JavaUtilLocale_FilteringMode *)mode;

/*!
 @brief Returns a list of matching languages tags using the basic filtering
  mechanism defined in RFC 4647.This is equivalent to 
 <code>filterTags(List, Collection, FilteringMode)</code> when <code>mode</code>
  is <code>FilteringMode.AUTOSELECT_FILTERING</code>.
 @param priorityList user's Language Priority List in which each language      tag is sorted in descending order based on priority or weight
 @param tags language tags
 @return a list of matching language tags sorted in descending order
      based on priority or weight, or an empty list if nothing matches.
      The list is modifiable.
 @throw NullPointerExceptionif <code>priorityList</code> or <code>tags</code> is
      <code>null</code>
 @since 1.8
 */
+ (id<JavaUtilList> __nonnull)filterTagsWithJavaUtilList:(id<JavaUtilList>)priorityList
                                  withJavaUtilCollection:(id<JavaUtilCollection>)tags;

/*!
 @brief Returns a list of matching languages tags using the basic filtering
  mechanism defined in RFC 4647.
 @param priorityList user's Language Priority List in which each language      tag is sorted in descending order based on priority or weight
 @param tags language tags
 @param mode filtering mode
 @return a list of matching language tags sorted in descending order
      based on priority or weight, or an empty list if nothing matches.
      The list is modifiable.
 @throw NullPointerExceptionif <code>priorityList</code> or <code>tags</code> is
      <code>null</code>
 @throw IllegalArgumentExceptionif one or more extended language ranges
      are included in the given list when     
 <code>FilteringMode.REJECT_EXTENDED_RANGES</code> is specified
 @since 1.8
 */
+ (id<JavaUtilList> __nonnull)filterTagsWithJavaUtilList:(id<JavaUtilList>)priorityList
                                  withJavaUtilCollection:(id<JavaUtilCollection>)tags
                        withJavaUtilLocale_FilteringMode:(JavaUtilLocale_FilteringMode *)mode;

/*!
 @brief Returns a locale for the specified IETF BCP 47 language tag string.
 <p>If the specified language tag contains any ill-formed subtags,
  the first such subtag and all following subtags are ignored.  Compare
  to <code>Locale.Builder.setLanguageTag</code> which throws an exception
  in this case. 
 <p>The following <b>conversions</b> are performed:<ul>
  
 <li>The language code "und" is mapped to language "". 
 <li>The language codes "he", "yi", and "id" are mapped to "iw",
  "ji", and "in" respectively. (This is the same canonicalization
  that's done in Locale's constructors.) 
 <li>The portion of a private use subtag prefixed by "lvariant",
  if any, is removed and appended to the variant field in the
  result locale (without case normalization).  If it is then
  empty, the private use subtag is discarded: 
 @code

      Locale loc;
      loc = Locale.forLanguageTag("en-US-x-lvariant-POSIX");
      loc.getVariant(); // returns "POSIX"
      loc.getExtension('x'); // returns null
      loc = Locale.forLanguageTag("de-POSIX-x-URP-lvariant-Abc-Def");
      loc.getVariant(); // returns "POSIX_Abc_Def"
      loc.getExtension('x'); // returns "urp" 
  
@endcode
  
 <li>When the languageTag argument contains an extlang subtag,
  the first such subtag is used as the language, and the primary
  language subtag and other extlang subtags are ignored: 
 @code

      Locale.forLanguageTag("ar-aao").getLanguage(); // returns "aao"
      Locale.forLanguageTag("en-abc-def-us").toString(); // returns "abc_US" 
  
@endcode
  
 <li>Case is normalized except for variant tags, which are left
  unchanged.  Language is normalized to lower case, script to
  title case, country to upper case, and extensions to lower
  case. 
 <li>If, after processing, the locale would exactly match either
  ja_JP_JP or th_TH_TH with no extensions, the appropriate
  extensions are added as though the constructor had been called: 
 @code

     Locale.forLanguageTag("ja-JP-x-lvariant-JP").toLanguageTag();
     // returns "ja-JP-u-ca-japanese-x-lvariant-JP"
     Locale.forLanguageTag("th-TH-x-lvariant-TH").toLanguageTag();
     // returns "th-TH-u-nu-thai-x-lvariant-TH" 
  
@endcode</ul>
  
 <p>This implements the 'Language-Tag' production of BCP47, and
  so supports grandfathered (regular and irregular) as well as
  private use language tags.  Stand alone private use tags are
  represented as empty language and extension 'x-whatever',
  and grandfathered tags are converted to their canonical replacements
  where they exist. 
 <p>Grandfathered tags with canonical replacements are as follows: 
 <table summary="Grandfathered tags with canonical replacements">
  <tbody align="center">
  <tr><th>grandfathered tag</th><th>&nbsp;</th><th>modern replacement</th></tr>
  <tr><td>art-lojban</td><td>&nbsp;</td><td>jbo</td></tr>
  <tr><td>i-ami</td><td>&nbsp;</td><td>ami</td></tr>
  <tr><td>i-bnn</td><td>&nbsp;</td><td>bnn</td></tr>
  <tr><td>i-hak</td><td>&nbsp;</td><td>hak</td></tr>
  <tr><td>i-klingon</td><td>&nbsp;</td><td>tlh</td></tr>
  <tr><td>i-lux</td><td>&nbsp;</td><td>lb</td></tr>
  <tr><td>i-navajo</td><td>&nbsp;</td><td>nv</td></tr>
  <tr><td>i-pwn</td><td>&nbsp;</td><td>pwn</td></tr>
  <tr><td>i-tao</td><td>&nbsp;</td><td>tao</td></tr>
  <tr><td>i-tay</td><td>&nbsp;</td><td>tay</td></tr>
  <tr><td>i-tsu</td><td>&nbsp;</td><td>tsu</td></tr>
  <tr><td>no-bok</td><td>&nbsp;</td><td>nb</td></tr>
  <tr><td>no-nyn</td><td>&nbsp;</td><td>nn</td></tr>
  <tr><td>sgn-BE-FR</td><td>&nbsp;</td><td>sfb</td></tr>
  <tr><td>sgn-BE-NL</td><td>&nbsp;</td><td>vgt</td></tr>
  <tr><td>sgn-CH-DE</td><td>&nbsp;</td><td>sgg</td></tr>
  <tr><td>zh-guoyu</td><td>&nbsp;</td><td>cmn</td></tr>
  <tr><td>zh-hakka</td><td>&nbsp;</td><td>hak</td></tr>
  <tr><td>zh-min-nan</td><td>&nbsp;</td><td>nan</td></tr>
  <tr><td>zh-xiang</td><td>&nbsp;</td><td>hsn</td></tr>
  </tbody>
  </table>
  
 <p>Grandfathered tags with no modern replacement will be
  converted as follows: 
 <table summary="Grandfathered tags with no modern replacement">
  <tbody align="center">
  <tr><th>grandfathered tag</th><th>&nbsp;</th><th>converts to</th></tr>
  <tr><td>cel-gaulish</td><td>&nbsp;</td><td>xtg-x-cel-gaulish</td></tr>
  <tr><td>en-GB-oed</td><td>&nbsp;</td><td>en-GB-x-oed</td></tr>
  <tr><td>i-default</td><td>&nbsp;</td><td>en-x-i-default</td></tr>
  <tr><td>i-enochian</td><td>&nbsp;</td><td>und-x-i-enochian</td></tr>
  <tr><td>i-mingo</td><td>&nbsp;</td><td>see-x-i-mingo</td></tr>
  <tr><td>zh-min</td><td>&nbsp;</td><td>nan-x-zh-min</td></tr>
  </tbody>
  </table>
  
 <p>For a list of all grandfathered tags, see the
  IANA Language Subtag Registry (search for "Type: grandfathered"). 
 <p><b>Note</b>: there is no guarantee that <code>toLanguageTag</code>
  and <code>forLanguageTag</code> will round-trip.
 @param languageTag the language tag
 @return The locale that best represents the language tag.
 @throw NullPointerExceptionif <code>languageTag</code> is <code>null</code>
 - seealso: #toLanguageTag()
 - seealso: java.util.Locale.Builder#setLanguageTag(String)
 @since 1.7
 */
+ (JavaUtilLocale * __nonnull)forLanguageTagWithNSString:(NSString *)languageTag;

/*!
 @brief Returns an array of all installed locales.
 @return An array of installed locales.
 */
+ (IOSObjectArray * __nonnull)getAvailableLocales;

/*!
 @brief Returns the country/region code for this locale, which should
  either be the empty string, an uppercase ISO 3166 2-letter code,
  or a UN M.49 3-digit code.
 @return The country/region code, or the empty string if none is defined.
 - seealso: #getDisplayCountry
 */
- (NSString * __nonnull)getCountry;

/*!
 @brief Gets the current value of the default locale for this instance
  of the Java Virtual Machine.
 <p>
  The Java Virtual Machine sets the default locale during startup
  based on the host environment. It is used by many locale-sensitive
  methods if no locale is explicitly specified.
  It can be changed using the 
 <code>setDefault</code> method.
 @return the default locale for this instance of the Java Virtual Machine
 */
+ (JavaUtilLocale * __nonnull)getDefault;

/*!
 @brief Gets the current value of the default locale for the specified Category
  for this instance of the Java Virtual Machine.
 <p>
  The Java Virtual Machine sets the default locale during startup based
  on the host environment. It is used by many locale-sensitive methods
  if no locale is explicitly specified. It can be changed using the
  setDefault(Locale.Category, Locale) method.
 @param category - the specified category to get the default locale
 @throw NullPointerException- if category is null
 @return the default locale for the specified Category for this instance
      of the Java Virtual Machine
 - seealso: #setDefault(Locale.Category, Locale)
 @since 1.7
 */
+ (JavaUtilLocale * __nonnull)getDefaultWithJavaUtilLocale_Category:(JavaUtilLocale_Category *)category;

/*!
 @brief Returns a name for the locale's country that is appropriate for display to the
  user.
 If possible, the name returned will be localized for the default 
 <code>DISPLAY</code> locale.
  For example, if the locale is fr_FR and the default 
 <code>DISPLAY</code> locale
  is en_US, getDisplayCountry() will return "France"; if the locale is en_US and
  the default <code>DISPLAY</code> locale is fr_FR,
  getDisplayCountry() will return "Etats-Unis".
  If the name returned cannot be localized for the default 
 <code>DISPLAY</code> locale,
  (say, we don't have a Japanese name for Croatia),
  this function falls back on the English name, and uses the ISO code as a last-resort
  value.  If the locale doesn't specify a country, this function returns the empty string.
 @return The name of the country appropriate to the locale.
 */
- (NSString * __nonnull)getDisplayCountry;

/*!
 @brief Returns the name of this locale's country, localized to <code>locale</code>.
 Returns the empty string if this locale does not correspond to a specific
  country.
 */
- (NSString * __nonnull)getDisplayCountryWithJavaUtilLocale:(JavaUtilLocale *)locale;

/*!
 @brief Returns a name for the locale's language that is appropriate for display to the
  user.
 If possible, the name returned will be localized for the default 
 <code>DISPLAY</code> locale.
  For example, if the locale is fr_FR and the default 
 <code>DISPLAY</code> locale
  is en_US, getDisplayLanguage() will return "French"; if the locale is en_US and
  the default <code>DISPLAY</code> locale is fr_FR,
  getDisplayLanguage() will return "anglais".
  If the name returned cannot be localized for the default 
 <code>DISPLAY</code> locale,
  (say, we don't have a Japanese name for Croatian),
  this function falls back on the English name, and uses the ISO code as a last-resort
  value.  If the locale doesn't specify a language, this function returns the empty string.
 @return The name of the display language.
 */
- (NSString * __nonnull)getDisplayLanguage;

/*!
 @brief Returns the name of this locale's language, localized to <code>locale</code>.
 If the language name is unknown, the language code is returned.
 */
- (NSString * __nonnull)getDisplayLanguageWithJavaUtilLocale:(JavaUtilLocale *)locale;

/*!
 @brief Returns a name for the locale that is appropriate for display to the
  user.This will be the values returned by getDisplayLanguage(),
  getDisplayScript(), getDisplayCountry(), and getDisplayVariant() assembled
  into a single string.
 The the non-empty values are used in order,
  with the second and subsequent names in parentheses.  For example: 
 <blockquote>
  language (script, country, variant)<br>
  language (country)<br>
  language (variant)<br>
  script (country)<br>
  country<br>
  </blockquote>
  depending on which fields are specified in the locale.  If the
  language, script, country, and variant fields are all empty,
  this function returns the empty string.
 @return The name of the locale appropriate to display.
 */
- (NSString * __nonnull)getDisplayName;

/*!
 @brief Returns this locale's language name, country name, and variant, localized
  to <code>locale</code>.The exact output form depends on whether this locale
  corresponds to a specific language, script, country and variant.
 <p>For example: 
 <ul>
  <li><code>new Locale("en").getDisplayName(Locale.US)</code> -> <code>English</code>
  <li><code>new Locale("en", "US").getDisplayName(Locale.US)</code> -> <code>English (United States)</code>
  <li><code>new Locale("en", "US", "POSIX").getDisplayName(Locale.US)</code> -> <code>English (United States,Computer)</code>
  <li><code>Locale.forLanguageTag("zh-Hant-CN").getDisplayName(Locale.US)</code> -> <code>Chinese (Traditional Han,China)</code>
  <li><code>new Locale("en").getDisplayName(Locale.FRANCE)</code> -> <code>anglais</code>
  <li><code>new Locale("en", "US").getDisplayName(Locale.FRANCE)</code> -> <code>anglais (États-Unis)</code>
  <li><code>new Locale("en", "US", "POSIX").getDisplayName(Locale.FRANCE)</code> -> <code>anglais (États-Unis,informatique)</code>.
  </ul>
 */
- (NSString * __nonnull)getDisplayNameWithJavaUtilLocale:(JavaUtilLocale *)locale;

/*!
 @brief Returns a name for the the locale's script that is appropriate for display to
  the user.If possible, the name will be localized for the default 
 <code>DISPLAY</code> locale.
 Returns
  the empty string if this locale doesn't specify a script code.
 @return the display name of the script code for the current default
      <code>DISPLAY</code> locale
 @since 1.7
 */
- (NSString * __nonnull)getDisplayScript;

/*!
 @brief Returns a name for the locale's script that is appropriate
  for display to the user.If possible, the name will be
  localized for the given locale.
 Returns the empty string if
  this locale doesn't specify a script code.
 @param inLocale The locale for which to retrieve the display script.
 @return the display name of the script code for the current default 
 <code>DISPLAY</code> locale
 @throw NullPointerExceptionif <code>inLocale</code> is <code>null</code>
 @since 1.7
 */
- (NSString * __nonnull)getDisplayScriptWithJavaUtilLocale:(JavaUtilLocale *)inLocale;

/*!
 @brief Returns a name for the locale's variant code that is appropriate for display to the
  user.If possible, the name will be localized for the default 
 <code>DISPLAY</code> locale.
 If the locale
  doesn't specify a variant code, this function returns the empty string.
 @return The name of the display variant code appropriate to the locale.
 */
- (NSString * __nonnull)getDisplayVariant;

/*!
 @brief Returns a name for the locale's variant code that is appropriate for display to the
  user.If possible, the name will be localized for inLocale.
 If the locale
  doesn't specify a variant code, this function returns the empty string.
 @param inLocale The locale for which to retrieve the display variant code.
 @return The name of the display variant code appropriate to the given locale.
 @throw NullPointerExceptionif <code>inLocale</code> is <code>null</code>
 */
- (NSString * __nonnull)getDisplayVariantWithJavaUtilLocale:(JavaUtilLocale *)inLocale;

/*!
 @brief Returns the extension (or private use) value associated with
  the specified key, or null if there is no extension
  associated with the key.To be well-formed, the key must be one
  of <code>[0-9A-Za-z]</code>.
 Keys are case-insensitive, so
  for example 'z' and 'Z' represent the same extension.
 @param key the extension key
 @return The extension, or null if this locale defines no
  extension for the specified key.
 @throw IllegalArgumentExceptionif key is not well-formed
 - seealso: #PRIVATE_USE_EXTENSION
 - seealso: #UNICODE_LOCALE_EXTENSION
 @since 1.7
 */
- (NSString * __nullable)getExtensionWithChar:(jchar)key;

/*!
 @brief Returns the set of extension keys associated with this locale, or the
  empty set if it has no extensions.The returned set is unmodifiable.
 The keys will all be lower-case.
 @return The set of extension keys, or the empty set if this locale has
  no extensions.
 @since 1.7
 */
- (id<JavaUtilSet> __nonnull)getExtensionKeys;

/*!
 @brief Returns a three-letter abbreviation for this locale's country.
 If the country matches an ISO 3166-1 alpha-2 code, the
  corresponding ISO 3166-1 alpha-3 uppercase code is returned.
  If the locale doesn't specify a country, this will be the empty
  string. 
 <p>The ISO 3166-1 codes can be found on-line.
 @return A three-letter abbreviation of this locale's country.
 @throw MissingResourceExceptionThrows MissingResourceException if the
  three-letter country abbreviation is not available for this locale.
 */
- (NSString * __nonnull)getISO3Country;

/*!
 @brief Returns a three-letter abbreviation of this locale's language.
 If the language matches an ISO 639-1 two-letter code, the
  corresponding ISO 639-2/T three-letter lowercase code is
  returned.  The ISO 639-2 language codes can be found on-line,
  see "Codes for the Representation of Names of Languages Part 2:
  Alpha-3 Code".  If the locale specifies a three-letter
  language, the language is returned as is.  If the locale does
  not specify a language the empty string is returned.
 @return A three-letter abbreviation of this locale's language.
 @throw MissingResourceExceptionThrows MissingResourceException if
  three-letter language abbreviation is not available for this locale.
 */
- (NSString * __nonnull)getISO3Language;

/*!
 @brief Returns a list of all 2-letter country codes defined in ISO 3166.
 Can be used to create Locales. 
 <p>
  <b>Note:</b> The <code>Locale</code> class also supports other codes for
  country (region), such as 3-letter numeric UN M.49 area codes.
  Therefore, the list returned by this method does not contain ALL valid
  codes that can be used to create Locales.
 @return An array of ISO 3166 two-letter country codes.
 */
+ (IOSObjectArray * __nonnull)getISOCountries;

/*!
 @brief Returns a list of all 2-letter language codes defined in ISO 639.
 Can be used to create Locales. 
 <p>
  <b>Note:</b>
  <ul>
  <li>ISO 639 is not a stable standard&mdash; some languages' codes have changed.
  The list this function returns includes both the new and the old codes for the
  languages whose codes have changed. 
 <li>The <code>Locale</code> class also supports language codes up to
  8 characters in length.  Therefore, the list returned by this method does
  not contain ALL valid codes that can be used to create Locales. 
 </ul>
 @return Am array of ISO 639 two-letter language codes.
 */
+ (IOSObjectArray * __nonnull)getISOLanguages;

/*!
 @brief Returns the language code of this Locale.
 <p><b>Note:</b> ISO 639 is not a stable standard&mdash; some languages' codes have changed.
  Locale's constructor recognizes both the new and the old codes for the languages
  whose codes have changed, but this function always returns the old code.  If you
  want to check for a specific language whose code has changed, don't do 
 @code

  if (locale.getLanguage().equals("he")) // BAD!
     ... 
  
@endcode
  Instead, do 
 @code

  if (locale.getLanguage().equals(new Locale("he").getLanguage()))
     ... 
  
@endcode
 @return The language code, or the empty string if none is defined.
 - seealso: #getDisplayLanguage
 */
- (NSString * __nonnull)getLanguage;

/*!
 @brief Returns the script for this locale, which should
  either be the empty string or an ISO 15924 4-letter script
  code.The first letter is uppercase and the rest are
  lowercase, for example, 'Latn', 'Cyrl'.
 @return The script code, or the empty string if none is defined.
 - seealso: #getDisplayScript
 @since 1.7
 */
- (NSString * __nonnull)getScript;

/*!
 @brief Returns the set of unicode locale attributes associated with
  this locale, or the empty set if it has no attributes.The
  returned set is unmodifiable.
 @return The set of attributes.
 @since 1.7
 */
- (id<JavaUtilSet> __nonnull)getUnicodeLocaleAttributes;

/*!
 @brief Returns the set of Unicode locale keys defined by this locale, or the empty set if
  this locale has none.The returned set is immutable.
 Keys are all lower case.
 @return The set of Unicode locale keys, or the empty set if this locale has
  no Unicode locale keywords.
 @since 1.7
 */
- (id<JavaUtilSet> __nonnull)getUnicodeLocaleKeys;

/*!
 @brief Returns the Unicode locale type associated with the specified Unicode locale key
  for this locale.Returns the empty string for keys that are defined with no type.
 Returns null if the key is not defined. Keys are case-insensitive. The key must
  be two alphanumeric characters ([0-9a-zA-Z]), or an IllegalArgumentException is
  thrown.
 @param key the Unicode locale key
 @return The Unicode locale type associated with the key, or null if the
  locale does not define the key.
 @throw IllegalArgumentExceptionif the key is not well-formed
 @throw NullPointerExceptionif <code>key</code> is null
 @since 1.7
 */
- (NSString * __nullable)getUnicodeLocaleTypeWithNSString:(NSString *)key;

/*!
 @brief Returns the variant code for this locale.
 @return The variant code, or the empty string if none is defined.
 - seealso: #getDisplayVariant
 */
- (NSString * __nonnull)getVariant;

/*!
 @brief Returns <code>true</code> if this <code>Locale</code> has any <a href="#def_extensions">
  extensions</a>.
 @return <code>true</code> if this <code>Locale</code> has any extensions
 @since 1.8
 */
- (jboolean)hasExtensions;

/*!
 @brief Override hashCode.
 Since Locales are often used in hashtables, caches the value
  for speed.
 */
- (NSUInteger)hash;

/*!
 */
+ (JavaUtilLocale *)initDefault OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Returns a <code>Locale</code> instance for the best-matching language
  tag using the lookup mechanism defined in RFC 4647.
 @param priorityList user's Language Priority List in which each language      tag is sorted in descending order based on priority or weight
 @param locales<code>Locale</code>  instances used for matching
 @return the best matching <code>Locale</code> instance chosen based on
      priority or weight, or <code>null</code> if nothing matches.
 @throw NullPointerExceptionif <code>priorityList</code> or <code>tags</code> is
      <code>null</code>
 @since 1.8
 */
+ (JavaUtilLocale * __nullable)lookupWithJavaUtilList:(id<JavaUtilList>)priorityList
                               withJavaUtilCollection:(id<JavaUtilCollection>)locales;

/*!
 @brief Returns the best-matching language tag using the lookup mechanism
  defined in RFC 4647.
 @param priorityList user's Language Priority List in which each language      tag is sorted in descending order based on priority or weight
 @param tags language tangs used for matching
 @return the best matching language tag chosen based on priority or
      weight, or <code>null</code> if nothing matches.
 @throw NullPointerExceptionif <code>priorityList</code> or <code>tags</code> is
      <code>null</code>
 @since 1.8
 */
+ (NSString * __nullable)lookupTagWithJavaUtilList:(id<JavaUtilList>)priorityList
                            withJavaUtilCollection:(id<JavaUtilCollection>)tags;

/*!
 @brief Sets the default locale for the specified Category for this instance
  of the Java Virtual Machine.This does not affect the host locale.
 <p>
  If there is a security manager, its checkPermission method is called
  with a PropertyPermission("user.language", "write") permission before
  the default locale is changed. 
 <p>
  The Java Virtual Machine sets the default locale during startup based
  on the host environment. It is used by many locale-sensitive methods
  if no locale is explicitly specified. 
 <p>
  Since changing the default locale may affect many different areas of
  functionality, this method should only be used if the caller is
  prepared to reinitialize locale-sensitive code running within the
  same Java Virtual Machine. 
 <p>
 @param category - the specified category to set the default locale
 @param newLocale - the new default locale
 @throw SecurityException- if a security manager exists and its
      checkPermission method doesn't allow the operation.
 @throw NullPointerException- if category and/or newLocale is null
 - seealso: SecurityManager#checkPermission(java.security.Permission)
 - seealso: PropertyPermission
 - seealso: #getDefault(Locale.Category)
 @since 1.7
 */
+ (void)setDefaultWithJavaUtilLocale_Category:(JavaUtilLocale_Category *)category
                           withJavaUtilLocale:(JavaUtilLocale *)newLocale;

/*!
 @brief Sets the default locale for this instance of the Java Virtual Machine.
 This does not affect the host locale. 
 <p>
  If there is a security manager, its <code>checkPermission</code>
  method is called with a <code>PropertyPermission("user.language", "write")</code>
  permission before the default locale is changed. 
 <p>
  The Java Virtual Machine sets the default locale during startup
  based on the host environment. It is used by many locale-sensitive
  methods if no locale is explicitly specified. 
 <p>
  Since changing the default locale may affect many different areas
  of functionality, this method should only be used if the caller
  is prepared to reinitialize locale-sensitive code running
  within the same Java Virtual Machine. 
 <p>
  By setting the default locale with this method, all of the default
  locales for each Category are also set to the specified default locale.
 @throw SecurityException
 if a security manager exists and its
         <code>checkPermission</code> method doesn't allow the operation.
 @throw NullPointerExceptionif <code>newLocale</code> is null
 @param newLocale the new default locale
 - seealso: SecurityManager#checkPermission
 - seealso: java.util.PropertyPermission
 */
+ (void)setDefaultWithJavaUtilLocale:(JavaUtilLocale *)newLocale;

/*!
 @brief Returns a copy of this <code>Locale</code> with no <a href="#def_extensions">
  extensions</a>.If this <code>Locale</code> has no extensions, this <code>Locale</code>
  is returned.
 @return a copy of this <code>Locale</code> with no extensions, or <code>this</code>
          if <code>this</code> has no extensions
 @since 1.8
 */
- (JavaUtilLocale * __nonnull)stripExtensions;

/*!
 @brief Returns a well-formed IETF BCP 47 language tag representing
  this locale.
 <p>If this <code>Locale</code> has a language, country, or
  variant that does not satisfy the IETF BCP 47 language tag
  syntax requirements, this method handles these fields as
  described below: 
 <p><b>Language:</b> If language is empty, or not <a href="#def_language">
 well-formed</a> (for example "a" or
  "e2"), it will be emitted as "und" (Undetermined). 
 <p><b>Country:</b> If country is not <a href="#def_region">
 well-formed</a> (for example "12" or "USA"),
  it will be omitted. 
 <p><b>Variant:</b> If variant <b>is</b> <a href="#def_variant">
 well-formed</a>, each sub-segment
  (delimited by '-' or '_') is emitted as a subtag.  Otherwise: 
 <ul>
  
 <li>if all sub-segments match <code>[0-9a-zA-Z]{1,8}</code>
  (for example "WIN" or "Oracle_JDK_Standard_Edition"), the first
  ill-formed sub-segment and all following will be appended to
  the private use subtag.  The first appended subtag will be
  "lvariant", followed by the sub-segments in order, separated by
  hyphen. For example, "x-lvariant-WIN",
  "Oracle-x-lvariant-JDK-Standard-Edition". 
 <li>if any sub-segment does not match 
 <code>[0-9a-zA-Z]{1,8}</code>, the variant will be truncated
  and the problematic sub-segment and all following sub-segments
  will be omitted.  If the remainder is non-empty, it will be
  emitted as a private use subtag as above (even if the remainder
  turns out to be well-formed).  For example,
  "Solaris_isjustthecoolestthing" is emitted as
  "x-lvariant-Solaris", not as "solaris".</li></ul>
  
 <p><b>Special Conversions:</b> Java supports some old locale
  representations, including deprecated ISO language codes,
  for compatibility. This method performs the following
  conversions: 
 <ul>
  
 <li>Deprecated ISO language codes "iw", "ji", and "in" are
  converted to "he", "yi", and "id", respectively. 
 <li>A locale with language "no", country "NO", and variant
  "NY", representing Norwegian Nynorsk (Norway), is converted
  to a language tag "nn-NO".</li></ul>
  
 <p><b>Note:</b> Although the language tag created by this
  method is well-formed (satisfies the syntax requirements
  defined by the IETF BCP 47 specification), it is not
  necessarily a valid BCP 47 language tag.  For example, 
 @code

    new Locale("xx", "YY").toLanguageTag();
@endcode
  will return "xx-YY", but the language subtag "xx" and the
  region subtag "YY" are invalid because they are not registered
  in the IANA Language Subtag Registry.
 @return a BCP47 language tag representing the locale
 - seealso: #forLanguageTag(String)
 @since 1.7
 */
- (NSString * __nonnull)toLanguageTag;

/*!
 @brief Returns a string representation of this <code>Locale</code>
  object, consisting of language, country, variant, script,
  and extensions as below: 
 <blockquote>
  language + "_" + country + "_" + (variant + "_#" | "#") + script + "-" + extensions 
 </blockquote>
  Language is always lower case, country is always upper case, script is always title
  case, and extensions are always lower case.Extensions and private use subtags
  will be in canonical order as explained in <code>toLanguageTag</code>.
 <p>When the locale has neither script nor extensions, the result is the same as in
  Java 6 and prior. 
 <p>If both the language and country fields are missing, this function will return
  the empty string, even if the variant, script, or extensions field is present (you
  can't have a locale with just a variant, the variant must accompany a well-formed
  language or country code). 
 <p>If script or extensions are present and variant is missing, no underscore is
  added before the "#". 
 <p>This behavior is designed to support debugging and to be compatible with
  previous uses of <code>toString</code> that expected language, country, and variant
  fields only.  To represent a Locale as a String for interchange purposes, use 
 <code>toLanguageTag</code>.
  
 <p>Examples: <ul>
  <li><tt>en</tt></li>
  <li><tt>de_DE</tt></li>
  <li><tt>_GB</tt></li>
  <li><tt>en_US_WIN</tt></li>
  <li><tt>de__POSIX</tt></li>
  <li><tt>zh_CN_#Hans</tt></li>
  <li><tt>zh_TW_#Hant-x-java</tt></li>
  <li><tt>th_TH_TH_#u-nu-thai</tt></li></ul>
 @return A string representation of the Locale, for debugging.
 - seealso: #getDisplayName
 - seealso: #toLanguageTag
 */
- (NSString * __nonnull)description;

#pragma mark Package-Private

/*!
 @brief Package locale method returning the Locale's BaseLocale,
  used by ResourceBundle
 @return base locale of this Locale
 */
- (SunUtilLocaleBaseLocale *)getBaseLocale;

+ (JavaUtilLocale *)getInstanceWithSunUtilLocaleBaseLocale:(SunUtilLocaleBaseLocale *)baseloc
                         withSunUtilLocaleLocaleExtensions:(SunUtilLocaleLocaleExtensions *)extensions;

/*!
 @brief Returns a <code>Locale</code> constructed from the given 
 <code>language</code>, <code>country</code> and 
 <code>variant</code>.If the same <code>Locale</code> instance
  is available in the cache, then that instance is
  returned.
 Otherwise, a new <code>Locale</code> instance is
  created and cached.
 @param language lowercase 2 to 8 language code.
 @param country uppercase two-letter ISO-3166 code and numric-3 UN M.49 area code.
 @param variant vendor and browser specific code. See class description.
 @return the <code>Locale</code> instance requested
 @throw NullPointerExceptionif any argument is null.
 */
+ (JavaUtilLocale *)getInstanceWithNSString:(NSString *)language
                               withNSString:(NSString *)country
                               withNSString:(NSString *)variant;

+ (JavaUtilLocale *)getInstanceWithNSString:(NSString *)language
                               withNSString:(NSString *)script
                               withNSString:(NSString *)country
                               withNSString:(NSString *)variant
          withSunUtilLocaleLocaleExtensions:(SunUtilLocaleLocaleExtensions *)extensions;

/*!
 @brief Package private method returning the Locale's LocaleExtensions,
  used by ResourceBundle.
 @return locale exnteions of this Locale,
          or <code>null</code> if no extensions are defined
 */
- (SunUtilLocaleLocaleExtensions *)getLocaleExtensions;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_STATIC_INIT(JavaUtilLocale)

/*!
 @brief Useful constant for language.
 */
inline JavaUtilLocale *JavaUtilLocale_get_ENGLISH(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaUtilLocale *JavaUtilLocale_ENGLISH;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaUtilLocale, ENGLISH, JavaUtilLocale *)

/*!
 @brief Useful constant for language.
 */
inline JavaUtilLocale *JavaUtilLocale_get_FRENCH(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaUtilLocale *JavaUtilLocale_FRENCH;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaUtilLocale, FRENCH, JavaUtilLocale *)

/*!
 @brief Useful constant for language.
 */
inline JavaUtilLocale *JavaUtilLocale_get_GERMAN(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaUtilLocale *JavaUtilLocale_GERMAN;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaUtilLocale, GERMAN, JavaUtilLocale *)

/*!
 @brief Useful constant for language.
 */
inline JavaUtilLocale *JavaUtilLocale_get_ITALIAN(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaUtilLocale *JavaUtilLocale_ITALIAN;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaUtilLocale, ITALIAN, JavaUtilLocale *)

/*!
 @brief Useful constant for language.
 */
inline JavaUtilLocale *JavaUtilLocale_get_JAPANESE(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaUtilLocale *JavaUtilLocale_JAPANESE;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaUtilLocale, JAPANESE, JavaUtilLocale *)

/*!
 @brief Useful constant for language.
 */
inline JavaUtilLocale *JavaUtilLocale_get_KOREAN(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaUtilLocale *JavaUtilLocale_KOREAN;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaUtilLocale, KOREAN, JavaUtilLocale *)

/*!
 @brief Useful constant for language.
 */
inline JavaUtilLocale *JavaUtilLocale_get_CHINESE(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaUtilLocale *JavaUtilLocale_CHINESE;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaUtilLocale, CHINESE, JavaUtilLocale *)

/*!
 @brief Useful constant for language.
 */
inline JavaUtilLocale *JavaUtilLocale_get_SIMPLIFIED_CHINESE(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaUtilLocale *JavaUtilLocale_SIMPLIFIED_CHINESE;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaUtilLocale, SIMPLIFIED_CHINESE, JavaUtilLocale *)

/*!
 @brief Useful constant for language.
 */
inline JavaUtilLocale *JavaUtilLocale_get_TRADITIONAL_CHINESE(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaUtilLocale *JavaUtilLocale_TRADITIONAL_CHINESE;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaUtilLocale, TRADITIONAL_CHINESE, JavaUtilLocale *)

/*!
 @brief Useful constant for country.
 */
inline JavaUtilLocale *JavaUtilLocale_get_FRANCE(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaUtilLocale *JavaUtilLocale_FRANCE;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaUtilLocale, FRANCE, JavaUtilLocale *)

/*!
 @brief Useful constant for country.
 */
inline JavaUtilLocale *JavaUtilLocale_get_GERMANY(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaUtilLocale *JavaUtilLocale_GERMANY;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaUtilLocale, GERMANY, JavaUtilLocale *)

/*!
 @brief Useful constant for country.
 */
inline JavaUtilLocale *JavaUtilLocale_get_ITALY(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaUtilLocale *JavaUtilLocale_ITALY;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaUtilLocale, ITALY, JavaUtilLocale *)

/*!
 @brief Useful constant for country.
 */
inline JavaUtilLocale *JavaUtilLocale_get_JAPAN(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaUtilLocale *JavaUtilLocale_JAPAN;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaUtilLocale, JAPAN, JavaUtilLocale *)

/*!
 @brief Useful constant for country.
 */
inline JavaUtilLocale *JavaUtilLocale_get_KOREA(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaUtilLocale *JavaUtilLocale_KOREA;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaUtilLocale, KOREA, JavaUtilLocale *)

/*!
 @brief Useful constant for country.
 */
inline JavaUtilLocale *JavaUtilLocale_get_CHINA(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaUtilLocale *JavaUtilLocale_CHINA;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaUtilLocale, CHINA, JavaUtilLocale *)

/*!
 @brief Useful constant for country.
 */
inline JavaUtilLocale *JavaUtilLocale_get_PRC(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaUtilLocale *JavaUtilLocale_PRC;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaUtilLocale, PRC, JavaUtilLocale *)

/*!
 @brief Useful constant for country.
 */
inline JavaUtilLocale *JavaUtilLocale_get_TAIWAN(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaUtilLocale *JavaUtilLocale_TAIWAN;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaUtilLocale, TAIWAN, JavaUtilLocale *)

/*!
 @brief Useful constant for country.
 */
inline JavaUtilLocale *JavaUtilLocale_get_UK(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaUtilLocale *JavaUtilLocale_UK;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaUtilLocale, UK, JavaUtilLocale *)

/*!
 @brief Useful constant for country.
 */
inline JavaUtilLocale *JavaUtilLocale_get_US(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaUtilLocale *JavaUtilLocale_US;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaUtilLocale, US, JavaUtilLocale *)

/*!
 @brief Useful constant for country.
 */
inline JavaUtilLocale *JavaUtilLocale_get_CANADA(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaUtilLocale *JavaUtilLocale_CANADA;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaUtilLocale, CANADA, JavaUtilLocale *)

/*!
 @brief Useful constant for country.
 */
inline JavaUtilLocale *JavaUtilLocale_get_CANADA_FRENCH(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaUtilLocale *JavaUtilLocale_CANADA_FRENCH;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaUtilLocale, CANADA_FRENCH, JavaUtilLocale *)

/*!
 @brief Useful constant for the root locale.The root locale is the locale whose
  language, country, and variant are empty ("") strings.
 This is regarded
  as the base locale of all locales, and is used as the language/country
  neutral locale for the locale sensitive operations.
 @since 1.6
 */
inline JavaUtilLocale *JavaUtilLocale_get_ROOT(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaUtilLocale *JavaUtilLocale_ROOT;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaUtilLocale, ROOT, JavaUtilLocale *)

/*!
 @brief The key for the private use extension ('x').
 - seealso: #getExtension(char)
 - seealso: Builder#setExtension(char, String)
 @since 1.7
 */
inline jchar JavaUtilLocale_get_PRIVATE_USE_EXTENSION(void);
#define JavaUtilLocale_PRIVATE_USE_EXTENSION 'x'
J2OBJC_STATIC_FIELD_CONSTANT(JavaUtilLocale, PRIVATE_USE_EXTENSION, jchar)

/*!
 @brief The key for Unicode locale extension ('u').
 - seealso: #getExtension(char)
 - seealso: Builder#setExtension(char, String)
 @since 1.7
 */
inline jchar JavaUtilLocale_get_UNICODE_LOCALE_EXTENSION(void);
#define JavaUtilLocale_UNICODE_LOCALE_EXTENSION 'u'
J2OBJC_STATIC_FIELD_CONSTANT(JavaUtilLocale, UNICODE_LOCALE_EXTENSION, jchar)

/*!
 @brief serialization ID
 */
inline jlong JavaUtilLocale_get_serialVersionUID(void);
#define JavaUtilLocale_serialVersionUID 9149081749638150636LL
J2OBJC_STATIC_FIELD_CONSTANT(JavaUtilLocale, serialVersionUID, jlong)

FOUNDATION_EXPORT void JavaUtilLocale_initWithNSString_withNSString_withNSString_(JavaUtilLocale *self, NSString *language, NSString *country, NSString *variant);

FOUNDATION_EXPORT JavaUtilLocale *new_JavaUtilLocale_initWithNSString_withNSString_withNSString_(NSString *language, NSString *country, NSString *variant) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilLocale *create_JavaUtilLocale_initWithNSString_withNSString_withNSString_(NSString *language, NSString *country, NSString *variant);

FOUNDATION_EXPORT void JavaUtilLocale_initWithNSString_withNSString_(JavaUtilLocale *self, NSString *language, NSString *country);

FOUNDATION_EXPORT JavaUtilLocale *new_JavaUtilLocale_initWithNSString_withNSString_(NSString *language, NSString *country) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilLocale *create_JavaUtilLocale_initWithNSString_withNSString_(NSString *language, NSString *country);

FOUNDATION_EXPORT void JavaUtilLocale_initWithNSString_(JavaUtilLocale *self, NSString *language);

FOUNDATION_EXPORT JavaUtilLocale *new_JavaUtilLocale_initWithNSString_(NSString *language) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilLocale *create_JavaUtilLocale_initWithNSString_(NSString *language);

FOUNDATION_EXPORT JavaUtilLocale *JavaUtilLocale_getInstanceWithNSString_withNSString_withNSString_(NSString *language, NSString *country, NSString *variant);

FOUNDATION_EXPORT JavaUtilLocale *JavaUtilLocale_getInstanceWithNSString_withNSString_withNSString_withNSString_withSunUtilLocaleLocaleExtensions_(NSString *language, NSString *script, NSString *country, NSString *variant, SunUtilLocaleLocaleExtensions *extensions);

FOUNDATION_EXPORT JavaUtilLocale *JavaUtilLocale_getInstanceWithSunUtilLocaleBaseLocale_withSunUtilLocaleLocaleExtensions_(SunUtilLocaleBaseLocale *baseloc, SunUtilLocaleLocaleExtensions *extensions);

FOUNDATION_EXPORT JavaUtilLocale *JavaUtilLocale_getDefault(void);

FOUNDATION_EXPORT JavaUtilLocale *JavaUtilLocale_getDefaultWithJavaUtilLocale_Category_(JavaUtilLocale_Category *category);

FOUNDATION_EXPORT JavaUtilLocale *JavaUtilLocale_initDefault(void);

FOUNDATION_EXPORT void JavaUtilLocale_setDefaultWithJavaUtilLocale_(JavaUtilLocale *newLocale);

FOUNDATION_EXPORT void JavaUtilLocale_setDefaultWithJavaUtilLocale_Category_withJavaUtilLocale_(JavaUtilLocale_Category *category, JavaUtilLocale *newLocale);

FOUNDATION_EXPORT IOSObjectArray *JavaUtilLocale_getAvailableLocales(void);

FOUNDATION_EXPORT IOSObjectArray *JavaUtilLocale_getISOCountries(void);

FOUNDATION_EXPORT IOSObjectArray *JavaUtilLocale_getISOLanguages(void);

FOUNDATION_EXPORT JavaUtilLocale *JavaUtilLocale_forLanguageTagWithNSString_(NSString *languageTag);

FOUNDATION_EXPORT NSString *JavaUtilLocale_adjustLanguageCodeWithNSString_(NSString *languageCode);

FOUNDATION_EXPORT id<JavaUtilList> JavaUtilLocale_filterWithJavaUtilList_withJavaUtilCollection_withJavaUtilLocale_FilteringMode_(id<JavaUtilList> priorityList, id<JavaUtilCollection> locales, JavaUtilLocale_FilteringMode *mode);

FOUNDATION_EXPORT id<JavaUtilList> JavaUtilLocale_filterWithJavaUtilList_withJavaUtilCollection_(id<JavaUtilList> priorityList, id<JavaUtilCollection> locales);

FOUNDATION_EXPORT id<JavaUtilList> JavaUtilLocale_filterTagsWithJavaUtilList_withJavaUtilCollection_withJavaUtilLocale_FilteringMode_(id<JavaUtilList> priorityList, id<JavaUtilCollection> tags, JavaUtilLocale_FilteringMode *mode);

FOUNDATION_EXPORT id<JavaUtilList> JavaUtilLocale_filterTagsWithJavaUtilList_withJavaUtilCollection_(id<JavaUtilList> priorityList, id<JavaUtilCollection> tags);

FOUNDATION_EXPORT JavaUtilLocale *JavaUtilLocale_lookupWithJavaUtilList_withJavaUtilCollection_(id<JavaUtilList> priorityList, id<JavaUtilCollection> locales);

FOUNDATION_EXPORT NSString *JavaUtilLocale_lookupTagWithJavaUtilList_withJavaUtilCollection_(id<JavaUtilList> priorityList, id<JavaUtilCollection> tags);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilLocale)

#endif

#if !defined (JavaUtilLocale_Category_) && (INCLUDE_ALL_JavaUtilLocale || defined(INCLUDE_JavaUtilLocale_Category))
#define JavaUtilLocale_Category_

#define RESTRICT_JavaLangEnum 1
#define INCLUDE_JavaLangEnum 1
#include "java/lang/Enum.h"

@class IOSObjectArray;

typedef NS_ENUM(jint, JavaUtilLocale_Category_Enum) {
  JavaUtilLocale_Category_Enum_DISPLAY = 0,
  JavaUtilLocale_Category_Enum_FORMAT = 1,
};
#if J2OBJC_IMPORTED_BY_JAVA_IMPLEMENTATION
#define JavaUtilLocale_Category_ORDINAL jint
#else
#define JavaUtilLocale_Category_ORDINAL JavaUtilLocale_Category_Enum
#endif


/*!
 @brief Enum for locale categories.These locale categories are used to get/set
  the default locale for the specific functionality represented by the
  category.
 - seealso: #getDefault(Locale.Category)
 - seealso: #setDefault(Locale.Category, Locale)
 @since 1.7
 */
@interface JavaUtilLocale_Category : JavaLangEnum {
 @public
  NSString *languageKey_;
  NSString *scriptKey_;
  NSString *countryKey_;
  NSString *variantKey_;
}

#pragma mark Public

+ (JavaUtilLocale_Category *)valueOfWithNSString:(NSString *)name;

+ (IOSObjectArray *)values;

#pragma mark Package-Private

- (JavaUtilLocale_Category_Enum)toNSEnum;

- (JavaUtilLocale_Category_ORDINAL)ordinal;

@end

J2OBJC_STATIC_INIT(JavaUtilLocale_Category)

/*! INTERNAL ONLY - Use enum accessors declared below. */
FOUNDATION_EXPORT JavaUtilLocale_Category *JavaUtilLocale_Category_values_[];

/*!
 @brief Category used to represent the default locale for
  displaying user interfaces.
 */
inline JavaUtilLocale_Category *JavaUtilLocale_Category_get_DISPLAY(void);
J2OBJC_ENUM_CONSTANT(JavaUtilLocale_Category, DISPLAY)

/*!
 @brief Category used to represent the default locale for
  formatting dates, numbers, and/or currencies.
 */
inline JavaUtilLocale_Category *JavaUtilLocale_Category_get_FORMAT(void);
J2OBJC_ENUM_CONSTANT(JavaUtilLocale_Category, FORMAT)

J2OBJC_FIELD_SETTER(JavaUtilLocale_Category, languageKey_, NSString *)
J2OBJC_FIELD_SETTER(JavaUtilLocale_Category, scriptKey_, NSString *)
J2OBJC_FIELD_SETTER(JavaUtilLocale_Category, countryKey_, NSString *)
J2OBJC_FIELD_SETTER(JavaUtilLocale_Category, variantKey_, NSString *)

FOUNDATION_EXPORT IOSObjectArray *JavaUtilLocale_Category_values(void);

FOUNDATION_EXPORT JavaUtilLocale_Category *JavaUtilLocale_Category_valueOfWithNSString_(NSString *name);

FOUNDATION_EXPORT JavaUtilLocale_Category *JavaUtilLocale_Category_fromOrdinal(JavaUtilLocale_Category_ORDINAL ordinal);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilLocale_Category)

#endif

#if !defined (JavaUtilLocale_Builder_) && (INCLUDE_ALL_JavaUtilLocale || defined(INCLUDE_JavaUtilLocale_Builder))
#define JavaUtilLocale_Builder_

@class JavaLangCharacter;
@class JavaUtilLocale;

/*!
 @brief <code>Builder</code> is used to build instances of <code>Locale</code>
  from values configured by the setters.Unlike the <code>Locale</code>
  constructors, the <code>Builder</code> checks if a value configured by a
  setter satisfies the syntax requirements defined by the <code>Locale</code>
  class.
 A <code>Locale</code> object created by a <code>Builder</code> is
  well-formed and can be transformed to a well-formed IETF BCP 47 language tag
  without losing information. 
 <p><b>Note:</b> The <code>Locale</code> class does not provide any
  syntactic restrictions on variant, while BCP 47 requires each variant
  subtag to be 5 to 8 alphanumerics or a single numeric followed by 3
  alphanumerics.  The method <code>setVariant</code> throws 
 <code>IllformedLocaleException</code> for a variant that does not satisfy
  this restriction. If it is necessary to support such a variant, use a
  Locale constructor.  However, keep in mind that a <code>Locale</code>
  object created this way might lose the variant information when
  transformed to a BCP 47 language tag. 
 <p>The following example shows how to create a <code>Locale</code> object
  with the <code>Builder</code>.
  <blockquote>
  @code

      Locale aLocale = new Builder().setLanguage("sr").setScript("Latn").setRegion("RS").build(); 
  
@endcode
  </blockquote>
  
 <p>Builders can be reused; <code>clear()</code> resets all
  fields to their default values.
 - seealso: Locale#forLanguageTag
 @since 1.7
 */
@interface JavaUtilLocale_Builder : NSObject

#pragma mark Public

/*!
 @brief Constructs an empty Builder.The default value of all
  fields, extensions, and private use information is the
  empty string.
 */
- (instancetype __nonnull)init;

/*!
 @brief Adds a unicode locale attribute, if not already present, otherwise
  has no effect.The attribute must not be null and must be <a href=".
 /Locale.html#def_locale_extension">
 well-formed</a> or an exception
  is thrown.
 @param attribute the attribute
 @return This builder.
 @throw NullPointerExceptionif <code>attribute</code> is null
 @throw IllformedLocaleExceptionif <code>attribute</code> is ill-formed
 - seealso: #setExtension(char, String)
 */
- (JavaUtilLocale_Builder * __nonnull)addUnicodeLocaleAttributeWithNSString:(NSString *)attribute;

/*!
 @brief Returns an instance of <code>Locale</code> created from the fields set
  on this builder.
 <p>This applies the conversions listed in <code>Locale.forLanguageTag</code>
  when constructing a Locale. (Grandfathered tags are handled in 
 <code>setLanguageTag</code>.)
 @return A Locale.
 */
- (JavaUtilLocale * __nonnull)build;

/*!
 @brief Resets the builder to its initial, empty state.
 @return This builder.
 */
- (JavaUtilLocale_Builder * __nonnull)clear;

/*!
 @brief Resets the extensions to their initial, empty state.
 Language, script, region and variant are unchanged.
 @return This builder.
 - seealso: #setExtension(char, String)
 */
- (JavaUtilLocale_Builder * __nonnull)clearExtensions;

/*!
 @brief Removes a unicode locale attribute, if present, otherwise has no
  effect.The attribute must not be null and must be <a href=".
 /Locale.html#def_locale_extension">
 well-formed</a> or an exception
  is thrown. 
 <p>Attribute comparision for removal is case-insensitive.
 @param attribute the attribute
 @return This builder.
 @throw NullPointerExceptionif <code>attribute</code> is null
 @throw IllformedLocaleExceptionif <code>attribute</code> is ill-formed
 - seealso: #setExtension(char, String)
 */
- (JavaUtilLocale_Builder * __nonnull)removeUnicodeLocaleAttributeWithNSString:(NSString *)attribute;

/*!
 @brief Sets the extension for the given key.If the value is null or the
  empty string, the extension is removed.
 Otherwise, the extension
  must be <a href="./Locale.html#def_extensions">well-formed</a> or an exception
  is thrown. 
 <p><b>Note:</b> The key <code>UNICODE_LOCALE_EXTENSION</code>
  ('u') is used for the Unicode locale extension.
  Setting a value for this key replaces any existing Unicode locale key/type
  pairs with those defined in the extension. 
 <p><b>Note:</b> The key <code>PRIVATE_USE_EXTENSION</code>
  ('x') is used for the private use code. To be
  well-formed, the value for this key needs only to have subtags of one to
  eight alphanumeric characters, not two to eight as in the general case.
 @param key the extension key
 @param value the extension value
 @return This builder.
 @throw IllformedLocaleExceptionif <code>key</code> is illegal
  or <code>value</code> is ill-formed
 - seealso: #setUnicodeLocaleKeyword(String, String)
 */
- (JavaUtilLocale_Builder * __nonnull)setExtensionWithChar:(jchar)key
                                              withNSString:(NSString *)value;

/*!
 @brief Sets the language.If <code>language</code> is the empty string or
  null, the language in this <code>Builder</code> is removed.
 Otherwise,
  the language must be <a href="./Locale.html#def_language">well-formed</a>
  or an exception is thrown. 
 <p>The typical language value is a two or three-letter language
  code as defined in ISO639.
 @param language the language
 @return This builder.
 @throw IllformedLocaleExceptionif <code>language</code> is ill-formed
 */
- (JavaUtilLocale_Builder * __nonnull)setLanguageWithNSString:(NSString *)language;

/*!
 @brief Resets the Builder to match the provided IETF BCP 47
  language tag.Discards the existing state.
 Null and the
  empty string cause the builder to be reset, like <code>clear</code>
 .  Grandfathered tags (see <code>Locale.forLanguageTag</code>
 ) are converted to their canonical
  form before being processed.  Otherwise, the language tag
  must be well-formed (see <code>Locale</code>) or an exception is
  thrown (unlike <code>Locale.forLanguageTag</code>, which
  just discards ill-formed and following portions of the
  tag).
 @param languageTag the language tag
 @return This builder.
 @throw IllformedLocaleExceptionif <code>languageTag</code> is ill-formed
 - seealso: Locale#forLanguageTag(String)
 */
- (JavaUtilLocale_Builder * __nonnull)setLanguageTagWithNSString:(NSString *)languageTag;

/*!
 @brief Resets the <code>Builder</code> to match the provided 
 <code>locale</code>.Existing state is discarded.
 <p>All fields of the locale must be well-formed, see <code>Locale</code>.
  
 <p>Locales with any ill-formed fields cause 
 <code>IllformedLocaleException</code> to be thrown, except for the
  following three cases which are accepted for compatibility
  reasons:<ul>
  <li>Locale("ja", "JP", "JP") is treated as "ja-JP-u-ca-japanese" 
 <li>Locale("th", "TH", "TH") is treated as "th-TH-u-nu-thai" 
 <li>Locale("no", "NO", "NY") is treated as "nn-NO"</ul>
 @param locale the locale
 @return This builder.
 @throw IllformedLocaleExceptionif <code>locale</code> has
  any ill-formed fields.
 @throw NullPointerExceptionif <code>locale</code> is null.
 */
- (JavaUtilLocale_Builder * __nonnull)setLocaleWithJavaUtilLocale:(JavaUtilLocale *)locale;

/*!
 @brief Sets the region.If region is null or the empty string, the region
  in this <code>Builder</code> is removed.
 Otherwise,
  the region must be <a href="./Locale.html#def_region">well-formed</a> or an
  exception is thrown. 
 <p>The typical region value is a two-letter ISO 3166 code or a
  three-digit UN M.49 area code. 
 <p>The country value in the <code>Locale</code> created by the 
 <code>Builder</code> is always normalized to upper case.
 @param region the region
 @return This builder.
 @throw IllformedLocaleExceptionif <code>region</code> is ill-formed
 */
- (JavaUtilLocale_Builder * __nonnull)setRegionWithNSString:(NSString *)region;

/*!
 @brief Sets the script.If <code>script</code> is null or the empty string,
  the script in this <code>Builder</code> is removed.
 Otherwise, the script must be <a href="./Locale.html#def_script">well-formed</a> or an
  exception is thrown. 
 <p>The typical script value is a four-letter script code as defined by ISO 15924.
 @param script the script
 @return This builder.
 @throw IllformedLocaleExceptionif <code>script</code> is ill-formed
 */
- (JavaUtilLocale_Builder * __nonnull)setScriptWithNSString:(NSString *)script;

/*!
 @brief Sets the Unicode locale keyword type for the given key.If the type
  is null, the Unicode keyword is removed.
 Otherwise, the key must be
  non-null and both key and type must be <a href="./Locale.html#def_locale_extension">
 well-formed</a> or an exception
  is thrown. 
 <p>Keys and types are converted to lower case. 
 <p><b>Note</b>:Setting the 'u' extension via <code>setExtension</code>
  replaces all Unicode locale keywords with those defined in the
  extension.
 @param key the Unicode locale key
 @param type the Unicode locale type
 @return This builder.
 @throw IllformedLocaleExceptionif <code>key</code> or <code>type</code>
  is ill-formed
 @throw NullPointerExceptionif <code>key</code> is null
 - seealso: #setExtension(char, String)
 */
- (JavaUtilLocale_Builder * __nonnull)setUnicodeLocaleKeywordWithNSString:(NSString *)key
                                                             withNSString:(NSString *)type;

/*!
 @brief Sets the variant.If variant is null or the empty string, the
  variant in this <code>Builder</code> is removed.
 Otherwise, it
  must consist of one or more <a href="./Locale.html#def_variant">well-formed</a>
  subtags, or an exception is thrown. 
 <p><b>Note:</b> This method checks if <code>variant</code>
  satisfies the IETF BCP 47 variant subtag's syntax requirements,
  and normalizes the value to lowercase letters.  However, the 
 <code>Locale</code> class does not impose any syntactic
  restriction on variant, and the variant value in 
 <code>Locale</code> is case sensitive.  To set such a variant,
  use a Locale constructor.
 @param variant the variant
 @return This builder.
 @throw IllformedLocaleExceptionif <code>variant</code> is ill-formed
 */
- (JavaUtilLocale_Builder * __nonnull)setVariantWithNSString:(NSString *)variant;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilLocale_Builder)

FOUNDATION_EXPORT void JavaUtilLocale_Builder_init(JavaUtilLocale_Builder *self);

FOUNDATION_EXPORT JavaUtilLocale_Builder *new_JavaUtilLocale_Builder_init(void) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilLocale_Builder *create_JavaUtilLocale_Builder_init(void);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilLocale_Builder)

#endif

#if !defined (JavaUtilLocale_FilteringMode_) && (INCLUDE_ALL_JavaUtilLocale || defined(INCLUDE_JavaUtilLocale_FilteringMode))
#define JavaUtilLocale_FilteringMode_

#define RESTRICT_JavaLangEnum 1
#define INCLUDE_JavaLangEnum 1
#include "java/lang/Enum.h"

@class IOSObjectArray;

typedef NS_ENUM(jint, JavaUtilLocale_FilteringMode_Enum) {
  JavaUtilLocale_FilteringMode_Enum_AUTOSELECT_FILTERING = 0,
  JavaUtilLocale_FilteringMode_Enum_EXTENDED_FILTERING = 1,
  JavaUtilLocale_FilteringMode_Enum_IGNORE_EXTENDED_RANGES = 2,
  JavaUtilLocale_FilteringMode_Enum_MAP_EXTENDED_RANGES = 3,
  JavaUtilLocale_FilteringMode_Enum_REJECT_EXTENDED_RANGES = 4,
};
#if J2OBJC_IMPORTED_BY_JAVA_IMPLEMENTATION
#define JavaUtilLocale_FilteringMode_ORDINAL jint
#else
#define JavaUtilLocale_FilteringMode_ORDINAL JavaUtilLocale_FilteringMode_Enum
#endif


/*!
 @brief This enum provides constants to select a filtering mode for locale
  matching.Refer to <a href="http://tools.ietf.org/html/rfc4647">RFC 4647
  Matching of Language Tags</a> for details.
 <p>As an example, think of two Language Priority Lists each of which
  includes only one language range and a set of following language tags: 
 @code

     de (German)
     de-DE (German, Germany)
     de-Deva (German, in Devanagari script)
     de-Deva-DE (German, in Devanagari script, Germany)
     de-DE-1996 (German, Germany, orthography of 1996)
     de-Latn-DE (German, in Latin script, Germany)
     de-Latn-DE-1996 (German, in Latin script, Germany, orthography of 1996) 
  
@endcode
  The filtering method will behave as follows: 
 <table cellpadding=2 summary="Filtering method behavior">
  <tr>
  <th>Filtering Mode</th>
  <th>Language Priority List: <code>"de-DE"</code></th>
  <th>Language Priority List: <code>"de-*-DE"</code></th>
  </tr>
  <tr>
  <td valign=top>
  <code>AUTOSELECT_FILTERING</code>
  </td>
  <td valign=top>
  Performs <em>basic</em> filtering and returns <code>"de-DE"</code> and 
 <code>"de-DE-1996"</code>.
  </td>
  <td valign=top>
  Performs <em>extended</em> filtering and returns <code>"de-DE"</code>,
  <code>"de-Deva-DE"</code>, <code>"de-DE-1996"</code>, <code>"de-Latn-DE"</code>, and 
 <code>"de-Latn-DE-1996"</code>.
  </td>
  </tr>
  <tr>
  <td valign=top>
  <code>EXTENDED_FILTERING</code>
  </td>
  <td valign=top>
  Performs <em>extended</em> filtering and returns <code>"de-DE"</code>,
  <code>"de-Deva-DE"</code>, <code>"de-DE-1996"</code>, <code>"de-Latn-DE"</code>, and 
 <code>"de-Latn-DE-1996"</code>.
  </td>
  <td valign=top>Same as above.</td>
  </tr>
  <tr>
  <td valign=top>
  <code>IGNORE_EXTENDED_RANGES</code>
  </td>
  <td valign=top>
  Performs <em>basic</em> filtering and returns <code>"de-DE"</code> and 
 <code>"de-DE-1996"</code>.
  </td>
  <td valign=top>
  Performs <em>basic</em> filtering and returns <code>null</code> because
  nothing matches. 
 </td>
  </tr>
  <tr>
  <td valign=top>
  <code>MAP_EXTENDED_RANGES</code>
  </td>
  <td valign=top>Same as above.</td>
  <td valign=top>
  Performs <em>basic</em> filtering and returns <code>"de-DE"</code> and 
 <code>"de-DE-1996"</code> because <code>"de-*-DE"</code> is mapped to 
 <code>"de-DE"</code>.
  </td>
  </tr>
  <tr>
  <td valign=top>
  <code>REJECT_EXTENDED_RANGES</code>
  </td>
  <td valign=top>Same as above.</td>
  <td valign=top>
  Throws <code>IllegalArgumentException</code> because <code>"de-*-DE"</code> is
  not a valid basic language range. 
 </td>
  </tr>
  </table>
 - seealso: #filter(List, Collection, FilteringMode)
 - seealso: #filterTags(List, Collection, FilteringMode)
 @since 1.8
 */
@interface JavaUtilLocale_FilteringMode : JavaLangEnum

#pragma mark Public

+ (JavaUtilLocale_FilteringMode *)valueOfWithNSString:(NSString *)name;

+ (IOSObjectArray *)values;

#pragma mark Package-Private

- (JavaUtilLocale_FilteringMode_Enum)toNSEnum;

- (JavaUtilLocale_FilteringMode_ORDINAL)ordinal;

@end

J2OBJC_STATIC_INIT(JavaUtilLocale_FilteringMode)

/*! INTERNAL ONLY - Use enum accessors declared below. */
FOUNDATION_EXPORT JavaUtilLocale_FilteringMode *JavaUtilLocale_FilteringMode_values_[];

/*!
 @brief Specifies automatic filtering mode based on the given Language
  Priority List consisting of language ranges.If all of the ranges
  are basic, basic filtering is selected.
 Otherwise, extended filtering is selected.
 */
inline JavaUtilLocale_FilteringMode *JavaUtilLocale_FilteringMode_get_AUTOSELECT_FILTERING(void);
J2OBJC_ENUM_CONSTANT(JavaUtilLocale_FilteringMode, AUTOSELECT_FILTERING)

/*!
 @brief Specifies extended filtering.
 */
inline JavaUtilLocale_FilteringMode *JavaUtilLocale_FilteringMode_get_EXTENDED_FILTERING(void);
J2OBJC_ENUM_CONSTANT(JavaUtilLocale_FilteringMode, EXTENDED_FILTERING)

/*!
 @brief Specifies basic filtering: Note that any extended language ranges
  included in the given Language Priority List are ignored.
 */
inline JavaUtilLocale_FilteringMode *JavaUtilLocale_FilteringMode_get_IGNORE_EXTENDED_RANGES(void);
J2OBJC_ENUM_CONSTANT(JavaUtilLocale_FilteringMode, IGNORE_EXTENDED_RANGES)

/*!
 @brief Specifies basic filtering: If any extended language ranges are
  included in the given Language Priority List, they are mapped to the
  basic language range.Specifically, a language range starting with a
  subtag <code>"*"</code> is treated as a language range <code>"*"</code>.
 For
  example, <code>"*-US"</code> is treated as <code>"*"</code>. If <code>"*"</code> is
  not the first subtag, <code>"*"</code> and extra <code>"-"</code> are removed.
  For example, <code>"ja-*-JP"</code> is mapped to <code>"ja-JP"</code>.
 */
inline JavaUtilLocale_FilteringMode *JavaUtilLocale_FilteringMode_get_MAP_EXTENDED_RANGES(void);
J2OBJC_ENUM_CONSTANT(JavaUtilLocale_FilteringMode, MAP_EXTENDED_RANGES)

/*!
 @brief Specifies basic filtering: If any extended language ranges are
  included in the given Language Priority List, the list is rejected
  and the filtering method throws <code>IllegalArgumentException</code>.
 */
inline JavaUtilLocale_FilteringMode *JavaUtilLocale_FilteringMode_get_REJECT_EXTENDED_RANGES(void);
J2OBJC_ENUM_CONSTANT(JavaUtilLocale_FilteringMode, REJECT_EXTENDED_RANGES)

FOUNDATION_EXPORT IOSObjectArray *JavaUtilLocale_FilteringMode_values(void);

FOUNDATION_EXPORT JavaUtilLocale_FilteringMode *JavaUtilLocale_FilteringMode_valueOfWithNSString_(NSString *name);

FOUNDATION_EXPORT JavaUtilLocale_FilteringMode *JavaUtilLocale_FilteringMode_fromOrdinal(JavaUtilLocale_FilteringMode_ORDINAL ordinal);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilLocale_FilteringMode)

#endif

#if !defined (JavaUtilLocale_LanguageRange_) && (INCLUDE_ALL_JavaUtilLocale || defined(INCLUDE_JavaUtilLocale_LanguageRange))
#define JavaUtilLocale_LanguageRange_

@class JavaLangBoolean;
@class JavaLangDouble;
@class JavaLangInteger;
@protocol JavaUtilList;
@protocol JavaUtilMap;

/*!
 @brief This class expresses a <em>Language Range</em> defined in 
 <a href="http://tools.ietf.org/html/rfc4647">RFC 4647 Matching of
  Language Tags</a>.A language range is an identifier which is used to
  select language tag(s) meeting specific requirements by using the
  mechanisms described in <a href="Locale.html#LocaleMatching">Locale
  Matching</a>.
 A list which represents a user's preferences and consists
  of language ranges is called a <em>Language Priority List</em>.
  
 <p>There are two types of language ranges: basic and extended. In RFC
  4647, the syntax of language ranges is expressed in 
 <a href="http://tools.ietf.org/html/rfc4234">ABNF</a> as follows: 
 <blockquote>
  @code

      basic-language-range    = (1*8ALPHA *("-" 1*8alphanum)) / "*"
      extended-language-range = (1*8ALPHA / "*")
                                *("-" (1*8alphanum / "*"))
      alphanum                = ALPHA / DIGIT 
  
@endcode
  </blockquote>
  For example, <code>"en"</code> (English), <code>"ja-JP"</code> (Japanese, Japan), 
 <code>"*"</code> (special language range which matches any language tag) are
  basic language ranges, whereas <code>"*-CH"</code> (any languages,
  Switzerland), <code>"es-*"</code> (Spanish, any regions), and 
 <code>"zh-Hant-*"</code> (Traditional Chinese, any regions) are extended
  language ranges.
 - seealso: #filter
 - seealso: #filterTags
 - seealso: #lookup
 - seealso: #lookupTag
 @since 1.8
 */
@interface JavaUtilLocale_LanguageRange : NSObject

#pragma mark Public

/*!
 @brief Constructs a <code>LanguageRange</code> using the given <code>range</code>.
 Note that no validation is done against the IANA Language Subtag
  Registry at time of construction. 
 <p>This is equivalent to <code>LanguageRange(range, MAX_WEIGHT)</code>.
 @param range a language range
 @throw NullPointerExceptionif the given <code>range</code> is
      <code>null</code>
 */
- (instancetype __nonnull)initWithNSString:(NSString *)range;

/*!
 @brief Constructs a <code>LanguageRange</code> using the given <code>range</code> and 
 <code>weight</code>.Note that no validation is done against the IANA
  Language Subtag Registry at time of construction.
 @param range a language range
 @param weight a weight value between <code>MIN_WEIGHT</code>  and
       <code>MAX_WEIGHT</code>
 @throw NullPointerExceptionif the given <code>range</code> is
      <code>null</code>
 @throw IllegalArgumentExceptionif the given <code>weight</code> is less
      than <code>MIN_WEIGHT</code> or greater than <code>MAX_WEIGHT</code>
 */
- (instancetype __nonnull)initWithNSString:(NSString *)range
                                withDouble:(jdouble)weight;

/*!
 @brief Compares this object to the specified object.The result is true if
  and only if the argument is not <code>null</code> and is a 
 <code>LanguageRange</code> object that contains the same <code>range</code>
  and <code>weight</code> values as this object.
 @param obj the object to compare with
 @return <code>true</code> if this object's <code>range</code> and
      <code>weight</code> are the same as the <code>obj</code>'s; <code>false</code>
      otherwise.
 */
- (jboolean)isEqual:(id)obj;

/*!
 @brief Returns the language range of this <code>LanguageRange</code>.
 @return the language range.
 */
- (NSString * __nonnull)getRange;

/*!
 @brief Returns the weight of this <code>LanguageRange</code>.
 @return the weight value.
 */
- (jdouble)getWeight;

/*!
 @brief Returns a hash code value for the object.
 @return a hash code value for this object.
 */
- (NSUInteger)hash;

/*!
 @brief Generates a new customized Language Priority List using the given 
 <code>priorityList</code> and <code>map</code>.If the given <code>map</code> is
  empty, this method returns a copy of the given <code>priorityList</code>.
 <p>In the map, a key represents a language range whereas a value is
  a list of equivalents of it. <code>'*'</code> cannot be used in the map.
  Each equivalent language range has the same weight value as its
  original language range. 
 @code

   An example of map:
        <b>Key</b>                            <b>Value</b>
       "zh" (Chinese)                 "zh",
                                      "zh-Hans"(Simplified Chinese)
       "zh-HK" (Chinese, Hong Kong)   "zh-HK"
       "zh-TW" (Chinese, Taiwan)      "zh-TW" 
  
@endcode
  The customization is performed after modification using the IANA
  Language Subtag Registry. 
 <p>For example, if a user's Language Priority List consists of five
  language ranges (<code>"zh"</code>, <code>"zh-CN"</code>, <code>"en"</code>,
  <code>"zh-TW"</code>, and <code>"zh-HK"</code>), the newly generated Language
  Priority List which is customized using the above map example will
  consists of <code>"zh"</code>, <code>"zh-Hans"</code>, <code>"zh-CN"</code>,
  <code>"zh-Hans-CN"</code>, <code>"en"</code>, <code>"zh-TW"</code>, and 
 <code>"zh-HK"</code>.
  
 <p><code>"zh-HK"</code> and <code>"zh-TW"</code> aren't converted to 
 <code>"zh-Hans-HK"</code> nor <code>"zh-Hans-TW"</code> even if they are
  included in the Language Priority List. In this example, mapping
  is used to clearly distinguish Simplified Chinese and Traditional
  Chinese. 
 <p>If the <code>"zh"</code>-to-<code>"zh"</code> mapping isn't included in the
  map, a simple replacement will be performed and the customized list
  won't include <code>"zh"</code> and <code>"zh-CN"</code>.
 @param priorityList user's Language Priority List
 @param map a map containing information to customize language ranges
 @return a new Language Priority List with customization. The list is
      modifiable.
 @throw NullPointerExceptionif <code>priorityList</code> is <code>null</code>
 - seealso: #parse(String, Map)
 */
+ (id<JavaUtilList> __nonnull)mapEquivalentsWithJavaUtilList:(id<JavaUtilList>)priorityList
                                             withJavaUtilMap:(id<JavaUtilMap>)map;

/*!
 @brief Parses the given <code>ranges</code> to generate a Language Priority List.
 <p>This method performs a syntactic check for each language range in
  the given <code>ranges</code> but doesn't do validation using the IANA
  Language Subtag Registry. 
 <p>The <code>ranges</code> to be given can take one of the following
  forms: 
 @code

    "Accept-Language: ja,en;q=0.4"  (weighted list with Accept-Language prefix)
    "ja,en;q=0.4"                   (weighted list)
    "ja,en"                         (prioritized list) 
  
@endcode
  In a weighted list, each language range is given a weight value.
  The weight value is identical to the "quality value" in 
 <a href="http://tools.ietf.org/html/rfc2616">RFC 2616</a>, and it
  expresses how much the user prefers  the language. A weight value is
  specified after a corresponding language range followed by 
 <code>";q="</code>, and the default weight value is <code>MAX_WEIGHT</code>
  when it is omitted. 
 <p>Unlike a weighted list, language ranges in a prioritized list
  are sorted in the descending order based on its priority. The first
  language range has the highest priority and meets the user's
  preference most. 
 <p>In either case, language ranges are sorted in descending order in
  the Language Priority List based on priority or weight. If a
  language range appears in the given <code>ranges</code> more than once,
  only the first one is included on the Language Priority List. 
 <p>The returned list consists of language ranges from the given 
 <code>ranges</code> and their equivalents found in the IANA Language
  Subtag Registry. For example, if the given <code>ranges</code> is 
 <code>"Accept-Language: iw,en-us;q=0.7,en;q=0.3"</code>, the elements in
  the list to be returned are: 
 @code

    <b>Range</b>                                   <b>Weight</b>
     "iw" (older tag for Hebrew)             1.0
     "he" (new preferred code for Hebrew)    1.0
     "en-us" (English, United States)        0.7
     "en" (English)                          0.3 
  
@endcode
  Two language ranges, <code>"iw"</code> and <code>"he"</code>, have the same
  highest priority in the list. By adding <code>"he"</code> to the user's
  Language Priority List, locale-matching method can find Hebrew as a
  matching locale (or language tag) even if the application or system
  offers only <code>"he"</code> as a supported locale (or language tag).
 @param ranges a list of comma-separated language ranges or a list of      language ranges in the form of the "Accept-Language" header
       defined in 
  <a href="http://tools.ietf.org/html/rfc2616"> RFC      2616 </a>
 @return a Language Priority List consisting of language ranges
      included in the given <code>ranges</code> and their equivalent
      language ranges if available. The list is modifiable.
 @throw NullPointerExceptionif <code>ranges</code> is null
 @throw IllegalArgumentExceptionif a language range or a weight
      found in the given <code>ranges</code> is ill-formed
 */
+ (id<JavaUtilList> __nonnull)parseWithNSString:(NSString *)ranges;

/*!
 @brief Parses the given <code>ranges</code> to generate a Language Priority
  List, and then customizes the list using the given <code>map</code>.
 This method is equivalent to 
 <code>mapEquivalents(parse(ranges), map)</code>.
 @param ranges a list of comma-separated language ranges or a list      of language ranges in the form of the "Accept-Language" header
       defined in 
  <a href="http://tools.ietf.org/html/rfc2616"> RFC      2616 </a>
 @param map a map containing information to customize language ranges
 @return a Language Priority List with customization. The list is
      modifiable.
 @throw NullPointerExceptionif <code>ranges</code> is null
 @throw IllegalArgumentExceptionif a language range or a weight
      found in the given <code>ranges</code> is ill-formed
 - seealso: #parse(String)
 - seealso: #mapEquivalents
 */
+ (id<JavaUtilList> __nonnull)parseWithNSString:(NSString *)ranges
                                withJavaUtilMap:(id<JavaUtilMap>)map;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaUtilLocale_LanguageRange)

/*!
 @brief A constant holding the maximum value of weight, 1.0, which indicates
  that the language range is a good fit for the user.
 */
inline jdouble JavaUtilLocale_LanguageRange_get_MAX_WEIGHT(void);
#define JavaUtilLocale_LanguageRange_MAX_WEIGHT 1.0
J2OBJC_STATIC_FIELD_CONSTANT(JavaUtilLocale_LanguageRange, MAX_WEIGHT, jdouble)

/*!
 @brief A constant holding the minimum value of weight, 0.0, which indicates
  that the language range is not a good fit for the user.
 */
inline jdouble JavaUtilLocale_LanguageRange_get_MIN_WEIGHT(void);
#define JavaUtilLocale_LanguageRange_MIN_WEIGHT 0.0
J2OBJC_STATIC_FIELD_CONSTANT(JavaUtilLocale_LanguageRange, MIN_WEIGHT, jdouble)

FOUNDATION_EXPORT void JavaUtilLocale_LanguageRange_initWithNSString_(JavaUtilLocale_LanguageRange *self, NSString *range);

FOUNDATION_EXPORT JavaUtilLocale_LanguageRange *new_JavaUtilLocale_LanguageRange_initWithNSString_(NSString *range) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilLocale_LanguageRange *create_JavaUtilLocale_LanguageRange_initWithNSString_(NSString *range);

FOUNDATION_EXPORT void JavaUtilLocale_LanguageRange_initWithNSString_withDouble_(JavaUtilLocale_LanguageRange *self, NSString *range, jdouble weight);

FOUNDATION_EXPORT JavaUtilLocale_LanguageRange *new_JavaUtilLocale_LanguageRange_initWithNSString_withDouble_(NSString *range, jdouble weight) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaUtilLocale_LanguageRange *create_JavaUtilLocale_LanguageRange_initWithNSString_withDouble_(NSString *range, jdouble weight);

FOUNDATION_EXPORT id<JavaUtilList> JavaUtilLocale_LanguageRange_parseWithNSString_(NSString *ranges);

FOUNDATION_EXPORT id<JavaUtilList> JavaUtilLocale_LanguageRange_parseWithNSString_withJavaUtilMap_(NSString *ranges, id<JavaUtilMap> map);

FOUNDATION_EXPORT id<JavaUtilList> JavaUtilLocale_LanguageRange_mapEquivalentsWithJavaUtilList_withJavaUtilMap_(id<JavaUtilList> priorityList, id<JavaUtilMap> map);

J2OBJC_TYPE_LITERAL_HEADER(JavaUtilLocale_LanguageRange)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif
#pragma pop_macro("INCLUDE_ALL_JavaUtilLocale")
