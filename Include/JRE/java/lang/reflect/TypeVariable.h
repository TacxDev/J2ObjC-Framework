//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: openjdk/src/share/classes/java/lang/reflect/TypeVariable.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_JavaLangReflectTypeVariable")
#ifdef RESTRICT_JavaLangReflectTypeVariable
#define INCLUDE_ALL_JavaLangReflectTypeVariable 0
#else
#define INCLUDE_ALL_JavaLangReflectTypeVariable 1
#endif
#undef RESTRICT_JavaLangReflectTypeVariable

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (JavaLangReflectTypeVariable_) && (INCLUDE_ALL_JavaLangReflectTypeVariable || defined(INCLUDE_JavaLangReflectTypeVariable))
#define JavaLangReflectTypeVariable_

#define RESTRICT_JavaLangReflectType 1
#define INCLUDE_JavaLangReflectType 1
#include "java/lang/reflect/Type.h"

#define RESTRICT_JavaLangReflectAnnotatedElement 1
#define INCLUDE_JavaLangReflectAnnotatedElement 1
#include "java/lang/reflect/AnnotatedElement.h"

@class IOSObjectArray;
@protocol JavaLangReflectGenericDeclaration;

/*!
 @brief TypeVariable is the common superinterface for type variables of kinds.
 A type variable is created the first time it is needed by a reflective
  method, as specified in this package.  If a type variable t is referenced
  by a type (i.e, class, interface or annotation type) T, and T is declared
  by the nth enclosing class of T (see JLS 8.1.2), then the creation of t
  requires the resolution (see JVMS 5) of the ith enclosing class of T,
  for i = 0 to n, inclusive. Creating a type variable must not cause the
  creation of its bounds. Repeated creation of a type variable has no effect. 
 <p>Multiple objects may be instantiated at run-time to
  represent a given type variable. Even though a type variable is
  created only once, this does not imply any requirement to cache
  instances representing the type variable. However, all instances
  representing a type variable must be equal() to each other.
  As a consequence, users of type variables must not rely on the identity
  of instances of classes implementing this interface.
 @since 1.5
 */
@protocol JavaLangReflectTypeVariable < JavaLangReflectType, JavaLangReflectAnnotatedElement, JavaObject >

/*!
 @brief Returns an array of <code>Type</code> objects representing the
  upper bound(s) of this type variable.Note that if no upper bound is
  explicitly declared, the upper bound is <code>Object</code>.
 <p>For each upper bound B: <ul> <li>if B is a parameterized
  type or a type variable, it is created, (see <code>ParameterizedType</code>
  for the
  details of the creation process for parameterized types). 
 <li>Otherwise, B is resolved.  </ul>
 @throw TypeNotPresentExceptionif any of the
      bounds refers to a non-existent type declaration
 @throw MalformedParameterizedTypeExceptionif any of the
      bounds refer to a parameterized type that cannot be instantiated
      for any reason
 @return an array of <code>Type</code>s representing the upper
      bound(s) of this type variable
 */
- (IOSObjectArray * __nonnull)getBounds;

/*!
 @brief Returns the <code>GenericDeclaration</code> object representing the
  generic declaration declared this type variable.
 @return the generic declaration declared for this type variable.
 @since 1.5
 */
- (id<JavaLangReflectGenericDeclaration> __nonnull)getGenericDeclaration;

/*!
 @brief Returns the name of this type variable, as it occurs in the source code.
 @return the name of this type variable, as it appears in the source code
 */
- (NSString * __nonnull)getName;

/*!
 @brief Returns an array of AnnotatedType objects that represent the use of
  types to denote the upper bounds of the type parameter represented by
  this TypeVariable.The order of the objects in the array corresponds to
  the order of the bounds in the declaration of the type parameter.
 Returns an array of length 0 if the type parameter declares no bounds.
 @return an array of objects representing the upper bounds of the type variable
 @since 1.8
 */
- (IOSObjectArray *)getAnnotatedBounds;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaLangReflectTypeVariable)

J2OBJC_TYPE_LITERAL_HEADER(JavaLangReflectTypeVariable)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif
#pragma pop_macro("INCLUDE_ALL_JavaLangReflectTypeVariable")
