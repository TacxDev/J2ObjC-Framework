//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/platform/libcore/ojluni/src/main/java/java/io/PipedInputStream.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_JavaIoPipedInputStream")
#ifdef RESTRICT_JavaIoPipedInputStream
#define INCLUDE_ALL_JavaIoPipedInputStream 0
#else
#define INCLUDE_ALL_JavaIoPipedInputStream 1
#endif
#undef RESTRICT_JavaIoPipedInputStream

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (JavaIoPipedInputStream_) && (INCLUDE_ALL_JavaIoPipedInputStream || defined(INCLUDE_JavaIoPipedInputStream))
#define JavaIoPipedInputStream_

#define RESTRICT_JavaIoInputStream 1
#define INCLUDE_JavaIoInputStream 1
#include "java/io/InputStream.h"

@class IOSByteArray;
@class JavaIoPipedOutputStream;
@class JavaLangBoolean;
@class JavaLangInteger;
@class JavaLangThread;

/*!
 @brief A piped input stream should be connected
  to a piped output stream; the piped  input
  stream then provides whatever data bytes
  are written to the piped output  stream.
 Typically, data is read from a <code>PipedInputStream</code>
  object by one thread  and data is written
  to the corresponding <code>PipedOutputStream</code>
  by some  other thread. Attempting to use
  both objects from a single thread is not
  recommended, as it may deadlock the thread.
  The piped input stream contains a buffer,
  decoupling read operations from write operations,
  within limits.
  A pipe is said to be <a id="BROKEN"> <i>broken</i> </a> if a
  thread that was providing data bytes to the connected
  piped output stream is no longer alive.
 @author James Gosling
 - seealso: java.io.PipedOutputStream
 @since 1.0
 */
@interface JavaIoPipedInputStream : JavaIoInputStream {
 @public
  jboolean closedByWriter_;
  volatile_jboolean closedByReader_;
  jboolean connected_;
  JavaLangThread *readSide_;
  JavaLangThread *writeSide_;
  /*!
   @brief The circular buffer into which incoming data is placed.
   @since 1.1
   */
  IOSByteArray *buffer_;
  /*!
   @brief The index of the position in the circular buffer at which the
  next byte of data will be stored when received from the connected
  piped output stream.
   <code>in&lt;0</code> implies the buffer is empty, 
 <code>in==out</code> implies the buffer is full
   @since 1.1
   */
  jint in_;
  /*!
   @brief The index of the position in the circular buffer at which the next
  byte of data will be read by this piped input stream.
   @since 1.1
   */
  jint out_;
}

#pragma mark Public

/*!
 @brief Creates a <code>PipedInputStream</code> so
  that it is not yet connected
 .
 It must be connected
  to a 
 <code>PipedOutputStream</code> before being used.
 */
- (instancetype __nonnull)init;

/*!
 @brief Creates a <code>PipedInputStream</code> so that it is not yet 
 connected and
  uses the specified pipe size for the pipe's buffer.
 It must be connected
  to a <code>PipedOutputStream</code> before being used.
 @param pipeSize the size of the pipe's buffer.
 @throw IllegalArgumentExceptionif <code>pipeSize <= 0</code>.
 @since 1.6
 */
- (instancetype __nonnull)initWithInt:(jint)pipeSize;

/*!
 @brief Creates a <code>PipedInputStream</code> so
  that it is connected to the piped output
  stream <code>src</code>.Data bytes written
  to <code>src</code> will then be  available
  as input from this stream.
 @param src the stream to connect to.
 @throw IOExceptionif an I/O error occurs.
 */
- (instancetype __nonnull)initWithJavaIoPipedOutputStream:(JavaIoPipedOutputStream *)src;

/*!
 @brief Creates a <code>PipedInputStream</code> so that it is
  connected to the piped output stream 
 <code>src</code> and uses the specified pipe size for
  the pipe's buffer.
 Data bytes written to <code>src</code> will then
  be available as input from this stream.
 @param src the stream to connect to.
 @param pipeSize the size of the pipe's buffer.
 @throw IOExceptionif an I/O error occurs.
 @throw IllegalArgumentExceptionif <code>pipeSize <= 0</code>.
 @since 1.6
 */
- (instancetype __nonnull)initWithJavaIoPipedOutputStream:(JavaIoPipedOutputStream *)src
                                                  withInt:(jint)pipeSize;

/*!
 @brief Returns the number of bytes that can be read from this input
  stream without blocking.
 @return the number of bytes that can be read from this input stream
          without blocking, or <code>0</code> if this input stream has been
          closed by invoking its <code>close()</code> method, or if the pipe
          is <code>unconnected</code>, or
           <a href="#BROKEN"> <code>broken</code></a>.
 @throw IOExceptionif an I/O error occurs.
 @since 1.0.2
 */
- (jint)available;

/*!
 @brief Closes this piped input stream and releases any system resources
  associated with the stream.
 @throw IOExceptionif an I/O error occurs.
 */
- (void)close;

/*!
 @brief Causes this piped input stream to be connected
  to the piped  output stream <code>src</code>.
 If this object is already connected to some
  other piped output  stream, an <code>IOException</code>
  is thrown. 
 <p>
  If <code>src</code> is an
  unconnected piped output stream and <code>snk</code>
  is an unconnected piped input stream, they
  may be connected by either the call: 
 @code
<code>snk.connect(src)</code> 
@endcode
  <p>
  or the call: 
 @code
<code>src.connect(snk)</code> 
@endcode
  <p>
  The two calls have the same effect.
 @param src The piped output stream to connect to.
 @throw IOExceptionif an I/O error occurs.
 */
- (void)connectWithJavaIoPipedOutputStream:(JavaIoPipedOutputStream *)src;

/*!
 @brief Reads the next byte of data from this piped input stream.The
  value byte is returned as an <code>int</code> in the range 
 <code>0</code> to <code>255</code>.
 This method blocks until input data is available, the end of the
  stream is detected, or an exception is thrown.
 @return the next byte of data, or <code>-1</code> if the end of the
              stream is reached.
 @throw IOExceptionif the pipe is
            <code>unconnected</code>,
            <a href="#BROKEN"> <code>broken</code></a>, closed,
            or if an I/O error occurs.
 */
- (jint)read;

/*!
 @brief Reads up to <code>len</code> bytes of data from this piped input
  stream into an array of bytes.Less than <code>len</code> bytes
  will be read if the end of the data stream is reached or if 
 <code>len</code> exceeds the pipe's buffer size.
 If <code>len </code> is zero, then no bytes are read and 0 is returned;
  otherwise, the method blocks until at least 1 byte of input is
  available, end of the stream has been detected, or an exception is
  thrown.
 @param b the buffer into which the data is read.
 @param off the start offset in the destination array  <code> b </code>
 @param len the maximum number of bytes read.
 @return the total number of bytes read into the buffer, or
              <code>-1</code> if there is no more data because the end of
              the stream has been reached.
 @throw NullPointerExceptionIf <code>b</code> is <code>null</code>.
 @throw IndexOutOfBoundsExceptionIf <code>off</code> is negative, 
 <code>len</code> is negative, or <code>len</code> is greater than 
 <code>b.length - off</code>
 @throw IOExceptionif the pipe is <a href="#BROKEN"> <code>broken</code></a>,
            <code>unconnected</code>,
            closed, or if an I/O error occurs.
 */
- (jint)readWithByteArray:(IOSByteArray *)b
                  withInt:(jint)off
                  withInt:(jint)len;

#pragma mark Protected

/*!
 @brief Receives a byte of data.This method will block if no input is
  available.
 @param b the byte being received
 @throw IOExceptionIf the pipe is <a href="#BROKEN"> <code>broken</code></a>,
           <code>unconnected</code>,
           closed, or if an I/O error occurs.
 @since 1.1
 */
- (void)receiveWithInt:(jint)b;

#pragma mark Package-Private

/*!
 @brief Receives data into an array of bytes.This method will
  block until some input is available.
 @param b the buffer into which the data is received
 @param off the start offset of the data
 @param len the maximum number of bytes received
 @throw IOExceptionIf the pipe is <a href="#BROKEN"> broken</a>,
            <code>unconnected</code>,
            closed,or if an I/O error occurs.
 */
- (void)receiveWithByteArray:(IOSByteArray *)b
                     withInt:(jint)off
                     withInt:(jint)len;

/*!
 @brief Notifies all waiting threads that the last byte of data has been
  received.
 */
- (void)receivedLast;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaIoPipedInputStream)

J2OBJC_FIELD_SETTER(JavaIoPipedInputStream, readSide_, JavaLangThread *)
J2OBJC_FIELD_SETTER(JavaIoPipedInputStream, writeSide_, JavaLangThread *)
J2OBJC_FIELD_SETTER(JavaIoPipedInputStream, buffer_, IOSByteArray *)

/*!
 @brief The default size of the pipe's circular input buffer.
 @since 1.1
 */
inline jint JavaIoPipedInputStream_get_PIPE_SIZE(void);
#define JavaIoPipedInputStream_PIPE_SIZE 1024
J2OBJC_STATIC_FIELD_CONSTANT(JavaIoPipedInputStream, PIPE_SIZE, jint)

FOUNDATION_EXPORT void JavaIoPipedInputStream_initWithJavaIoPipedOutputStream_(JavaIoPipedInputStream *self, JavaIoPipedOutputStream *src);

FOUNDATION_EXPORT JavaIoPipedInputStream *new_JavaIoPipedInputStream_initWithJavaIoPipedOutputStream_(JavaIoPipedOutputStream *src) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaIoPipedInputStream *create_JavaIoPipedInputStream_initWithJavaIoPipedOutputStream_(JavaIoPipedOutputStream *src);

FOUNDATION_EXPORT void JavaIoPipedInputStream_initWithJavaIoPipedOutputStream_withInt_(JavaIoPipedInputStream *self, JavaIoPipedOutputStream *src, jint pipeSize);

FOUNDATION_EXPORT JavaIoPipedInputStream *new_JavaIoPipedInputStream_initWithJavaIoPipedOutputStream_withInt_(JavaIoPipedOutputStream *src, jint pipeSize) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaIoPipedInputStream *create_JavaIoPipedInputStream_initWithJavaIoPipedOutputStream_withInt_(JavaIoPipedOutputStream *src, jint pipeSize);

FOUNDATION_EXPORT void JavaIoPipedInputStream_init(JavaIoPipedInputStream *self);

FOUNDATION_EXPORT JavaIoPipedInputStream *new_JavaIoPipedInputStream_init(void) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaIoPipedInputStream *create_JavaIoPipedInputStream_init(void);

FOUNDATION_EXPORT void JavaIoPipedInputStream_initWithInt_(JavaIoPipedInputStream *self, jint pipeSize);

FOUNDATION_EXPORT JavaIoPipedInputStream *new_JavaIoPipedInputStream_initWithInt_(jint pipeSize) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaIoPipedInputStream *create_JavaIoPipedInputStream_initWithInt_(jint pipeSize);

J2OBJC_TYPE_LITERAL_HEADER(JavaIoPipedInputStream)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif
#pragma pop_macro("INCLUDE_ALL_JavaIoPipedInputStream")
