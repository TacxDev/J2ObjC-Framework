//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/platform/libcore/ojluni/src/main/java/java/text/SimpleDateFormat.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_JavaTextSimpleDateFormat")
#ifdef RESTRICT_JavaTextSimpleDateFormat
#define INCLUDE_ALL_JavaTextSimpleDateFormat 0
#else
#define INCLUDE_ALL_JavaTextSimpleDateFormat 1
#endif
#undef RESTRICT_JavaTextSimpleDateFormat

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (JavaTextSimpleDateFormat_) && (INCLUDE_ALL_JavaTextSimpleDateFormat || defined(INCLUDE_JavaTextSimpleDateFormat))
#define JavaTextSimpleDateFormat_

#define RESTRICT_JavaTextDateFormat 1
#define INCLUDE_JavaTextDateFormat 1
#include "java/text/DateFormat.h"

@class JavaLangBoolean;
@class JavaLangInteger;
@class JavaLangLong;
@class JavaLangStringBuffer;
@class JavaTextDateFormatSymbols;
@class JavaTextFieldPosition;
@class JavaTextParsePosition;
@class JavaUtilDate;
@class JavaUtilLocale;
@protocol JavaTextAttributedCharacterIterator;

/*!
 @brief <code>SimpleDateFormat</code> is a concrete class for formatting and
  parsing dates in a locale-sensitive manner.It allows for formatting
  (date &rarr; text), parsing (text &rarr; date), and normalization.
 <p>
  <code>SimpleDateFormat</code> allows you to start by choosing
  any user-defined patterns for date-time formatting. However, you
  are encouraged to create a date-time formatter with either 
 <code>getTimeInstance</code>, <code>getDateInstance</code>, or 
 <code>getDateTimeInstance</code> in <code>DateFormat</code>. Each
  of these class methods can return a date/time formatter initialized
  with a default format pattern. You may modify the format pattern
  using the <code>applyPattern</code> methods as desired.
  For more information on using these methods, see 
 <code>DateFormat</code>.
  
 <h3>Date and Time Patterns</h3>
  <p>
  Date and time formats are specified by <em>date and time pattern</em>
  strings.
  Within date and time pattern strings, unquoted letters from 
 <code>'A'</code> to <code>'Z'</code> and from <code>'a'</code> to 
 <code>'z'</code> are interpreted as pattern letters representing the
  components of a date or time string.
  Text can be quoted using single quotes (<code>'</code>) to avoid
  interpretation. 
 <code>"''"</code> represents a single quote.
  All other characters are not interpreted; they're simply copied into the
  output string during formatting or matched against the input string
  during parsing. 
 <p>
  The following pattern letters are defined (all other characters from 
 <code>'A'</code> to <code>'Z'</code> and from <code>'a'</code> to 
 <code>'z'</code> are reserved): 
 <blockquote>
  <table class="striped">
  <caption style="display:none">Chart shows pattern letters, date/time component, presentation, and examples.</caption>
  <thead>
      <tr>
          <th scope="col" style="text-align:left">Letter
          <th scope="col" style="text-align:left">Date or Time Component
          <th scope="col" style="text-align:left">Presentation
          <th scope="col" style="text-align:left">Examples
          <th scope="col" style="text-align:left">Supported (API Levels) 
 </thead>
  <tbody>
      <tr>
          <th scope="row"><code>G</code>
          <td>Era designator
          <td><a href="#text">Text</a>
          <td><code>AD</code>
          <td>1+</td>
      <tr>
          <th scope="row"><code>y</code>
          <td>Year
          <td><a href="#year">Year</a>
          <td><code>1996</code>; <code>96</code>
          <td>1+</td>
      <tr>
          <th scope="row"><code>Y</code>
          <td>Week year
          <td><a href="#year">Year</a>
          <td><code>2009</code>; <code>09</code>
          <td>24+</td>
      <tr>
          <th scope="row"><code>M</code>
          <td>Month in year (context sensitive)
          <td><a href="#month">Month</a>
          <td><code>July</code>; <code>Jul</code>; <code>07</code>
          <td>1+</td>
      <tr>
          <th scope="row"><code>L</code>
          <td>Month in year (standalone form)
          <td><a href="#month">Month</a>
          <td><code>July</code>; <code>Jul</code>; <code>07</code>
          <td>TBD</td>
      <tr>
          <th scope="row"><code>w</code>
          <td>Week in year
          <td><a href="#number">Number</a>
          <td><code>27</code>
          <td>1+</td>
      <tr>
          <th scope="row"><code>W</code>
          <td>Week in month
          <td><a href="#number">Number</a>
          <td><code>2</code>
          <td>1+</td>
      <tr>
          <th scope="row"><code>D</code>
          <td>Day in year
          <td><a href="#number">Number</a>
          <td><code>189</code>
          <td>1+</td>
      <tr>
          <th scope="row"><code>d</code>
          <td>Day in month
          <td><a href="#number">Number</a>
          <td><code>10</code>
          <td>1+</td>
      <tr>
          <th scope="row"><code>F</code>
          <td>Day of week in month
          <td><a href="#number">Number</a>
          <td><code>2</code>
          <td>1+</td>
      <tr>
          <th scope="row"><code>E</code>
          <td>Day name in week
          <td><a href="#text">Text</a>
          <td><code>Tuesday</code>; <code>Tue</code>
          <td>1+</td>
      <tr>
          <th scope="row"><code>u</code>
          <td>Day number of week (1 = Monday, ..., 7 = Sunday)
          <td><a href="#number">Number</a>
          <td><code>1</code>
          <td>24+</td>
      <tr>
          <th scope="row"><code>a</code>
          <td>Am/pm marker
          <td><a href="#text">Text</a>
          <td><code>PM</code>
          <td>1+</td>
      <tr>
          <th scope="row"><code>H</code>
          <td>Hour in day (0-23)
          <td><a href="#number">Number</a>
          <td><code>0</code>
          <td>1+</td>
      <tr>
          <th scope="row"><code>k</code>
          <td>Hour in day (1-24)
          <td><a href="#number">Number</a>
          <td><code>24</code>
          <td>1+</td>
      <tr>
          <th scope="row"><code>K</code>
          <td>Hour in am/pm (0-11)
          <td><a href="#number">Number</a>
          <td><code>0</code>
          <td>1+</td>
      <tr>
          <th scope="row"><code>h</code>
          <td>Hour in am/pm (1-12)
          <td><a href="#number">Number</a>
          <td><code>12</code>
          <td>1+</td>
      <tr>
          <th scope="row"><code>m</code>
          <td>Minute in hour
          <td><a href="#number">Number</a>
          <td><code>30</code>
          <td>1+</td>
      <tr>
          <th scope="row"><code>s</code>
          <td>Second in minute
          <td><a href="#number">Number</a>
          <td><code>55</code>
          <td>1+</td>
      <tr>
          <th scope="row"><code>S</code>
          <td>Millisecond
          <td><a href="#number">Number</a>
          <td><code>978</code>
          <td>1+</td>
      <tr>
          <th scope="row"><code>z</code>
          <td>Time zone
          <td><a href="#timezone">General time zone</a>
          <td><code>Pacific Standard Time</code>; <code>PST</code>; <code>GMT-08:00</code>
          <td>1+</td>
      <tr>
          <th scope="row"><code>Z</code>
          <td>Time zone
          <td><a href="#rfc822timezone">RFC 822 time zone</a>
          <td><code>-0800</code>
          <td>1+</td>
      <tr>
          <th scope="row"><code>X</code>
          <td>Time zone
          <td><a href="#iso8601timezone">ISO 8601 time zone</a>
          <td><code>-08</code>; <code>-0800</code>;  <code>-08:00</code>
          <td>24+</td>
  </tbody>
  </table>
  </blockquote>
  Pattern letters are usually repeated, as their number determines the
  exact presentation: 
 <ul>
  <li><strong><a id="text">Text:</a></strong>
      For formatting, if the number of pattern letters is 4 or more,
      the full form is used; otherwise a short or abbreviated form
      is used if available.
      For parsing, both forms are accepted, independent of the number
      of pattern letters.</li>
  <li><strong><a id="number">Number:</a></strong>
      For formatting, the number of pattern letters is the minimum
      number of digits, and shorter numbers are zero-padded to this amount.
      For parsing, the number of pattern letters is ignored unless
      it's needed to separate two adjacent fields.</li>
  <li><strong><a id="year">Year:</a></strong>
      If the formatter's <code>Calendar</code> is the Gregorian
      calendar, the following rules are applied.     
 <ul>
      <li>For formatting, if the number of pattern letters is 2, the year
          is truncated to 2 digits; otherwise it is interpreted as a         
 <a href="#number">number</a>.
      <li>For parsing, if the number of pattern letters is more than 2,
          the year is interpreted literally, regardless of the number of
          digits. So using the pattern "MM/dd/yyyy", "01/11/12" parses to
          Jan 11, 12 A.D.     
 <li>For parsing with the abbreviated year pattern ("y" or "yy"),
          <code>SimpleDateFormat</code> must interpret the abbreviated year
          relative to some century.  It does this by adjusting dates to be
          within 80 years before and 20 years after the time the <code>SimpleDateFormat</code>
          instance is created. For example, using a pattern of "MM/dd/yy" and a         
 <code>SimpleDateFormat</code> instance created on Jan 1, 1997,  the string
          "01/11/12" would be interpreted as Jan 11, 2012 while the string "05/04/64"
          would be interpreted as May 4, 1964.
          During parsing, only strings consisting of exactly two digits, as defined by         
 <code>Character.isDigit(char)</code>, will be parsed into the default century.
          Any other numeric string, such as a one digit string, a three or more digit
          string, or a two digit string that isn't all digits (for example, "-1"), is
          interpreted literally.  So "01/02/3" or "01/02/003" are parsed, using the
          same pattern, as Jan 2, 3 AD.  Likewise, "01/02/-3" is parsed as Jan 2, 4 BC.     
 </ul>
      Otherwise, calendar system specific forms are applied.
      For both formatting and parsing, if the number of pattern
      letters is 4 or more, a calendar specific long form
  is used. Otherwise, a calendar
      specific short or abbreviated form
      is used.     
 <br>
      If week year <code>'Y'</code> is specified and the calendar
  doesn't support any <a href="../util/GregorianCalendar.html#week_year">
  week
      years</a>, the calendar year (<code>'y'</code>) is used instead. The
      support of week years can be tested with a call to <code>getCalendar()</code>
 .<code>isWeekDateSupported()</code>
 .</li>
  <li><strong><a id="month">Month:</a></strong>
      If the number of pattern letters is 3 or more, the month is
      interpreted as <a href="#text">text</a>; otherwise,
      it is interpreted as a <a href="#number">number</a>.
      <ul>
      <li>Letter <em>M</em> produces context-sensitive month names, such as the
          embedded form of names. Letter <em>M</em> is context-sensitive in the
          sense that when it is used in the standalone pattern, for example,
          "MMMM", it gives the standalone form of a month name and when it is
          used in the pattern containing other field(s), for example, "d MMMM",
          it gives the format form of a month name. For example, January in the
          Catalan language is "de gener" in the format form while it is "gener"
          in the standalone form. In this case, "MMMM" will produce "gener" and
          the month part of the "d MMMM" will produce "de gener". If a         
 <code>DateFormatSymbols</code> has been set explicitly with constructor
          <code>SimpleDateFormat(String,DateFormatSymbols)</code> or method <code>setDateFormatSymbols(DateFormatSymbols)</code>
 , the month names given by
          the <code>DateFormatSymbols</code> are used.</li>
      <li>Letter <em>L</em> produces the standalone form of month names.</li>
      </ul>
      <br></li>
  <li><strong><a id="timezone">General time zone:</a></strong>
      Time zones are interpreted as <a href="#text">text</a> if they have
      names. For time zones representing a GMT offset value, the
      following syntax is used:     
 @code

          <a id="GMTOffsetTimeZone"><i>GMTOffsetTimeZone:</i></a>
                          <code>GMT</code> <i>Sign</i> <i>Hours</i> <code>:</code> <i>Minutes</i>
          <i>Sign:</i> one of
                          <code>+ -</code>
          <i>Hours:</i>
                          <i>Digit</i>
                          <i>Digit</i> <i>Digit</i>
          <i>Minutes:</i>
                          <i>Digit</i> <i>Digit</i>
          <i>Digit:</i> one of
                          <code>0 1 2 3 4 5 6 7 8 9</code>
@endcode
      <i>Hours</i> must be between 0 and 23, and <i>Minutes</i> must be between
      00 and 59. The format is locale independent and digits must be taken
      from the Basic Latin block of the Unicode standard.     
 <p>For parsing, <a href="#rfc822timezone">RFC 822 time zones</a> are also
      accepted.</li>
  <li><strong><a id="rfc822timezone">RFC 822 time zone:</a></strong>
      For formatting, the RFC 822 4-digit time zone format is used:     
 @code

          <i>RFC822TimeZone:</i>
                          <i>Sign</i> <i>TwoDigitHours</i> <i>Minutes</i>
          <i>TwoDigitHours:</i>
                          <i>Digit Digit</i>
@endcode
      <i>TwoDigitHours</i> must be between 00 and 23. Other definitions
      are as for <a href="#timezone">general time zones</a>.
      <p>For parsing, <a href="#timezone">general time zones</a> are also
      accepted. 
 <li><strong><a id="iso8601timezone">ISO 8601 Time zone:</a></strong>
      The number of pattern letters designates the format for both formatting
      and parsing as follows:     
 @code

          <i>ISO8601TimeZone:</i>
                          <i>OneLetterISO8601TimeZone</i>
                          <i>TwoLetterISO8601TimeZone</i>
                          <i>ThreeLetterISO8601TimeZone</i>
          <i>OneLetterISO8601TimeZone:</i>
                          <i>Sign</i> <i>TwoDigitHours</i>
              Z
          <i>TwoLetterISO8601TimeZone:</i>
                          <i>Sign</i> <i>TwoDigitHours</i> <i>Minutes</i>
              Z
          <i>ThreeLetterISO8601TimeZone:</i>
                          <i>Sign</i> <i>TwoDigitHours</i> : <i>Minutes</i>
              Z
@endcode
      Other definitions are as for <a href="#timezone">general time zones</a> or
      <a href="#rfc822timezone">RFC 822 time zones</a>.
      <p>For formatting, if the offset value from GMT is 0, <code>"Z"</code> is
      produced. If the number of pattern letters is 1, any fraction of an hour
      is ignored. For example, if the pattern is <code>"X"</code> and the time zone is
      <code>"GMT+05:30"</code>, <code>"+05"</code> is produced.
      <p>For parsing, the letter <code>"Z"</code> is parsed as the UTC time zone designator (therefore
      <code>"09:30Z"</code> is parsed as <code>"09:30 UTC"</code>.
      <a href="#timezone">General time zones</a> are <em>not</em> accepted.
      <p>If the number of <code>"X"</code> pattern letters is 4 or more (e.g. <code>XXXX</code>), <code>IllegalArgumentException</code>
  is thrown when constructing a <code>SimpleDateFormat</code>
  or applying a
      pattern
 .
  </ul>
  <code>SimpleDateFormat</code> also supports <em>localized date and time
  pattern</em> strings. In these strings, the pattern letters described above
  may be replaced with other, locale dependent, pattern letters. 
 <code>SimpleDateFormat</code> does not deal with the localization of text
  other than the pattern letters; that's up to the client of the class. 
 <h4>Examples</h4>
  The following examples show how date and time patterns are interpreted in
  the U.S. locale. The given date and time are 2001-07-04 12:08:56 local time
  in the U.S. Pacific Time time zone. 
 <blockquote>
  <table class="striped">
  <caption style="display:none">Examples of date and time patterns interpreted in the U.S. locale</caption>
  <thead>
      <tr>
          <th scope="col" style="text-align:left">Date and Time Pattern
          <th scope="col" style="text-align:left">Result
  </thead>
  <tbody>
      <tr>
          <th scope="row"><code>"yyyy.MM.dd G 'at' HH:mm:ss z"</code>
          <td><code>2001.07.04 AD at 12:08:56 PDT</code>
      <tr>
          <th scope="row"><code>"EEE, MMM d, ''yy"</code>
          <td><code>Wed, Jul 4, '01</code>
      <tr>
          <th scope="row"><code>"h:mm a"</code>
          <td><code>12:08 PM</code>
      <tr>
          <th scope="row"><code>"hh 'o''clock' a, zzzz"</code>
          <td><code>12 o'clock PM, Pacific Daylight Time</code>
      <tr>
          <th scope="row"><code>"K:mm a, z"</code>
          <td><code>0:08 PM, PDT</code>
      <tr>
          <th scope="row"><code>"yyyyy.MMMM.dd GGG hh:mm aaa"</code>
          <td><code>02001.July.04 AD 12:08 PM</code>
      <tr>
          <th scope="row"><code>"EEE, d MMM yyyy HH:mm:ss Z"</code>
          <td><code>Wed, 4 Jul 2001 12:08:56 -0700</code>
      <tr>
          <th scope="row"><code>"yyMMddHHmmssZ"</code>
          <td><code>010704120856-0700</code>
      <tr>
          <th scope="row"><code>"yyyy-MM-dd'T'HH:mm:ss.SSSZ"</code>
          <td><code>2001-07-04T12:08:56.235-0700</code>
      <tr>
          <th scope="row"><code>"yyyy-MM-dd'T'HH:mm:ss.SSSXXX"</code>
          <td><code>2001-07-04T12:08:56.235-07:00</code>
      <tr>
          <th scope="row"><code>"YYYY-'W'ww-u"</code>
          <td><code>2001-W27-3</code>
  </tbody>
  </table>
  </blockquote>
  
 <h4><a id="synchronization">Synchronization</a></h4>
  
 <p>
  Date formats are not synchronized.
  It is recommended to create separate format instances for each thread.
  If multiple threads access a format concurrently, it must be synchronized
  externally.
 - seealso: <a href="http://docs.oracle.com/javase/tutorial/i18n/format/simpleDateFormat.html">Java Tutorial</a>
 - seealso: java.util.Calendar
 - seealso: java.util.TimeZone
 - seealso: DateFormat
 - seealso: DateFormatSymbols
 @author Mark Davis, Chen-Lieh Huang, Alan Liu
 @since 1.1
 */
@interface JavaTextSimpleDateFormat : JavaTextDateFormat {
 @public
  /*!
   @brief Indicates whether this <code>SimpleDateFormat</code> should use
  the DateFormatSymbols.If true, the format and parse methods
  use the DateFormatSymbols values.
   If false, the format and
  parse methods call Calendar.getDisplayName or
  Calendar.getDisplayNames.
   */
  jboolean useDateFormatSymbols_;
}

#pragma mark Public

/*!
 @brief Constructs a <code>SimpleDateFormat</code> using the default pattern and
  date format symbols for the default 
 <code>FORMAT</code> locale.
 <b>Note:</b> This constructor may not support all locales.
  For full coverage, use the factory methods in the <code>DateFormat</code>
  class.
 */
- (instancetype __nonnull)init;

/*!
 @brief Constructs a <code>SimpleDateFormat</code> using the given pattern and
  the default date format symbols for the default 
 <code>FORMAT</code> locale.
 <b>Note:</b> This constructor may not support all locales.
  For full coverage, use the factory methods in the <code>DateFormat</code>
  class. 
 <p>This is equivalent to calling 
 <code>SimpleDateFormat(pattern, Locale.getDefault(Locale.Category.FORMAT))</code>
 .
 - seealso: java.util.Locale#getDefault(java.util.Locale.Category)
 - seealso: java.util.Locale.Category#FORMAT
 @param pattern the pattern describing the date and time format
 @throw NullPointerExceptionif the given pattern is null
 @throw IllegalArgumentExceptionif the given pattern is invalid
 */
- (instancetype __nonnull)initWithNSString:(NSString *)pattern;

/*!
 @brief Constructs a <code>SimpleDateFormat</code> using the given pattern and
  date format symbols.
 @param pattern the pattern describing the date and time format
 @param formatSymbols the date format symbols to be used for formatting
 @throw NullPointerExceptionif the given pattern or formatSymbols is null
 @throw IllegalArgumentExceptionif the given pattern is invalid
 */
- (instancetype __nonnull)initWithNSString:(NSString *)pattern
             withJavaTextDateFormatSymbols:(JavaTextDateFormatSymbols *)formatSymbols;

/*!
 @brief Constructs a <code>SimpleDateFormat</code> using the given pattern and
  the default date format symbols for the given locale.
 <b>Note:</b> This constructor may not support all locales.
  For full coverage, use the factory methods in the <code>DateFormat</code>
  class.
 @param pattern the pattern describing the date and time format
 @param locale the locale whose date format symbols should be used
 @throw NullPointerExceptionif the given pattern or locale is null
 @throw IllegalArgumentExceptionif the given pattern is invalid
 */
- (instancetype __nonnull)initWithNSString:(NSString *)pattern
                        withJavaUtilLocale:(JavaUtilLocale *)locale;

/*!
 @brief Applies the given localized pattern string to this date format.
 @param pattern a String to be mapped to the new date and time format         pattern for this format
 @throw NullPointerExceptionif the given pattern is null
 @throw IllegalArgumentExceptionif the given pattern is invalid
 */
- (void)applyLocalizedPatternWithNSString:(NSString *)pattern;

/*!
 @brief Applies the given pattern string to this date format.
 @param pattern the new date and time pattern for this date format
 @throw NullPointerExceptionif the given pattern is null
 @throw IllegalArgumentExceptionif the given pattern is invalid
 */
- (void)applyPatternWithNSString:(NSString *)pattern;

/*!
 @brief Creates a copy of this <code>SimpleDateFormat</code>.This also
  clones the format's date format symbols.
 @return a clone of this <code>SimpleDateFormat</code>
 */
- (id)java_clone;

/*!
 @brief Compares the given object with this <code>SimpleDateFormat</code> for
  equality.
 @return true if the given object is equal to this 
 <code>SimpleDateFormat</code>
 */
- (jboolean)isEqual:(id)obj;

/*!
 @brief Formats the given <code>Date</code> into a date/time string and appends
  the result to the given <code>StringBuffer</code>.
 @param date the date-time value to be formatted into a date-time string.
 @param toAppendTo where the new date-time text is to be appended.
 @param pos keeps track on the position of the field within  the returned string. For example, given a date-time text
   <code>"1996.07.10 AD at 15:08:56 PDT"</code>
  , if the given <code>fieldPosition</code>  is <code>DateFormat.YEAR_FIELD</code>
  , the begin index and end index of  <code>fieldPosition</code>
   will be set to 0 and 4, respectively.  Notice that if the same date-time field appears more than once in a
   pattern, the <code>fieldPosition</code>
   will be set for the first occurrence  of that date-time field. For instance, formatting a 
 <code>Date</code>  to the  date-time string <code>"1 PM PDT (Pacific Daylight Time)"</code>
   using the  pattern <code>"h a z (zzzz)"</code>  and the alignment field
   <code>DateFormat.TIMEZONE_FIELD</code> , the begin index and end index of
   <code>fieldPosition</code>  will be set to 5 and 8, respectively, for the
   first occurrence of the timezone pattern character <code>'z'</code>
  .
 @return the formatted date-time string.
 @throw NullPointerExceptionif any of the parameters is <code>null</code>.
 */
- (JavaLangStringBuffer *)formatWithJavaUtilDate:(JavaUtilDate *)date
                        withJavaLangStringBuffer:(JavaLangStringBuffer *)toAppendTo
                       withJavaTextFieldPosition:(JavaTextFieldPosition *)pos;

/*!
 @brief Formats an Object producing an <code>AttributedCharacterIterator</code>.
 You can use the returned <code>AttributedCharacterIterator</code>
  to build the resulting String, as well as to determine information
  about the resulting String. 
 <p>
  Each attribute key of the AttributedCharacterIterator will be of type 
 <code>DateFormat.Field</code>, with the corresponding attribute value
  being the same as the attribute key.
 @throw NullPointerExceptionif obj is null.
 @throw IllegalArgumentExceptionif the Format cannot format the
             given object, or if the Format's pattern string is invalid.
 @param obj The object to format
 @return AttributedCharacterIterator describing the formatted value.
 @since 1.4
 */
- (id<JavaTextAttributedCharacterIterator>)formatToCharacterIteratorWithId:(id)obj;

/*!
 @brief Returns the beginning date of the 100-year period 2-digit years are interpreted
  as being within.
 @return the start of the 100-year period into which two digit years are
  parsed
 - seealso: #set2DigitYearStart
 @since 1.2
 */
- (JavaUtilDate *)get2DigitYearStart;

/*!
 @brief Gets a copy of the date and time format symbols of this date format.
 @return the date and time format symbols of this date format
 - seealso: #setDateFormatSymbols
 */
- (JavaTextDateFormatSymbols *)getDateFormatSymbols;

/*!
 @brief Returns the hash code value for this <code>SimpleDateFormat</code> object.
 @return the hash code value for this <code>SimpleDateFormat</code> object.
 */
- (NSUInteger)hash;

/*!
 @brief Parses text from a string to produce a <code>Date</code>.
 <p>
  The method attempts to parse text starting at the index given by 
 <code>pos</code>.
  If parsing succeeds, then the index of <code>pos</code> is updated
  to the index after the last character used (parsing does not necessarily
  use all characters up to the end of the string), and the parsed
  date is returned. The updated <code>pos</code> can be used to
  indicate the starting point for the next call to this method.
  If an error occurs, then the index of <code>pos</code> is not
  changed, the error index of <code>pos</code> is set to the index of
  the character where the error occurred, and null is returned. 
 <p>This parsing operation uses the <code>calendar</code>
  to produce a <code>Date</code>. All of the <code>calendar</code>
 's date-time fields are cleared
  before parsing, and the <code>calendar</code>'s default
  values of the date-time fields are used for any missing
  date-time information. For example, the year value of the
  parsed <code>Date</code> is 1970 with <code>GregorianCalendar</code> if
  no year value is given from the parsing operation.  The <code>TimeZone</code>
  value may be overwritten, depending on the given
  pattern and the time zone value in <code>text</code>. Any <code>TimeZone</code>
  value that has previously been set by a call to 
 <code>setTimeZone</code> may need
  to be restored for further operations.
 @param text A  <code> String </code> , part of which should be parsed.
 @param pos A  <code> ParsePosition </code>  object with index and error
                index information as described above.
 @return A <code>Date</code> parsed from the string. In case of
          error, returns null.
 @throw NullPointerExceptionif <code>text</code> or <code>pos</code> is null.
 */
- (JavaUtilDate *)parseWithNSString:(NSString *)text
          withJavaTextParsePosition:(JavaTextParsePosition *)pos;

/*!
 @brief Sets the 100-year period 2-digit years will be interpreted as being in
  to begin on the date the user specifies.
 @param startDate During parsing, two digit years will be placed in the range  
  <code> startDate </code>  to  <code> startDate + 100 years </code> .
 - seealso: #get2DigitYearStart
 @throw NullPointerExceptionif <code>startDate</code> is <code>null</code>.
 @since 1.2
 */
- (void)set2DigitYearStartWithJavaUtilDate:(JavaUtilDate *)startDate;

/*!
 @brief Sets the date and time format symbols of this date format.
 @param newFormatSymbols the new date and time format symbols
 @throw NullPointerExceptionif the given newFormatSymbols is null
 - seealso: #getDateFormatSymbols
 */
- (void)setDateFormatSymbolsWithJavaTextDateFormatSymbols:(JavaTextDateFormatSymbols *)newFormatSymbols;

/*!
 @brief Returns a localized pattern string describing this date format.
 @return a localized pattern string describing this date format.
 */
- (NSString *)toLocalizedPattern;

/*!
 @brief Returns a pattern string describing this date format.
 @return a pattern string describing this date format.
 */
- (NSString *)toPattern;

#pragma mark Package-Private

- (instancetype __nonnull)initWithInt:(jint)timeStyle
                              withInt:(jint)dateStyle
                   withJavaUtilLocale:(JavaUtilLocale *)loc;

@end

J2OBJC_STATIC_INIT(JavaTextSimpleDateFormat)

inline jlong JavaTextSimpleDateFormat_get_serialVersionUID(void);
#define JavaTextSimpleDateFormat_serialVersionUID 4774881970558875024LL
J2OBJC_STATIC_FIELD_CONSTANT(JavaTextSimpleDateFormat, serialVersionUID, jlong)

inline jint JavaTextSimpleDateFormat_get_currentSerialVersion(void);
#define JavaTextSimpleDateFormat_currentSerialVersion 1
J2OBJC_STATIC_FIELD_CONSTANT(JavaTextSimpleDateFormat, currentSerialVersion, jint)

FOUNDATION_EXPORT void JavaTextSimpleDateFormat_init(JavaTextSimpleDateFormat *self);

FOUNDATION_EXPORT JavaTextSimpleDateFormat *new_JavaTextSimpleDateFormat_init(void) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaTextSimpleDateFormat *create_JavaTextSimpleDateFormat_init(void);

FOUNDATION_EXPORT void JavaTextSimpleDateFormat_initWithNSString_(JavaTextSimpleDateFormat *self, NSString *pattern);

FOUNDATION_EXPORT JavaTextSimpleDateFormat *new_JavaTextSimpleDateFormat_initWithNSString_(NSString *pattern) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaTextSimpleDateFormat *create_JavaTextSimpleDateFormat_initWithNSString_(NSString *pattern);

FOUNDATION_EXPORT void JavaTextSimpleDateFormat_initWithNSString_withJavaUtilLocale_(JavaTextSimpleDateFormat *self, NSString *pattern, JavaUtilLocale *locale);

FOUNDATION_EXPORT JavaTextSimpleDateFormat *new_JavaTextSimpleDateFormat_initWithNSString_withJavaUtilLocale_(NSString *pattern, JavaUtilLocale *locale) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaTextSimpleDateFormat *create_JavaTextSimpleDateFormat_initWithNSString_withJavaUtilLocale_(NSString *pattern, JavaUtilLocale *locale);

FOUNDATION_EXPORT void JavaTextSimpleDateFormat_initWithNSString_withJavaTextDateFormatSymbols_(JavaTextSimpleDateFormat *self, NSString *pattern, JavaTextDateFormatSymbols *formatSymbols);

FOUNDATION_EXPORT JavaTextSimpleDateFormat *new_JavaTextSimpleDateFormat_initWithNSString_withJavaTextDateFormatSymbols_(NSString *pattern, JavaTextDateFormatSymbols *formatSymbols) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaTextSimpleDateFormat *create_JavaTextSimpleDateFormat_initWithNSString_withJavaTextDateFormatSymbols_(NSString *pattern, JavaTextDateFormatSymbols *formatSymbols);

FOUNDATION_EXPORT void JavaTextSimpleDateFormat_initWithInt_withInt_withJavaUtilLocale_(JavaTextSimpleDateFormat *self, jint timeStyle, jint dateStyle, JavaUtilLocale *loc);

FOUNDATION_EXPORT JavaTextSimpleDateFormat *new_JavaTextSimpleDateFormat_initWithInt_withInt_withJavaUtilLocale_(jint timeStyle, jint dateStyle, JavaUtilLocale *loc) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaTextSimpleDateFormat *create_JavaTextSimpleDateFormat_initWithInt_withInt_withJavaUtilLocale_(jint timeStyle, jint dateStyle, JavaUtilLocale *loc);

J2OBJC_TYPE_LITERAL_HEADER(JavaTextSimpleDateFormat)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif
#pragma pop_macro("INCLUDE_ALL_JavaTextSimpleDateFormat")
