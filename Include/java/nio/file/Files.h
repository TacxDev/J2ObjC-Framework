//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/platform/libcore/ojluni/src/main/java/java/nio/file/Files.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_JavaNioFileFiles")
#ifdef RESTRICT_JavaNioFileFiles
#define INCLUDE_ALL_JavaNioFileFiles 0
#else
#define INCLUDE_ALL_JavaNioFileFiles 1
#endif
#undef RESTRICT_JavaNioFileFiles

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (JavaNioFileFiles_) && (INCLUDE_ALL_JavaNioFileFiles || defined(INCLUDE_JavaNioFileFiles))
#define JavaNioFileFiles_

@class IOSByteArray;
@class IOSClass;
@class IOSObjectArray;
@class JavaIoBufferedReader;
@class JavaIoBufferedWriter;
@class JavaIoInputStream;
@class JavaIoOutputStream;
@class JavaLangBoolean;
@class JavaLangInteger;
@class JavaLangLong;
@class JavaNioCharsetCharset;
@class JavaNioFileAttributeFileTime;
@class JavaNioFileFileStore;
@protocol JavaLangIterable;
@protocol JavaNioChannelsSeekableByteChannel;
@protocol JavaNioFileAttributeBasicFileAttributes;
@protocol JavaNioFileAttributeFileAttributeView;
@protocol JavaNioFileAttributeUserPrincipal;
@protocol JavaNioFileDirectoryStream;
@protocol JavaNioFileDirectoryStream_Filter;
@protocol JavaNioFileFileVisitor;
@protocol JavaNioFilePath;
@protocol JavaUtilFunctionBiPredicate;
@protocol JavaUtilList;
@protocol JavaUtilMap;
@protocol JavaUtilSet;
@protocol JavaUtilStreamStream;

/*!
 @brief This class consists exclusively of static methods that operate on files,
  directories, or other types of files.
 <p> In most cases, the methods defined here will delegate to the associated
  file system provider to perform the file operations.
 @since 1.7
 */
@interface JavaNioFileFiles : NSObject

#pragma mark Public

/*!
 @brief Copies all bytes from an input stream to a file.On return, the input
  stream will be at end of stream.
 <p> By default, the copy fails if the target file already exists or is a
  symbolic link. If the <code>REPLACE_EXISTING</code>
  option is specified, and the target file already exists,
  then it is replaced if it is not a non-empty directory. If the target
  file exists and is a symbolic link, then the symbolic link is replaced.
  In this release, the <code>REPLACE_EXISTING</code> option is the only option
  required to be supported by this method. Additional options may be
  supported in future releases. 
 <p>  If an I/O error occurs reading from the input stream or writing to
  the file, then it may do so after the target file has been created and
  after some bytes have been read or written. Consequently the input
  stream may not be at end of stream and may be in an inconsistent state.
  It is strongly recommended that the input stream be promptly closed if an
  I/O error occurs. 
 <p> This method may block indefinitely reading from the input stream (or
  writing to the file). The behavior for the case that the input stream is 
 <i>asynchronously closed</i> or the thread interrupted during the copy is
  highly input stream and file system provider specific and therefore not
  specified. 
 <p> <b>Usage example</b>: Suppose we want to capture a web page and save
  it to a file: 
 @code

      Path path = ...
      URI u = URI.create("http://java.sun.com/");
      try (InputStream in = u.toURL().openStream()) {
          Files.copy(in, path);
      } 
  
@endcode
 @param inArg the input stream to read from
 @param target the path to the file
 @param options options specifying how the copy should be done
 @return the number of bytes read or written
 @throw IOException
 if an I/O error occurs when reading or writing
 @throw FileAlreadyExistsException
 if the target file exists but cannot be replaced because the
           <code>REPLACE_EXISTING</code> option is not specified <i>(optional
           specific exception)</i>
 @throw DirectoryNotEmptyException
 the <code>REPLACE_EXISTING</code> option is specified but the file
           cannot be replaced because it is a non-empty directory          
 <i>(optional specific exception)</i>     *
 @throw UnsupportedOperationException
 if <code>options</code> contains a copy option that is not supported
 @throw SecurityException
 In the case of the default provider, and a security manager is
           installed, the <code>checkWrite</code>
           method is invoked to check write access to the file. Where the          
 <code>REPLACE_EXISTING</code> option is specified, the security
           manager's <code>checkDelete</code>
           method is invoked to check that an existing file can be deleted.
 */
+ (jlong)copy__WithJavaIoInputStream:(JavaIoInputStream *)inArg
                 withJavaNioFilePath:(id<JavaNioFilePath>)target
      withJavaNioFileCopyOptionArray:(IOSObjectArray *)options OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Copies all bytes from a file to an output stream.
 <p> If an I/O error occurs reading from the file or writing to the output
  stream, then it may do so after some bytes have been read or written.
  Consequently the output stream may be in an inconsistent state. It is
  strongly recommended that the output stream be promptly closed if an I/O
  error occurs. 
 <p> This method may block indefinitely writing to the output stream (or
  reading from the file). The behavior for the case that the output stream
  is <i>asynchronously closed</i> or the thread interrupted during the copy
  is highly output stream and file system provider specific and therefore
  not specified. 
 <p> Note that if the given output stream is <code>java.io.Flushable</code>
  then its <code>flush</code> method may need to invoked
  after this method completes so as to flush any buffered output.
 @param source the  path to the file
 @param outArg the output stream to write to
 @return the number of bytes read or written
 @throw IOException
 if an I/O error occurs when reading or writing
 @throw SecurityException
 In the case of the default provider, and a security manager is
           installed, the <code>checkRead</code>
           method is invoked to check read access to the file.
 */
+ (jlong)copy__WithJavaNioFilePath:(id<JavaNioFilePath>)source
            withJavaIoOutputStream:(JavaIoOutputStream *)outArg OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Copy a file to a target file.
 <p> This method copies a file to the target file with the <code>options</code>
  parameter specifying how the copy is performed. By default, the
  copy fails if the target file already exists or is a symbolic link,
  except if the source and target are the <code>same</code> file, in
  which case the method completes without copying the file. File attributes
  are not required to be copied to the target file. If symbolic links are
  supported, and the file is a symbolic link, then the final target of the
  link is copied. If the file is a directory then it creates an empty
  directory in the target location (entries in the directory are not
  copied). This method can be used with the <code>walkFileTree</code>
  method to copy a directory and all entries in the directory,
  or an entire <i>file-tree</i> where required. 
 <p> The <code>options</code> parameter may include any of the following: 
 <table border=1 cellpadding=5 summary="">
  <tr> <th>Option</th> <th>Description</th> </tr>
  <tr>
    <td> <code>REPLACE_EXISTING</code> </td>
    <td> If the target file exists, then the target file is replaced if it
      is not a non-empty directory. If the target file exists and is a
      symbolic link, then the symbolic link itself, not the target of
      the link, is replaced. </td>
  </tr>
  <tr>
    <td> <code>COPY_ATTRIBUTES</code> </td>
    <td> Attempts to copy the file attributes associated with this file to
      the target file. The exact file attributes that are copied is platform
      and file system dependent and therefore unspecified. Minimally, the     
 <code>last-modified-time</code> is
      copied to the target file if supported by both the source and target
      file stores. Copying of file timestamps may result in precision
      loss. </td>
  </tr>
  <tr>
    <td> <code>NOFOLLOW_LINKS</code> </td>
    <td> Symbolic links are not followed. If the file is a symbolic link,
      then the symbolic link itself, not the target of the link, is copied.
      It is implementation specific if file attributes can be copied to the
      new link. In other words, the <code>COPY_ATTRIBUTES</code> option may be
      ignored when copying a symbolic link. </td>
  </tr>
  </table>
  
 <p> An implementation of this interface may support additional
  implementation specific options. 
 <p> Copying a file is not an atomic operation. If an <code>IOException</code>
  is thrown, then it is possible that the target file is incomplete or some
  of its file attributes have not been copied from the source file. When the 
 <code>REPLACE_EXISTING</code> option is specified and the target file
  exists, then the target file is replaced. The check for the existence of
  the file and the creation of the new file may not be atomic with respect
  to other file system activities. 
 <p> <b>Usage Example:</b>
  Suppose we want to copy a file into a directory, giving it the same file
  name as the source file: 
 @code

      Path source = ...
      Path newdir = ...
      Files.copy(source, newdir.resolve(source.getFileName()); 
  
@endcode
 @param source the path to the file to copy
 @param target the path to the target file (may be associated with a different
            provider to the source path)
 @param options options specifying how the copy should be done
 @return the path to the target file
 @throw UnsupportedOperationException
 if the array contains a copy option that is not supported
 @throw FileAlreadyExistsException
 if the target file exists but cannot be replaced because the
           <code>REPLACE_EXISTING</code> option is not specified <i>(optional
           specific exception)</i>
 @throw DirectoryNotEmptyException
 the <code>REPLACE_EXISTING</code> option is specified but the file
           cannot be replaced because it is a non-empty directory          
 <i>(optional specific exception)</i>
 @throw IOException
 if an I/O error occurs
 @throw SecurityException
 In the case of the default provider, and a security manager is
           installed, the <code>checkRead</code>
           method is invoked to check read access to the source file, the          
 <code>checkWrite</code> is invoked
           to check write access to the target file. If a symbolic link is
           copied the security manager is invoked to check <code>LinkPermission</code>
 <code>("symbolic")</code>.
 */
+ (id<JavaNioFilePath>)copy__WithJavaNioFilePath:(id<JavaNioFilePath>)source
                             withJavaNioFilePath:(id<JavaNioFilePath>)target
                  withJavaNioFileCopyOptionArray:(IOSObjectArray *)options OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Creates a directory by creating all nonexistent parent directories first.
 Unlike the <code>createDirectory</code> method, an exception
  is not thrown if the directory could not be created because it already
  exists. 
 <p> The <code>attrs</code> parameter is optional <code>file-attributes</code>
  to set atomically when creating the nonexistent
  directories. Each file attribute is identified by its <code>name</code>
 . If more than one attribute of the same name is
  included in the array then all but the last occurrence is ignored. 
 <p> If this method fails, then it may do so after creating some, but not
  all, of the parent directories.
 @param dir the directory to create
 @param attrs an optional list of file attributes to set atomically when
            creating the directory
 @return the directory
 @throw UnsupportedOperationException
 if the array contains an attribute that cannot be set atomically
           when creating the directory
 @throw FileAlreadyExistsException
 if <code>dir</code> exists but is not a directory <i>(optional specific
           exception)</i>
 @throw IOException
 if an I/O error occurs
 @throw SecurityException
 in the case of the default provider, and a security manager is
           installed, the <code>checkWrite</code>
           method is invoked prior to attempting to create a directory and
           its <code>checkRead</code> is
           invoked for each parent directory that is checked. If <code>dir</code>
  is not an absolute path then its <code>toAbsolutePath</code>
  may need to be invoked to get its absolute path.
           This may invoke the security manager's <code>checkPropertyAccess</code>
           method to check access to the system property <code>user.dir</code>
 */
+ (id<JavaNioFilePath>)createDirectoriesWithJavaNioFilePath:(id<JavaNioFilePath>)dir
                 withJavaNioFileAttributeFileAttributeArray:(IOSObjectArray *)attrs;

/*!
 @brief Creates a new directory.The check for the existence of the file and the
  creation of the directory if it does not exist are a single operation
  that is atomic with respect to all other filesystem activities that might
  affect the directory.
 The <code>createDirectories</code>
  method should be used where it is required to create all nonexistent
  parent directories first. 
 <p> The <code>attrs</code> parameter is optional <code>file-attributes</code>
  to set atomically when creating the directory. Each
  attribute is identified by its <code>name</code>. If more
  than one attribute of the same name is included in the array then all but
  the last occurrence is ignored.
 @param dir the directory to create
 @param attrs an optional list of file attributes to set atomically when
            creating the directory
 @return the directory
 @throw UnsupportedOperationException
 if the array contains an attribute that cannot be set atomically
           when creating the directory
 @throw FileAlreadyExistsException
 if a directory could not otherwise be created because a file of
           that name already exists <i>(optional specific exception)</i>
 @throw IOException
 if an I/O error occurs or the parent directory does not exist
 @throw SecurityException
 In the case of the default provider, and a security manager is
           installed, the <code>checkWrite</code>
           method is invoked to check write access to the new directory.
 */
+ (id<JavaNioFilePath>)createDirectoryWithJavaNioFilePath:(id<JavaNioFilePath>)dir
               withJavaNioFileAttributeFileAttributeArray:(IOSObjectArray *)attrs;

/*!
 @brief Creates a new and empty file, failing if the file already exists.The
  check for the existence of the file and the creation of the new file if
  it does not exist are a single operation that is atomic with respect to
  all other filesystem activities that might affect the directory.
 <p> The <code>attrs</code> parameter is optional <code>file-attributes</code>
  to set atomically when creating the file. Each attribute
  is identified by its <code>name</code>. If more than one
  attribute of the same name is included in the array then all but the last
  occurrence is ignored.
 @param path the path to the file to create
 @param attrs an optional list of file attributes to set atomically when
            creating the file
 @return the file
 @throw UnsupportedOperationException
 if the array contains an attribute that cannot be set atomically
           when creating the file
 @throw FileAlreadyExistsException
 if a file of that name already exists
           <i>(optional specific exception)</i>
 @throw IOException
 if an I/O error occurs or the parent directory does not exist
 @throw SecurityException
 In the case of the default provider, and a security manager is
           installed, the <code>checkWrite</code>
           method is invoked to check write access to the new file.
 */
+ (id<JavaNioFilePath>)createFileWithJavaNioFilePath:(id<JavaNioFilePath>)path
          withJavaNioFileAttributeFileAttributeArray:(IOSObjectArray *)attrs;

/*!
 @brief Creates a new link (directory entry) for an existing file <i>(optional
  operation)</i>.
 <p> The <code>link</code> parameter locates the directory entry to create.
  The <code>existing</code> parameter is the path to an existing file. This
  method creates a new directory entry for the file so that it can be
  accessed using <code>link</code> as the path. On some file systems this is
  known as creating a "hard link". Whether the file attributes are
  maintained for the file or for each directory entry is file system
  specific and therefore not specified. Typically, a file system requires
  that all links (directory entries) for a file be on the same file system.
  Furthermore, on some platforms, the Java virtual machine may require to
  be started with implementation specific privileges to create hard links
  or to create links to directories.
 @param link the link (directory entry) to create
 @param existing a path to an existing file
 @return the path to the link (directory entry)
 @throw UnsupportedOperationException
 if the implementation does not support adding an existing file
           to a directory
 @throw FileAlreadyExistsException
 if the entry could not otherwise be created because a file of
           that name already exists <i>(optional specific exception)</i>
 @throw IOException
 if an I/O error occurs
 @throw SecurityException
 In the case of the default provider, and a security manager
           is installed, it denies <code>LinkPermission</code><tt>("hard")</tt>
           or its <code>checkWrite</code>
           method denies write access to either the link or the
           existing file.
 */
+ (id<JavaNioFilePath>)createLinkWithJavaNioFilePath:(id<JavaNioFilePath>)link
                                 withJavaNioFilePath:(id<JavaNioFilePath>)existing;

/*!
 @brief Creates a symbolic link to a target <i>(optional operation)</i>.
 <p> The <code>target</code> parameter is the target of the link. It may be an 
 <code>absolute</code> or relative path and may not exist. When
  the target is a relative path then file system operations on the resulting
  link are relative to the path of the link. 
 <p> The <code>attrs</code> parameter is optional <code>attributes</code>
  to set atomically when creating the link. Each attribute is
  identified by its <code>name</code>. If more than one attribute
  of the same name is included in the array then all but the last occurrence
  is ignored. 
 <p> Where symbolic links are supported, but the underlying <code>FileStore</code>
  does not support symbolic links, then this may fail with an <code>IOException</code>
 . Additionally, some operating systems may require that the
  Java virtual machine be started with implementation specific privileges to
  create symbolic links, in which case this method may throw <code>IOException</code>.
 @param link the path of the symbolic link to create
 @param target the target of the symbolic link
 @param attrs the array of attributes to set atomically when creating the
            symbolic link
 @return the path to the symbolic link
 @throw UnsupportedOperationException
 if the implementation does not support symbolic links or the
           array contains an attribute that cannot be set atomically when
           creating the symbolic link
 @throw FileAlreadyExistsException
 if a file with the name already exists <i>(optional specific
           exception)</i>
 @throw IOException
 if an I/O error occurs
 @throw SecurityException
 In the case of the default provider, and a security manager
           is installed, it denies <code>LinkPermission</code><tt>("symbolic")</tt>
           or its <code>checkWrite</code>
           method denies write access to the path of the symbolic link.
 */
+ (id<JavaNioFilePath>)createSymbolicLinkWithJavaNioFilePath:(id<JavaNioFilePath>)link
                                         withJavaNioFilePath:(id<JavaNioFilePath>)target
                  withJavaNioFileAttributeFileAttributeArray:(IOSObjectArray *)attrs;

/*!
 @brief Creates a new directory in the specified directory, using the given
  prefix to generate its name.The resulting <code>Path</code> is associated
  with the same <code>FileSystem</code> as the given directory.
 <p> The details as to how the name of the directory is constructed is
  implementation dependent and therefore not specified. Where possible
  the <code>prefix</code> is used to construct candidate names. 
 <p> As with the <code>createTempFile</code> methods, this method is only
  part of a temporary-file facility. A <code>shutdown-hook</code>
 , or the <code>java.io.File.deleteOnExit</code> mechanism may be
  used to delete the directory automatically. 
 <p> The <code>attrs</code> parameter is optional <code>file-attributes</code>
  to set atomically when creating the directory. Each
  attribute is identified by its <code>name</code>. If more
  than one attribute of the same name is included in the array then all but
  the last occurrence is ignored.
 @param dir the path to directory in which to create the directory
 @param prefix the prefix string to be used in generating the directory's name;
            may be 
 <code>null</code>
 @param attrs an optional list of file attributes to set atomically when
            creating the directory
 @return the path to the newly created directory that did not exist before
           this method was invoked
 @throw IllegalArgumentException
 if the prefix cannot be used to generate a candidate directory name
 @throw UnsupportedOperationException
 if the array contains an attribute that cannot be set atomically
           when creating the directory
 @throw IOException
 if an I/O error occurs or <code>dir</code> does not exist
 @throw SecurityException
 In the case of the default provider, and a security manager is
           installed, the <code>checkWrite</code>
           method is invoked to check write access when creating the
           directory.
 */
+ (id<JavaNioFilePath>)createTempDirectoryWithJavaNioFilePath:(id<JavaNioFilePath>)dir
                                                 withNSString:(NSString *)prefix
                   withJavaNioFileAttributeFileAttributeArray:(IOSObjectArray *)attrs;

/*!
 @brief Creates a new directory in the default temporary-file directory, using
  the given prefix to generate its name.The resulting <code>Path</code> is
  associated with the default <code>FileSystem</code>.
 <p> This method works in exactly the manner specified by <code>createTempDirectory(Path,String,FileAttribute[])</code>
  method for the case
  that the <code>dir</code> parameter is the temporary-file directory.
 @param prefix the prefix string to be used in generating the directory's name;
            may be 
 <code>null</code>
 @param attrs an optional list of file attributes to set atomically when
            creating the directory
 @return the path to the newly created directory that did not exist before
           this method was invoked
 @throw IllegalArgumentException
 if the prefix cannot be used to generate a candidate directory name
 @throw UnsupportedOperationException
 if the array contains an attribute that cannot be set atomically
           when creating the directory
 @throw IOException
 if an I/O error occurs or the temporary-file directory does not
           exist
 @throw SecurityException
 In the case of the default provider, and a security manager is
           installed, the <code>checkWrite</code>
           method is invoked to check write access when creating the
           directory.
 */
+ (id<JavaNioFilePath>)createTempDirectoryWithNSString:(NSString *)prefix
            withJavaNioFileAttributeFileAttributeArray:(IOSObjectArray *)attrs;

/*!
 @brief Creates a new empty file in the specified directory, using the given
  prefix and suffix strings to generate its name.The resulting 
 <code>Path</code> is associated with the same <code>FileSystem</code> as the given
  directory.
 <p> The details as to how the name of the file is constructed is
  implementation dependent and therefore not specified. Where possible
  the <code>prefix</code> and <code>suffix</code> are used to construct candidate
  names in the same manner as the <code>java.io.File.createTempFile(String,String,File)</code>
  method. 
 <p> As with the <code>File.createTempFile</code> methods, this method is only
  part of a temporary-file facility. Where used as a <em>work files</em>,
  the resulting file may be opened using the <code>DELETE_ON_CLOSE</code>
  option so that the
  file is deleted when the appropriate <code>close</code> method is invoked.
  Alternatively, a <code>shutdown-hook</code>, or the 
 <code>java.io.File.deleteOnExit</code> mechanism may be used to delete the
  file automatically. 
 <p> The <code>attrs</code> parameter is optional <code>file-attributes</code>
  to set atomically when creating the file. Each attribute
  is identified by its <code>name</code>. If more than one
  attribute of the same name is included in the array then all but the last
  occurrence is ignored. When no file attributes are specified, then the
  resulting file may have more restrictive access permissions to files
  created by the <code>java.io.File.createTempFile(String,String,File)</code>
  method.
 @param dir the path to directory in which to create the file
 @param prefix the prefix string to be used in generating the file's name;
            may be 
 <code>null</code>
 @param suffix the suffix string to be used in generating the file's name;
            may be 
 <code>null</code> , in which case "<code>.tmp</code> " is used
 @param attrs an optional list of file attributes to set atomically when
            creating the file
 @return the path to the newly created file that did not exist before
           this method was invoked
 @throw IllegalArgumentException
 if the prefix or suffix parameters cannot be used to generate
           a candidate file name
 @throw UnsupportedOperationException
 if the array contains an attribute that cannot be set atomically
           when creating the directory
 @throw IOException
 if an I/O error occurs or <code>dir</code> does not exist
 @throw SecurityException
 In the case of the default provider, and a security manager is
           installed, the <code>checkWrite</code>
           method is invoked to check write access to the file.
 */
+ (id<JavaNioFilePath>)createTempFileWithJavaNioFilePath:(id<JavaNioFilePath>)dir
                                            withNSString:(NSString *)prefix
                                            withNSString:(NSString *)suffix
              withJavaNioFileAttributeFileAttributeArray:(IOSObjectArray *)attrs;

/*!
 @brief Creates an empty file in the default temporary-file directory, using
  the given prefix and suffix to generate its name.The resulting <code>Path</code>
  is associated with the default <code>FileSystem</code>.
 <p> This method works in exactly the manner specified by the 
 <code>createTempFile(Path,String,String,FileAttribute[])</code> method for
  the case that the <code>dir</code> parameter is the temporary-file directory.
 @param prefix the prefix string to be used in generating the file's name;
            may be 
 <code>null</code>
 @param suffix the suffix string to be used in generating the file's name;
            may be 
 <code>null</code> , in which case "<code>.tmp</code> " is used
 @param attrs an optional list of file attributes to set atomically when
            creating the file
 @return the path to the newly created file that did not exist before
           this method was invoked
 @throw IllegalArgumentException
 if the prefix or suffix parameters cannot be used to generate
           a candidate file name
 @throw UnsupportedOperationException
 if the array contains an attribute that cannot be set atomically
           when creating the directory
 @throw IOException
 if an I/O error occurs or the temporary-file directory does not
           exist
 @throw SecurityException
 In the case of the default provider, and a security manager is
           installed, the <code>checkWrite</code>
           method is invoked to check write access to the file.
 */
+ (id<JavaNioFilePath>)createTempFileWithNSString:(NSString *)prefix
                                     withNSString:(NSString *)suffix
       withJavaNioFileAttributeFileAttributeArray:(IOSObjectArray *)attrs;

/*!
 @brief Deletes a file.
 <p> An implementation may require to examine the file to determine if the
  file is a directory. Consequently this method may not be atomic with respect
  to other file system operations.  If the file is a symbolic link then the
  symbolic link itself, not the final target of the link, is deleted. 
 <p> If the file is a directory then the directory must be empty. In some
  implementations a directory has entries for special files or links that
  are created when the directory is created. In such implementations a
  directory is considered empty when only the special entries exist.
  This method can be used with the <code>walkFileTree</code>
  method to delete a directory and all entries in the directory, or an
  entire <i>file-tree</i> where required. 
 <p> On some operating systems it may not be possible to remove a file when
  it is open and in use by this Java virtual machine or other programs.
 @param path the path to the file to delete
 @throw NoSuchFileException
 if the file does not exist <i>(optional specific exception)</i>
 @throw DirectoryNotEmptyException
 if the file is a directory and could not otherwise be deleted
           because the directory is not empty <i>(optional specific
           exception)</i>
 @throw IOException
 if an I/O error occurs
 @throw SecurityException
 In the case of the default provider, and a security manager is
           installed, the <code>SecurityManager.checkDelete(String)</code> method
           is invoked to check delete access to the file
 */
+ (void)delete__WithJavaNioFilePath:(id<JavaNioFilePath>)path;

/*!
 @brief Deletes a file if it exists.
 <p> As with the <code>delete(Path)</code> method, an
  implementation may need to examine the file to determine if the file is a
  directory. Consequently this method may not be atomic with respect to
  other file system operations.  If the file is a symbolic link, then the
  symbolic link itself, not the final target of the link, is deleted. 
 <p> If the file is a directory then the directory must be empty. In some
  implementations a directory has entries for special files or links that
  are created when the directory is created. In such implementations a
  directory is considered empty when only the special entries exist. 
 <p> On some operating systems it may not be possible to remove a file when
  it is open and in use by this Java virtual machine or other programs.
 @param path the path to the file to delete
 @return <code>true</code> if the file was deleted by this method; <code>false</code>
  if the file could not be deleted because it did not
           exist
 @throw DirectoryNotEmptyException
 if the file is a directory and could not otherwise be deleted
           because the directory is not empty <i>(optional specific
           exception)</i>
 @throw IOException
 if an I/O error occurs
 @throw SecurityException
 In the case of the default provider, and a security manager is
           installed, the <code>SecurityManager.checkDelete(String)</code> method
           is invoked to check delete access to the file.
 */
+ (jboolean)deleteIfExistsWithJavaNioFilePath:(id<JavaNioFilePath>)path;

/*!
 @brief Tests whether a file exists.
 <p> The <code>options</code> parameter may be used to indicate how symbolic links
  are handled for the case that the file is a symbolic link. By default,
  symbolic links are followed. If the option <code>NOFOLLOW_LINKS</code>
  is present then symbolic links are not followed. 
 <p> Note that the result of this method is immediately outdated. If this
  method indicates the file exists then there is no guarantee that a
  subsequence access will succeed. Care should be taken when using this
  method in security sensitive applications.
 @param path the path to the file to test
 @param options options indicating how symbolic links are handled
   .
 @return <code>true</code> if the file exists; <code>false</code> if the file does
           not exist or its existence cannot be determined.
 @throw SecurityException
 In the case of the default provider, the <code>SecurityManager.checkRead(String)</code>
  is invoked to check
           read access to the file.
 - seealso: #notExists
 */
+ (jboolean)existsWithJavaNioFilePath:(id<JavaNioFilePath>)path
       withJavaNioFileLinkOptionArray:(IOSObjectArray *)options;

/*!
 @brief Return a <code>Stream</code> that is lazily populated with <code>Path</code>
  by searching for files in a file tree rooted at a given starting
  file.
 <p> This method walks the file tree in exactly the manner specified by the 
 <code>walk</code> method. For each file encountered, the given 
 <code>BiPredicate</code> is invoked with its <code>Path</code> and <code>BasicFileAttributes</code>
 . The <code>Path</code> object is obtained as if by 
 <code>resolving</code> the relative path against <code>start</code>
  and is only included in the returned <code>Stream</code> if
  the <code>BiPredicate</code> returns true. Compare to calling <code>filter</code>
  on the <code>Stream</code>
  returned by <code>walk</code> method, this method may be more efficient by
  avoiding redundant retrieval of the <code>BasicFileAttributes</code>.
  
 <p> The returned stream encapsulates one or more <code>DirectoryStream</code>s.
  If timely disposal of file system resources is required, the 
 <code>try</code>-with-resources construct should be used to ensure that the
  stream's <code>close</code> method is invoked after the stream
  operations are completed.  Operating on a closed stream will result in an 
 <code>java.lang.IllegalStateException</code>.
  
 <p> If an <code>IOException</code> is thrown when accessing the directory
  after returned from this method, it is wrapped in an <code>UncheckedIOException</code>
  which will be thrown from the method that caused
  the access to take place.
 @param start the starting file
 @param maxDepth the maximum number of directory levels to search
 @param matcher the function used to decide whether a file should be included
            in the returned stream
 @param options options to configure the traversal
 @return the <code>Stream</code> of <code>Path</code>
 @throw IllegalArgumentException
 if the <code>maxDepth</code> parameter is negative
 @throw SecurityException
 If the security manager denies access to the starting file.
           In the case of the default provider, the <code>checkRead</code>
  method is invoked
           to check read access to the directory.
 @throw IOException
 if an I/O error is thrown when accessing the starting file.
 - seealso: #walk(Path, int, FileVisitOption...)
 @since 1.8
 */
+ (id<JavaUtilStreamStream>)findWithJavaNioFilePath:(id<JavaNioFilePath>)start
                                            withInt:(jint)maxDepth
                    withJavaUtilFunctionBiPredicate:(id<JavaUtilFunctionBiPredicate>)matcher
                withJavaNioFileFileVisitOptionArray:(IOSObjectArray *)options;

/*!
 @brief Reads the value of a file attribute.
 <p> The <code>attribute</code> parameter identifies the attribute to be read
  and takes the form: 
 <blockquote>
  [<i>view-name</i><b>:</b>]<i>attribute-name</i>
  </blockquote>
  where square brackets [...] delineate an optional component and the
  character <code>':'</code> stands for itself. 
 <p> <i>view-name</i> is the <code>name</code> of a <code>FileAttributeView</code>
  that identifies a set of file attributes. If not
  specified then it defaults to <code>"basic"</code>, the name of the file
  attribute view that identifies the basic set of file attributes common to
  many file systems. <i>attribute-name</i> is the name of the attribute. 
 <p> The <code>options</code> array may be used to indicate how symbolic links
  are handled for the case that the file is a symbolic link. By default,
  symbolic links are followed and the file attribute of the final target
  of the link is read. If the option <code>NOFOLLOW_LINKS</code>
  is present then symbolic links are not followed. 
 <p> <b>Usage Example:</b>
  Suppose we require the user ID of the file owner on a system that
  supports a "<code>unix</code>" view: 
 @code

     Path path = ...
     int uid = (Integer)Files.getAttribute(path, "unix:uid"); 
  
@endcode
 @param path the path to the file
 @param attribute the attribute to read
 @param options options indicating how symbolic links are handled
 @return the attribute value
 @throw UnsupportedOperationException
 if the attribute view is not available
 @throw IllegalArgumentException
 if the attribute name is not specified or is not recognized
 @throw IOException
 if an I/O error occurs
 @throw SecurityException
 In the case of the default provider, and a security manager is
           installed, its <code>checkRead</code>
           method denies read access to the file. If this method is invoked
           to read security sensitive attributes then the security manager
           may be invoked to check for additional permissions.
 */
+ (id)getAttributeWithJavaNioFilePath:(id<JavaNioFilePath>)path
                         withNSString:(NSString *)attribute
       withJavaNioFileLinkOptionArray:(IOSObjectArray *)options;

/*!
 @brief Returns a file attribute view of a given type.
 <p> A file attribute view provides a read-only or updatable view of a
  set of file attributes. This method is intended to be used where the file
  attribute view defines type-safe methods to read or update the file
  attributes. The <code>type</code> parameter is the type of the attribute view
  required and the method returns an instance of that type if supported.
  The <code>BasicFileAttributeView</code> type supports access to the basic
  attributes of a file. Invoking this method to select a file attribute
  view of that type will always return an instance of that class. 
 <p> The <code>options</code> array may be used to indicate how symbolic links
  are handled by the resulting file attribute view for the case that the
  file is a symbolic link. By default, symbolic links are followed. If the
  option <code>NOFOLLOW_LINKS</code> is present then
  symbolic links are not followed. This option is ignored by implementations
  that do not support symbolic links. 
 <p> <b>Usage Example:</b>
  Suppose we want read or set a file's ACL, if supported: 
 @code

      Path path = ...
      AclFileAttributeView view = Files.getFileAttributeView(path, AclFileAttributeView.class);
      if (view != null) {
          List&lt;AclEntry&gt; acl = view.getAcl();
          :
      } 
  
@endcode
 @param path the path to the file
 @param type the 
 <code>Class</code>  object corresponding to the file attribute view
 @param options options indicating how symbolic links are handled
 @return a file attribute view of the specified type, or <code>null</code> if
           the attribute view type is not available
 */
+ (id<JavaNioFileAttributeFileAttributeView>)getFileAttributeViewWithJavaNioFilePath:(id<JavaNioFilePath>)path
                                                                        withIOSClass:(IOSClass *)type
                                                      withJavaNioFileLinkOptionArray:(IOSObjectArray *)options;

/*!
 @brief Returns the <code>FileStore</code> representing the file store where a file
  is located.
 <p> Once a reference to the <code>FileStore</code> is obtained it is
  implementation specific if operations on the returned <code>FileStore</code>,
  or <code>FileStoreAttributeView</code> objects obtained from it, continue
  to depend on the existence of the file. In particular the behavior is not
  defined for the case that the file is deleted or moved to a different
  file store.
 @param path the path to the file
 @return the file store where the file is stored
 @throw IOException
 if an I/O error occurs
 @throw SecurityException
 In the case of the default provider, and a security manager is
           installed, the <code>checkRead</code>
           method is invoked to check read access to the file, and in
           addition it checks <code>RuntimePermission</code><tt>
           ("getFileStoreAttributes")</tt>
 */
+ (JavaNioFileFileStore *)getFileStoreWithJavaNioFilePath:(id<JavaNioFilePath>)path;

/*!
 @brief Returns a file's last modified time.
 <p> The <code>options</code> array may be used to indicate how symbolic links
  are handled for the case that the file is a symbolic link. By default,
  symbolic links are followed and the file attribute of the final target
  of the link is read. If the option <code>NOFOLLOW_LINKS</code>
  is present then symbolic links are not followed.
 @param path the path to the file
 @param options options indicating how symbolic links are handled
 @return a <code>FileTime</code> representing the time the file was last
           modified, or an implementation specific default when a time
           stamp to indicate the time of last modification is not supported
           by the file system
 @throw IOException
 if an I/O error occurs
 @throw SecurityException
 In the case of the default provider, and a security manager is
           installed, its <code>checkRead</code>
           method denies read access to the file.
 - seealso: BasicFileAttributes#lastModifiedTime
 */
+ (JavaNioFileAttributeFileTime *)getLastModifiedTimeWithJavaNioFilePath:(id<JavaNioFilePath>)path
                                          withJavaNioFileLinkOptionArray:(IOSObjectArray *)options;

/*!
 @brief Returns the owner of a file.
 <p> The <code>path</code> parameter is associated with a file system that
  supports <code>FileOwnerAttributeView</code>. This file attribute view provides
  access to a file attribute that is the owner of the file.
 @param path The path to the file
 @param options options indicating how symbolic links are handled
 @return A user principal representing the owner of the file
 @throw UnsupportedOperationException
 if the associated file system does not support the <code>FileOwnerAttributeView</code>
 @throw IOException
 if an I/O error occurs
 @throw SecurityException
 In the case of the default provider, and a security manager is
           installed, it denies <code>RuntimePermission</code><tt>("accessUserInformation")</tt>
           or its <code>checkRead</code> method
           denies read access to the file.
 */
+ (id<JavaNioFileAttributeUserPrincipal>)getOwnerWithJavaNioFilePath:(id<JavaNioFilePath>)path
                                      withJavaNioFileLinkOptionArray:(IOSObjectArray *)options;

/*!
 @brief Returns a file's POSIX file permissions.
 <p> The <code>path</code> parameter is associated with a <code>FileSystem</code>
  that supports the <code>PosixFileAttributeView</code>. This attribute view
  provides access to file attributes commonly associated with files on file
  systems used by operating systems that implement the Portable Operating
  System Interface (POSIX) family of standards. 
 <p> The <code>options</code> array may be used to indicate how symbolic links
  are handled for the case that the file is a symbolic link. By default,
  symbolic links are followed and the file attribute of the final target
  of the link is read. If the option <code>NOFOLLOW_LINKS</code>
  is present then symbolic links are not followed.
 @param path the path to the file
 @param options options indicating how symbolic links are handled
 @return the file permissions
 @throw UnsupportedOperationException
 if the associated file system does not support the <code>PosixFileAttributeView</code>
 @throw IOException
 if an I/O error occurs
 @throw SecurityException
 In the case of the default provider, a security manager is
           installed, and it denies <code>RuntimePermission</code><tt>("accessUserInformation")</tt>
           or its <code>checkRead</code> method
           denies read access to the file.
 */
+ (id<JavaUtilSet>)getPosixFilePermissionsWithJavaNioFilePath:(id<JavaNioFilePath>)path
                               withJavaNioFileLinkOptionArray:(IOSObjectArray *)options;

/*!
 @brief Tests whether a file is a directory.
 <p> The <code>options</code> array may be used to indicate how symbolic links
  are handled for the case that the file is a symbolic link. By default,
  symbolic links are followed and the file attribute of the final target
  of the link is read. If the option <code>NOFOLLOW_LINKS</code>
  is present then symbolic links are not followed. 
 <p> Where it is required to distinguish an I/O exception from the case
  that the file is not a directory then the file attributes can be
  read with the <code>readAttributes</code>
  method and the file type tested with the <code>BasicFileAttributes.isDirectory</code>
  method.
 @param path the path to the file to test
 @param options options indicating how symbolic links are handled
 @return <code>true</code> if the file is a directory; <code>false</code> if
           the file does not exist, is not a directory, or it cannot
           be determined if the file is a directory or not.
 @throw SecurityException
 In the case of the default provider, and a security manager is
           installed, its <code>checkRead</code>
           method denies read access to the file.
 */
+ (jboolean)isDirectoryWithJavaNioFilePath:(id<JavaNioFilePath>)path
            withJavaNioFileLinkOptionArray:(IOSObjectArray *)options;

/*!
 @brief Tests whether a file is executable.This method checks that a file exists
  and that this Java virtual machine has appropriate privileges to <code>execute</code>
  the file.
 The semantics may differ when checking
  access to a directory. For example, on UNIX systems, checking for
  execute access checks that the Java virtual machine has permission to
  search the directory in order to access file or subdirectories. 
 <p> Depending on the implementation, this method may require to read file
  permissions, access control lists, or other file attributes in order to
  check the effective access to the file. Consequently, this method may not
  be atomic with respect to other file system operations. 
 <p> Note that the result of this method is immediately outdated, there is
  no guarantee that a subsequent attempt to execute the file will succeed
  (or even that it will access the same file). Care should be taken when
  using this method in security sensitive applications.
 @param path the path to the file to check
 @return <code>true</code> if the file exists and is executable; <code>false</code>
           if the file does not exist, execute access would be denied because
           the Java virtual machine has insufficient privileges, or access
           cannot be determined
 @throw SecurityException
 In the case of the default provider, and a security manager is
           installed, the <code>checkExec</code>
  is invoked to check execute access to the file.
 */
+ (jboolean)isExecutableWithJavaNioFilePath:(id<JavaNioFilePath>)path;

/*!
 @brief Tells whether or not a file is considered <em>hidden</em>.The exact
  definition of hidden is platform or provider dependent.
 On UNIX for
  example a file is considered to be hidden if its name begins with a
  period character ('.'). On Windows a file is considered hidden if it
  isn't a directory and the DOS <code>hidden</code>
  attribute is set. 
 <p> Depending on the implementation this method may require to access
  the file system to determine if the file is considered hidden.
 @param path the path to the file to test
 @return <code>true</code> if the file is considered hidden
 @throw IOException
 if an I/O error occurs
 @throw SecurityException
 In the case of the default provider, and a security manager is
           installed, the <code>checkRead</code>
           method is invoked to check read access to the file.
 */
+ (jboolean)isHiddenWithJavaNioFilePath:(id<JavaNioFilePath>)path;

/*!
 @brief Tests whether a file is readable.This method checks that a file exists
  and that this Java virtual machine has appropriate privileges that would
  allow it open the file for reading.
 Depending on the implementation, this
  method may require to read file permissions, access control lists, or
  other file attributes in order to check the effective access to the file.
  Consequently, this method may not be atomic with respect to other file
  system operations. 
 <p> Note that the result of this method is immediately outdated, there is
  no guarantee that a subsequent attempt to open the file for reading will
  succeed (or even that it will access the same file). Care should be taken
  when using this method in security sensitive applications.
 @param path the path to the file to check
 @return <code>true</code> if the file exists and is readable; <code>false</code>
           if the file does not exist, read access would be denied because
           the Java virtual machine has insufficient privileges, or access
           cannot be determined
 @throw SecurityException
 In the case of the default provider, and a security manager is
           installed, the <code>checkRead</code>
           is invoked to check read access to the file.
 */
+ (jboolean)isReadableWithJavaNioFilePath:(id<JavaNioFilePath>)path;

/*!
 @brief Tests whether a file is a regular file with opaque content.
 <p> The <code>options</code> array may be used to indicate how symbolic links
  are handled for the case that the file is a symbolic link. By default,
  symbolic links are followed and the file attribute of the final target
  of the link is read. If the option <code>NOFOLLOW_LINKS</code>
  is present then symbolic links are not followed. 
 <p> Where it is required to distinguish an I/O exception from the case
  that the file is not a regular file then the file attributes can be
  read with the <code>readAttributes</code>
  method and the file type tested with the <code>BasicFileAttributes.isRegularFile</code>
  method.
 @param path the path to the file
 @param options options indicating how symbolic links are handled
 @return <code>true</code> if the file is a regular file; <code>false</code> if
           the file does not exist, is not a regular file, or it
           cannot be determined if the file is a regular file or not.
 @throw SecurityException
 In the case of the default provider, and a security manager is
           installed, its <code>checkRead</code>
           method denies read access to the file.
 */
+ (jboolean)isRegularFileWithJavaNioFilePath:(id<JavaNioFilePath>)path
              withJavaNioFileLinkOptionArray:(IOSObjectArray *)options;

/*!
 @brief Tests if two paths locate the same file.
 <p> If both <code>Path</code> objects are <code>equal</code>
  then this method returns <code>true</code> without checking if the file exists.
  If the two <code>Path</code> objects are associated with different providers
  then this method returns <code>false</code>. Otherwise, this method checks if
  both <code>Path</code> objects locate the same file, and depending on the
  implementation, may require to open or access both files. 
 <p> If the file system and files remain static, then this method implements
  an equivalence relation for non-null <code>Paths</code>.
  <ul>
  <li>It is <i>reflexive</i>: for <code>Path</code> <code>f</code>,
      <code>isSameFile(f,f)</code> should return <code>true</code>.
  <li>It is <i>symmetric</i>: for two <code>Paths</code> <code>f</code> and <code>g</code>,
      <code>isSameFile(f,g)</code> will equal <code>isSameFile(g,f)</code>.
  <li>It is <i>transitive</i>: for three <code>Paths</code>
      <code>f</code>, <code>g</code>, and <code>h</code>, if <code>isSameFile(f,g)</code> returns
      <code>true</code> and <code>isSameFile(g,h)</code> returns <code>true</code>, then
      <code>isSameFile(f,h)</code> will return return <code>true</code>.
  </ul>
 @param path one path to the file
 @param path2 the other path
 @return <code>true</code> if, and only if, the two paths locate the same file
 @throw IOException
 if an I/O error occurs
 @throw SecurityException
 In the case of the default provider, and a security manager is
           installed, the <code>checkRead</code>
           method is invoked to check read access to both files.
 - seealso: java.nio.file.attribute.BasicFileAttributes#fileKey
 */
+ (jboolean)isSameFileWithJavaNioFilePath:(id<JavaNioFilePath>)path
                      withJavaNioFilePath:(id<JavaNioFilePath>)path2;

/*!
 @brief Tests whether a file is a symbolic link.
 <p> Where it is required to distinguish an I/O exception from the case
  that the file is not a symbolic link then the file attributes can be
  read with the <code>readAttributes</code>
  method and the file type tested with the <code>BasicFileAttributes.isSymbolicLink</code>
  method.
 @param path The path to the file
 @return <code>true</code> if the file is a symbolic link; <code>false</code> if
           the file does not exist, is not a symbolic link, or it cannot
           be determined if the file is a symbolic link or not.
 @throw SecurityException
 In the case of the default provider, and a security manager is
           installed, its <code>checkRead</code>
           method denies read access to the file.
 */
+ (jboolean)isSymbolicLinkWithJavaNioFilePath:(id<JavaNioFilePath>)path;

/*!
 @brief Tests whether a file is writable.This method checks that a file exists
  and that this Java virtual machine has appropriate privileges that would
  allow it open the file for writing.
 Depending on the implementation, this
  method may require to read file permissions, access control lists, or
  other file attributes in order to check the effective access to the file.
  Consequently, this method may not be atomic with respect to other file
  system operations. 
 <p> Note that result of this method is immediately outdated, there is no
  guarantee that a subsequent attempt to open the file for writing will
  succeed (or even that it will access the same file). Care should be taken
  when using this method in security sensitive applications.
 @param path the path to the file to check
 @return <code>true</code> if the file exists and is writable; <code>false</code>
           if the file does not exist, write access would be denied because
           the Java virtual machine has insufficient privileges, or access
           cannot be determined
 @throw SecurityException
 In the case of the default provider, and a security manager is
           installed, the <code>checkWrite</code>
           is invoked to check write access to the file.
 */
+ (jboolean)isWritableWithJavaNioFilePath:(id<JavaNioFilePath>)path;

/*!
 @brief Read all lines from a file as a <code>Stream</code>.Bytes from the file are
  decoded into characters using the <code>UTF-8</code>
  <code>charset</code>.
 <p> This method works as if invoking it were equivalent to evaluating the
  expression: 
 @code
 Files.lines(path, StandardCharsets.UTF_8) 
 
@endcode
 @param path the path to the file
 @return the lines from the file as a <code>Stream</code>
 @throw IOException
 if an I/O error occurs opening the file
 @throw SecurityException
 In the case of the default provider, and a security manager is
           installed, the <code>checkRead</code>
           method is invoked to check read access to the file.
 @since 1.8
 */
+ (id<JavaUtilStreamStream>)linesWithJavaNioFilePath:(id<JavaNioFilePath>)path;

/*!
 @brief Read all lines from a file as a <code>Stream</code>.Unlike <code>readAllLines</code>
 , this method does not read
  all lines into a <code>List</code>, but instead populates lazily as the stream
  is consumed.
 <p> Bytes from the file are decoded into characters using the specified
  charset and the same line terminators as specified by <code>readAllLines</code>
  are supported. 
 <p> After this method returns, then any subsequent I/O exception that
  occurs while reading from the file or when a malformed or unmappable byte
  sequence is read, is wrapped in an <code>UncheckedIOException</code> that will
  be thrown from the 
 <code>java.util.stream.Stream</code> method that caused the read to take
  place. In case an <code>IOException</code> is thrown when closing the file,
  it is also wrapped as an <code>UncheckedIOException</code>.
  
 <p> The returned stream encapsulates a <code>Reader</code>.  If timely
  disposal of file system resources is required, the try-with-resources
  construct should be used to ensure that the stream's 
 <code>close</code> method is invoked after the stream operations
  are completed.
 @param path the path to the file
 @param cs the charset to use for decoding
 @return the lines from the file as a <code>Stream</code>
 @throw IOException
 if an I/O error occurs opening the file
 @throw SecurityException
 In the case of the default provider, and a security manager is
           installed, the <code>checkRead</code>
           method is invoked to check read access to the file.
 - seealso: #readAllLines(Path, Charset)
 - seealso: #newBufferedReader(Path, Charset)
 - seealso: java.io.BufferedReader#lines()
 @since 1.8
 */
+ (id<JavaUtilStreamStream>)linesWithJavaNioFilePath:(id<JavaNioFilePath>)path
                           withJavaNioCharsetCharset:(JavaNioCharsetCharset *)cs;

/*!
 @brief Return a lazily populated <code>Stream</code>, the elements of
  which are the entries in the directory.The listing is not recursive.
 <p> The elements of the stream are <code>Path</code> objects that are
  obtained as if by <code>resolving</code> the name of the
  directory entry against <code>dir</code>. Some file systems maintain special
  links to the directory itself and the directory's parent directory.
  Entries representing these links are not included. 
 <p> The stream is <i>weakly consistent</i>. It is thread safe but does
  not freeze the directory while iterating, so it may (or may not)
  reflect updates to the directory that occur after returning from this
  method. 
 <p> The returned stream encapsulates a <code>DirectoryStream</code>.
  If timely disposal of file system resources is required, the 
 <code>try</code>-with-resources construct should be used to ensure that the
  stream's <code>close</code> method is invoked after the stream
  operations are completed. 
 <p> Operating on a closed stream behaves as if the end of stream
  has been reached. Due to read-ahead, one or more elements may be
  returned after the stream has been closed. 
 <p> If an <code>IOException</code> is thrown when accessing the directory
  after this method has returned, it is wrapped in an <code>UncheckedIOException</code>
  which will be thrown from the method that caused
  the access to take place.
 @param dir The path to the directory
 @return The <code>Stream</code> describing the content of the
           directory
 @throw NotDirectoryException
 if the file could not otherwise be opened because it is not
           a directory <i>(optional specific exception)</i>
 @throw IOException
 if an I/O error occurs when opening the directory
 @throw SecurityException
 In the case of the default provider, and a security manager is
           installed, the <code>checkRead</code>
           method is invoked to check read access to the directory.
 - seealso: #newDirectoryStream(Path)
 @since 1.8
 */
+ (id<JavaUtilStreamStream>)listWithJavaNioFilePath:(id<JavaNioFilePath>)dir;

/*!
 @brief Move or rename a file to a target file.
 <p> By default, this method attempts to move the file to the target
  file, failing if the target file exists except if the source and
  target are the <code>same</code> file, in which case this method
  has no effect. If the file is a symbolic link then the symbolic link
  itself, not the target of the link, is moved. This method may be
  invoked to move an empty directory. In some implementations a directory
  has entries for special files or links that are created when the
  directory is created. In such implementations a directory is considered
  empty when only the special entries exist. When invoked to move a
  directory that is not empty then the directory is moved if it does not
  require moving the entries in the directory.  For example, renaming a
  directory on the same <code>FileStore</code> will usually not require moving
  the entries in the directory. When moving a directory requires that its
  entries be moved then this method fails (by throwing an <code>IOException</code>
 ). To move a <i>file tree</i> may involve copying rather
  than moving directories and this can be done using the <code>copy</code>
  method in conjunction with the <code>Files.walkFileTree</code>
  utility method. 
 <p> The <code>options</code> parameter may include any of the following: 
 <table border=1 cellpadding=5 summary="">
  <tr> <th>Option</th> <th>Description</th> </tr>
  <tr>
    <td> <code>REPLACE_EXISTING</code> </td>
    <td> If the target file exists, then the target file is replaced if it
      is not a non-empty directory. If the target file exists and is a
      symbolic link, then the symbolic link itself, not the target of
      the link, is replaced. </td>
  </tr>
  <tr>
    <td> <code>ATOMIC_MOVE</code> </td>
    <td> The move is performed as an atomic file system operation and all
      other options are ignored. If the target file exists then it is
      implementation specific if the existing file is replaced or this method
      fails by throwing an <code>IOException</code>. If the move cannot be
      performed as an atomic file system operation then <code>AtomicMoveNotSupportedException</code>
  is thrown. This can arise, for
      example, when the target location is on a different <code>FileStore</code>
      and would require that the file be copied, or target location is
      associated with a different provider to this object. </td>
  </table>
  
 <p> An implementation of this interface may support additional
  implementation specific options. 
 <p> Moving a file will copy the <code>last-modified-time</code>
  to the target
  file if supported by both source and target file stores. Copying of file
  timestamps may result in precision loss. An implementation may also
  attempt to copy other file attributes but is not required to fail if the
  file attributes cannot be copied. When the move is performed as
  a non-atomic operation, and an <code>IOException</code> is thrown, then the
  state of the files is not defined. The original file and the target file
  may both exist, the target file may be incomplete or some of its file
  attributes may not been copied from the original file. 
 <p> <b>Usage Examples:</b>
  Suppose we want to rename a file to "newname", keeping the file in the
  same directory: 
 @code

      Path source = ...
      Files.move(source, source.resolveSibling("newname")); 
  
@endcode
  Alternatively, suppose we want to move a file to new directory, keeping
  the same file name, and replacing any existing file of that name in the
  directory: 
 @code

      Path source = ...
      Path newdir = ...
      Files.move(source, newdir.resolve(source.getFileName()), REPLACE_EXISTING); 
  
@endcode
 @param source the path to the file to move
 @param target the path to the target file (may be associated with a different
            provider to the source path)
 @param options options specifying how the move should be done
 @return the path to the target file
 @throw UnsupportedOperationException
 if the array contains a copy option that is not supported
 @throw FileAlreadyExistsException
 if the target file exists but cannot be replaced because the
           <code>REPLACE_EXISTING</code> option is not specified <i>(optional
           specific exception)</i>
 @throw DirectoryNotEmptyException
 the <code>REPLACE_EXISTING</code> option is specified but the file
           cannot be replaced because it is a non-empty directory          
 <i>(optional specific exception)</i>
 @throw AtomicMoveNotSupportedException
 if the options array contains the <code>ATOMIC_MOVE</code> option but
           the file cannot be moved as an atomic file system operation.
 @throw IOException
 if an I/O error occurs
 @throw SecurityException
 In the case of the default provider, and a security manager is
           installed, the <code>checkWrite</code>
           method is invoked to check write access to both the source and
           target file.
 */
+ (id<JavaNioFilePath>)moveWithJavaNioFilePath:(id<JavaNioFilePath>)source
                           withJavaNioFilePath:(id<JavaNioFilePath>)target
                withJavaNioFileCopyOptionArray:(IOSObjectArray *)options;

/*!
 @brief Opens a file for reading, returning a <code>BufferedReader</code> to read text
  from the file in an efficient manner.Bytes from the file are decoded into
  characters using the <code>UTF-8</code> <code>charset</code>
 .
 <p> This method works as if invoking it were equivalent to evaluating the
  expression: 
 @code
 Files.newBufferedReader(path, StandardCharsets.UTF_8) 
 
@endcode
 @param path the path to the file
 @return a new buffered reader, with default buffer size, to read text
           from the file
 @throw IOException
 if an I/O error occurs opening the file
 @throw SecurityException
 In the case of the default provider, and a security manager is
           installed, the <code>checkRead</code>
           method is invoked to check read access to the file.
 @since 1.8
 */
+ (JavaIoBufferedReader *)newBufferedReaderWithJavaNioFilePath:(id<JavaNioFilePath>)path OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Opens a file for reading, returning a <code>BufferedReader</code> that may be
  used to read text from the file in an efficient manner.Bytes from the
  file are decoded into characters using the specified charset.
 Reading
  commences at the beginning of the file. 
 <p> The <code>Reader</code> methods that read from the file throw <code>IOException</code>
  if a malformed or unmappable byte sequence is read.
 @param path the path to the file
 @param cs the charset to use for decoding
 @return a new buffered reader, with default buffer size, to read text
           from the file
 @throw IOException
 if an I/O error occurs opening the file
 @throw SecurityException
 In the case of the default provider, and a security manager is
           installed, the <code>checkRead</code>
           method is invoked to check read access to the file.
 - seealso: #readAllLines
 */
+ (JavaIoBufferedReader *)newBufferedReaderWithJavaNioFilePath:(id<JavaNioFilePath>)path
                                     withJavaNioCharsetCharset:(JavaNioCharsetCharset *)cs OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Opens or creates a file for writing, returning a <code>BufferedWriter</code>
  that may be used to write text to the file in an efficient manner.
 The <code>options</code> parameter specifies how the the file is created or
  opened. If no options are present then this method works as if the <code>CREATE</code>
 , <code>TRUNCATE_EXISTING</code>
 , and <code>WRITE</code>
  options are present. In other words, it
  opens the file for writing, creating the file if it doesn't exist, or
  initially truncating an existing <code>regular-file</code> to
  a size of <code>0</code> if it exists. 
 <p> The <code>Writer</code> methods to write text throw <code>IOException</code>
  if the text cannot be encoded using the specified charset.
 @param path the path to the file
 @param cs the charset to use for encoding
 @param options options specifying how the file is opened
 @return a new buffered writer, with default buffer size, to write text
           to the file
 @throw IOException
 if an I/O error occurs opening or creating the file
 @throw UnsupportedOperationException
 if an unsupported option is specified
 @throw SecurityException
 In the case of the default provider, and a security manager is
           installed, the <code>checkWrite</code>
           method is invoked to check write access to the file.
 - seealso: #write(Path,Iterable,Charset,OpenOption[])
 */
+ (JavaIoBufferedWriter *)newBufferedWriterWithJavaNioFilePath:(id<JavaNioFilePath>)path
                                     withJavaNioCharsetCharset:(JavaNioCharsetCharset *)cs
                                withJavaNioFileOpenOptionArray:(IOSObjectArray *)options OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Opens or creates a file for writing, returning a <code>BufferedWriter</code>
  to write text to the file in an efficient manner.The text is encoded
  into bytes for writing using the <code>UTF-8</code>
  <code>charset</code>.
 <p> This method works as if invoking it were equivalent to evaluating the
  expression: 
 @code
 Files.newBufferedWriter(path, StandardCharsets.UTF_8, options) 
 
@endcode
 @param path the path to the file
 @param options options specifying how the file is opened
 @return a new buffered writer, with default buffer size, to write text
           to the file
 @throw IOException
 if an I/O error occurs opening or creating the file
 @throw UnsupportedOperationException
 if an unsupported option is specified
 @throw SecurityException
 In the case of the default provider, and a security manager is
           installed, the <code>checkWrite</code>
           method is invoked to check write access to the file.
 @since 1.8
 */
+ (JavaIoBufferedWriter *)newBufferedWriterWithJavaNioFilePath:(id<JavaNioFilePath>)path
                                withJavaNioFileOpenOptionArray:(IOSObjectArray *)options OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Opens or creates a file, returning a seekable byte channel to access the
  file.
 <p> This method opens or creates a file in exactly the manner specified
  by the <code>newByteChannel</code>
  method.
 @param path the path to the file to open or create
 @param options options specifying how the file is opened
 @return a new seekable byte channel
 @throw IllegalArgumentException
 if the set contains an invalid combination of options
 @throw UnsupportedOperationException
 if an unsupported open option is specified
 @throw FileAlreadyExistsException
 if a file of that name already exists and the <code>CREATE_NEW</code>
  option is specified
           <i>(optional specific exception)</i>
 @throw IOException
 if an I/O error occurs
 @throw SecurityException
 In the case of the default provider, and a security manager is
           installed, the <code>checkRead</code>
           method is invoked to check read access to the path if the file is
           opened for reading. The <code>checkWrite</code>
  method is invoked to check write access to the path
           if the file is opened for writing. The <code>checkDelete</code>
  method is
           invoked to check delete access if the file is opened with the          
 <code>DELETE_ON_CLOSE</code> option.
 - seealso: java.nio.channels.FileChannel#open(Path,OpenOption[])
 */
+ (id<JavaNioChannelsSeekableByteChannel>)newByteChannelWithJavaNioFilePath:(id<JavaNioFilePath>)path
                                             withJavaNioFileOpenOptionArray:(IOSObjectArray *)options OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Opens or creates a file, returning a seekable byte channel to access the
  file.
 <p> The <code>options</code> parameter determines how the file is opened.
  The <code>READ</code> and <code>WRITE</code>
  options determine if the file should be
  opened for reading and/or writing. If neither option (or the <code>APPEND</code>
  option) is present then the file is
  opened for reading. By default reading or writing commence at the
  beginning of the file. 
 <p> In the addition to <code>READ</code> and <code>WRITE</code>, the following
  options may be present: 
 <table border=1 cellpadding=5 summary="Options">
  <tr> <th>Option</th> <th>Description</th> </tr>
  <tr>
    <td> <code>APPEND</code> </td>
    <td> If this option is present then the file is opened for writing and
      each invocation of the channel's <code>write</code> method first advances
      the position to the end of the file and then writes the requested
      data. Whether the advancement of the position and the writing of the
      data are done in a single atomic operation is system-dependent and
      therefore unspecified. This option may not be used in conjunction
      with the <code>READ</code> or <code>TRUNCATE_EXISTING</code> options. </td>
  </tr>
  <tr>
    <td> <code>TRUNCATE_EXISTING</code> </td>
    <td> If this option is present then the existing file is truncated to
    a size of 0 bytes. This option is ignored when the file is opened only
    for reading. </td>
  </tr>
  <tr>
    <td> <code>CREATE_NEW</code> </td>
    <td> If this option is present then a new file is created, failing if
    the file already exists or is a symbolic link. When creating a file the
    check for the existence of the file and the creation of the file if it
    does not exist is atomic with respect to other file system operations.
    This option is ignored when the file is opened only for reading. </td>
  </tr>
  <tr>
    <td> <code>CREATE</code> </td>
    <td> If this option is present then an existing file is opened if it
    exists, otherwise a new file is created. This option is ignored if the   
 <code>CREATE_NEW</code> option is also present or the file is opened only
    for reading. </td>
  </tr>
  <tr>
    <td> <code>DELETE_ON_CLOSE</code> </td>
    <td> When this option is present then the implementation makes a
    <em>best effort</em> attempt to delete the file when closed by the
    <code>close</code> method. If the <code>close</code>
    method is not invoked then a <em>best effort</em> attempt is made to
    delete the file when the Java virtual machine terminates. </td>
  </tr>
  <tr>
    <td><code>SPARSE</code> </td>
    <td> When creating a new file this option is a <em>hint</em> that the
    new file will be sparse. This option is ignored when not creating
    a new file. </td>
  </tr>
  <tr>
    <td> <code>SYNC</code> </td>
    <td> Requires that every update to the file's content or metadata be
    written synchronously to the underlying storage device. (see <a href="package-summary.html#integrity">
  Synchronized I/O file
    integrity</a>). </td>
  </tr>
  <tr>
    <td> <code>DSYNC</code> </td>
    <td> Requires that every update to the file's content be written
    synchronously to the underlying storage device. (see <a href="package-summary.html#integrity">
  Synchronized I/O file
    integrity</a>). </td>
  </tr>
  </table>
  
 <p> An implementation may also support additional implementation specific
  options. 
 <p> The <code>attrs</code> parameter is optional <code>file-attributes</code>
  to set atomically when a new file is created. 
 <p> In the case of the default provider, the returned seekable byte channel
  is a <code>java.nio.channels.FileChannel</code>.
  
 <p> <b>Usage Examples:</b>
  @code

      Path path = ...
      // open file for reading
      ReadableByteChannel rbc = Files.newByteChannel(path, EnumSet.of(READ)));
      // open file for writing to the end of an existing file, creating
      // the file if it doesn't already exist
      WritableByteChannel wbc = Files.newByteChannel(path, EnumSet.of(CREATE,APPEND));
      // create file with initial permissions, opening it for both reading and writing     
 FileAttribute<Set<PosixFilePermission>> perms = ...
      SeekableByteChannel sbc = Files.newByteChannel(path, EnumSet.of(CREATE_NEW,READ,WRITE), perms); 
  
@endcode
 @param path the path to the file to open or create
 @param options options specifying how the file is opened
 @param attrs an optional list of file attributes to set atomically when
            creating the file
 @return a new seekable byte channel
 @throw IllegalArgumentException
 if the set contains an invalid combination of options
 @throw UnsupportedOperationException
 if an unsupported open option is specified or the array contains
           attributes that cannot be set atomically when creating the file
 @throw FileAlreadyExistsException
 if a file of that name already exists and the <code>CREATE_NEW</code>
  option is specified
           <i>(optional specific exception)</i>
 @throw IOException
 if an I/O error occurs
 @throw SecurityException
 In the case of the default provider, and a security manager is
           installed, the <code>checkRead</code>
           method is invoked to check read access to the path if the file is
           opened for reading. The <code>checkWrite</code>
  method is invoked to check write access to the path
           if the file is opened for writing. The <code>checkDelete</code>
  method is
           invoked to check delete access if the file is opened with the          
 <code>DELETE_ON_CLOSE</code> option.
 - seealso: java.nio.channels.FileChannel#open(Path,Set,FileAttribute[])
 */
+ (id<JavaNioChannelsSeekableByteChannel>)newByteChannelWithJavaNioFilePath:(id<JavaNioFilePath>)path
                                                            withJavaUtilSet:(id<JavaUtilSet>)options
                                 withJavaNioFileAttributeFileAttributeArray:(IOSObjectArray *)attrs OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Opens a directory, returning a <code>DirectoryStream</code> to iterate over
  all entries in the directory.The elements returned by the directory
  stream's <code>iterator</code> are of type <code>Path</code>
 , each one representing an entry in the directory.
 The <code>Path</code>
  objects are obtained as if by <code>resolving</code> the
  name of the directory entry against <code>dir</code>.
  
 <p> When not using the try-with-resources construct, then directory
  stream's <code>close</code> method should be invoked after iteration is
  completed so as to free any resources held for the open directory. 
 <p> When an implementation supports operations on entries in the
  directory that execute in a race-free manner then the returned directory
  stream is a <code>SecureDirectoryStream</code>.
 @param dir the path to the directory
 @return a new and open <code>DirectoryStream</code> object
 @throw NotDirectoryException
 if the file could not otherwise be opened because it is not
           a directory <i>(optional specific exception)</i>
 @throw IOException
 if an I/O error occurs
 @throw SecurityException
 In the case of the default provider, and a security manager is
           installed, the <code>checkRead</code>
           method is invoked to check read access to the directory.
 */
+ (id<JavaNioFileDirectoryStream>)newDirectoryStreamWithJavaNioFilePath:(id<JavaNioFilePath>)dir OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Opens a directory, returning a <code>DirectoryStream</code> to iterate over
  the entries in the directory.The elements returned by the directory
  stream's <code>iterator</code> are of type <code>Path</code>
 , each one representing an entry in the directory.
 The <code>Path</code>
  objects are obtained as if by <code>resolving</code> the
  name of the directory entry against <code>dir</code>. The entries returned by
  the iterator are filtered by the given <code>filter</code>
 .
  
 <p> When not using the try-with-resources construct, then directory
  stream's <code>close</code> method should be invoked after iteration is
  completed so as to free any resources held for the open directory. 
 <p> Where the filter terminates due to an uncaught error or runtime
  exception then it is propagated to the <code>hasNext</code>
  or <code>next</code> method. Where an <code>IOException</code>
  is thrown, it results in the <code>hasNext</code> or <code>next</code>
  method throwing a <code>DirectoryIteratorException</code> with the 
 <code>IOException</code> as the cause. 
 <p> When an implementation supports operations on entries in the
  directory that execute in a race-free manner then the returned directory
  stream is a <code>SecureDirectoryStream</code>.
  
 <p> <b>Usage Example:</b>
  Suppose we want to iterate over the files in a directory that are
  larger than 8K. 
 @code

      DirectoryStream.Filter&lt;Path&gt; filter = new DirectoryStream.Filter&lt;Path&gt;() {
          public boolean accept(Path file) throws IOException {
              return (Files.size(file) &gt; 8192L);
          }
      };
      Path dir = ...
      try (DirectoryStream&lt;Path&gt; stream = Files.newDirectoryStream(dir, filter)) {
          :
      } 
  
@endcode
 @param dir the path to the directory
 @param filter the directory stream filter
 @return a new and open <code>DirectoryStream</code> object
 @throw NotDirectoryException
 if the file could not otherwise be opened because it is not
           a directory <i>(optional specific exception)</i>
 @throw IOException
 if an I/O error occurs
 @throw SecurityException
 In the case of the default provider, and a security manager is
           installed, the <code>checkRead</code>
           method is invoked to check read access to the directory.
 */
+ (id<JavaNioFileDirectoryStream>)newDirectoryStreamWithJavaNioFilePath:(id<JavaNioFilePath>)dir
                                  withJavaNioFileDirectoryStream_Filter:(id<JavaNioFileDirectoryStream_Filter>)filter OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Opens a directory, returning a <code>DirectoryStream</code> to iterate over
  the entries in the directory.The elements returned by the directory
  stream's <code>iterator</code> are of type <code>Path</code>
 , each one representing an entry in the directory.
 The <code>Path</code>
  objects are obtained as if by <code>resolving</code> the
  name of the directory entry against <code>dir</code>. The entries returned by
  the iterator are filtered by matching the <code>String</code> representation
  of their file names against the given <em>globbing</em> pattern. 
 <p> For example, suppose we want to iterate over the files ending with
  ".java" in a directory: 
 @code

      Path dir = ...
      try (DirectoryStream&lt;Path&gt; stream = Files.newDirectoryStream(dir, "*.java")) {
          :
      } 
  
@endcode
  
 <p> The globbing pattern is specified by the <code>getPathMatcher</code>
  method. 
 <p> When not using the try-with-resources construct, then directory
  stream's <code>close</code> method should be invoked after iteration is
  completed so as to free any resources held for the open directory. 
 <p> When an implementation supports operations on entries in the
  directory that execute in a race-free manner then the returned directory
  stream is a <code>SecureDirectoryStream</code>.
 @param dir the path to the directory
 @param glob the glob pattern
 @return a new and open <code>DirectoryStream</code> object
 @throw java.util.regex.PatternSyntaxException
 if the pattern is invalid
 @throw NotDirectoryException
 if the file could not otherwise be opened because it is not
           a directory <i>(optional specific exception)</i>
 @throw IOException
 if an I/O error occurs
 @throw SecurityException
 In the case of the default provider, and a security manager is
           installed, the <code>checkRead</code>
           method is invoked to check read access to the directory.
 */
+ (id<JavaNioFileDirectoryStream>)newDirectoryStreamWithJavaNioFilePath:(id<JavaNioFilePath>)dir
                                                           withNSString:(NSString *)glob OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Opens a file, returning an input stream to read from the file.The stream
  will not be buffered, and is not required to support the <code>mark</code>
  or <code>reset</code> methods.
 The
  stream will be safe for access by multiple concurrent threads. Reading
  commences at the beginning of the file. Whether the returned stream is 
 <i>asynchronously closeable</i> and/or <i>interruptible</i> is highly
  file system provider specific and therefore not specified. 
 <p> The <code>options</code> parameter determines how the file is opened.
  If no options are present then it is equivalent to opening the file with the 
 <code>READ</code> option. In addition to the <code>READ</code>
  option, an implementation may also support additional implementation
  specific options.
 @param path the path to the file to open
 @param options options specifying how the file is opened
 @return a new input stream
 @throw IllegalArgumentException
 if an invalid combination of options is specified
 @throw UnsupportedOperationException
 if an unsupported option is specified
 @throw IOException
 if an I/O error occurs
 @throw SecurityException
 In the case of the default provider, and a security manager is
           installed, the <code>checkRead</code>
           method is invoked to check read access to the file.
 */
+ (JavaIoInputStream *)newInputStreamWithJavaNioFilePath:(id<JavaNioFilePath>)path
                          withJavaNioFileOpenOptionArray:(IOSObjectArray *)options OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Opens or creates a file, returning an output stream that may be used to
  write bytes to the file.The resulting stream will not be buffered.
 The
  stream will be safe for access by multiple concurrent threads. Whether
  the returned stream is <i>asynchronously closeable</i> and/or 
 <i>interruptible</i> is highly file system provider specific and
  therefore not specified. 
 <p> This method opens or creates a file in exactly the manner specified
  by the <code>newByteChannel</code>
  method with the exception that the <code>READ</code>
  option may not be present in the array of options. If no options are
  present then this method works as if the <code>CREATE</code>
 , <code>TRUNCATE_EXISTING</code>,
  and <code>WRITE</code> options are present. In other
  words, it opens the file for writing, creating the file if it doesn't
  exist, or initially truncating an existing <code>regular-file</code>
  to a size of <code>0</code> if it exists. 
 <p> <b>Usage Examples:</b>
  @code

      Path path = ...
      // truncate and overwrite an existing file, or create the file if
      // it doesn't initially exist
      OutputStream out = Files.newOutputStream(path);
      // append to an existing file, fail if the file does not exist
      out = Files.newOutputStream(path, APPEND);
      // append to an existing file, create file if it doesn't initially exist
      out = Files.newOutputStream(path, CREATE, APPEND);
      // always create new file, failing if it already exists
      out = Files.newOutputStream(path, CREATE_NEW); 
  
@endcode
 @param path the path to the file to open or create
 @param options options specifying how the file is opened
 @return a new output stream
 @throw IllegalArgumentException
 if <code>options</code> contains an invalid combination of options
 @throw UnsupportedOperationException
 if an unsupported option is specified
 @throw IOException
 if an I/O error occurs
 @throw SecurityException
 In the case of the default provider, and a security manager is
           installed, the <code>checkWrite</code>
           method is invoked to check write access to the file. The <code>checkDelete</code>
  method is
           invoked to check delete access if the file is opened with the          
 <code>DELETE_ON_CLOSE</code> option.
 */
+ (JavaIoOutputStream *)newOutputStreamWithJavaNioFilePath:(id<JavaNioFilePath>)path
                            withJavaNioFileOpenOptionArray:(IOSObjectArray *)options OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Tests whether the file located by this path does not exist.This method
  is intended for cases where it is required to take action when it can be
  confirmed that a file does not exist.
 <p> The <code>options</code> parameter may be used to indicate how symbolic links
  are handled for the case that the file is a symbolic link. By default,
  symbolic links are followed. If the option <code>NOFOLLOW_LINKS</code>
  is present then symbolic links are not followed. 
 <p> Note that this method is not the complement of the <code>exists</code>
  method. Where it is not possible to determine if a file exists
  or not then both methods return <code>false</code>. As with the <code>exists</code>
  method, the result of this method is immediately outdated. If this
  method indicates the file does exist then there is no guarantee that a
  subsequence attempt to create the file will succeed. Care should be taken
  when using this method in security sensitive applications.
 @param path the path to the file to test
 @param options options indicating how symbolic links are handled
 @return <code>true</code> if the file does not exist; <code>false</code> if the
           file exists or its existence cannot be determined
 @throw SecurityException
 In the case of the default provider, the <code>SecurityManager.checkRead(String)</code>
  is invoked to check
           read access to the file.
 */
+ (jboolean)notExistsWithJavaNioFilePath:(id<JavaNioFilePath>)path
          withJavaNioFileLinkOptionArray:(IOSObjectArray *)options;

/*!
 @brief Probes the content type of a file.
 <p> This method uses the installed <code>FileTypeDetector</code> implementations
  to probe the given file to determine its content type. Each file type
  detector's <code>probeContentType</code> is
  invoked, in turn, to probe the file type. If the file is recognized then
  the content type is returned. If the file is not recognized by any of the
  installed file type detectors then a system-default file type detector is
  invoked to guess the content type. 
 <p> A given invocation of the Java virtual machine maintains a system-wide
  list of file type detectors. Installed file type detectors are loaded
  using the service-provider loading facility defined by the <code>ServiceLoader</code>
  class. Installed file type detectors are loaded using the system class
  loader. If the system class loader cannot be found then the extension class
  loader is used; If the extension class loader cannot be found then the
  bootstrap class loader is used. File type detectors are typically installed
  by placing them in a JAR file on the application class path or in the
  extension directory, the JAR file contains a provider-configuration file
  named <code>java.nio.file.spi.FileTypeDetector</code> in the resource directory 
 <code>META-INF/services</code>, and the file lists one or more fully-qualified
  names of concrete subclass of <code>FileTypeDetector</code> that have a zero
  argument constructor. If the process of locating or instantiating the
  installed file type detectors fails then an unspecified error is thrown.
  The ordering that installed providers are located is implementation
  specific. 
 <p> The return value of this method is the string form of the value of a
  Multipurpose Internet Mail Extension (MIME) content type as
  defined by <a href="http://www.ietf.org/rfc/rfc2045.txt"><i>RFC&nbsp;2045:
  Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet
  Message Bodies</i></a>. The string is guaranteed to be parsable according
  to the grammar in the RFC.
 @param path the path to the file to probe
 @return The content type of the file, or <code>null</code> if the content
           type cannot be determined
 @throw IOException
 if an I/O error occurs
 @throw SecurityException
 If a security manager is installed and it denies an unspecified
           permission required by a file type detector implementation.
 */
+ (NSString *)probeContentTypeWithJavaNioFilePath:(id<JavaNioFilePath>)path;

/*!
 @brief Reads all the bytes from a file.The method ensures that the file is
  closed when all bytes have been read or an I/O error, or other runtime
  exception, is thrown.
 <p> Note that this method is intended for simple cases where it is
  convenient to read all bytes into a byte array. It is not intended for
  reading in large files.
 @param path the path to the file
 @return a byte array containing the bytes read from the file
 @throw IOException
 if an I/O error occurs reading from the stream
 @throw OutOfMemoryError
 if an array of the required size cannot be allocated, for
           example the file is larger that <code>2GB</code>
 @throw SecurityException
 In the case of the default provider, and a security manager is
           installed, the <code>checkRead</code>
           method is invoked to check read access to the file.
 */
+ (IOSByteArray *)readAllBytesWithJavaNioFilePath:(id<JavaNioFilePath>)path;

/*!
 @brief Read all lines from a file.Bytes from the file are decoded into characters
  using the <code>UTF-8</code> <code>charset</code>.
 <p> This method works as if invoking it were equivalent to evaluating the
  expression: 
 @code
 Files.readAllLines(path, StandardCharsets.UTF_8) 
 
@endcode
 @param path the path to the file
 @return the lines from the file as a <code>List</code>; whether the <code>List</code>
  is modifiable or not is implementation dependent and
           therefore not specified
 @throw IOException
 if an I/O error occurs reading from the file or a malformed or
           unmappable byte sequence is read
 @throw SecurityException
 In the case of the default provider, and a security manager is
           installed, the <code>checkRead</code>
           method is invoked to check read access to the file.
 @since 1.8
 */
+ (id<JavaUtilList>)readAllLinesWithJavaNioFilePath:(id<JavaNioFilePath>)path;

/*!
 @brief Read all lines from a file.This method ensures that the file is
  closed when all bytes have been read or an I/O error, or other runtime
  exception, is thrown.
 Bytes from the file are decoded into characters
  using the specified charset. 
 <p> This method recognizes the following as line terminators: 
 <ul>
    <li> <code>&#92;u000D</code> followed by <code>&#92;u000A</code>,
      CARRIAGE RETURN followed by LINE FEED </li>
    <li> <code>&#92;u000A</code>, LINE FEED </li>
    <li> <code>&#92;u000D</code>, CARRIAGE RETURN </li>
  </ul>
  <p> Additional Unicode line terminators may be recognized in future
  releases. 
 <p> Note that this method is intended for simple cases where it is
  convenient to read all lines in a single operation. It is not intended
  for reading in large files.
 @param path the path to the file
 @param cs the charset to use for decoding
 @return the lines from the file as a <code>List</code>; whether the <code>List</code>
  is modifiable or not is implementation dependent and
           therefore not specified
 @throw IOException
 if an I/O error occurs reading from the file or a malformed or
           unmappable byte sequence is read
 @throw SecurityException
 In the case of the default provider, and a security manager is
           installed, the <code>checkRead</code>
           method is invoked to check read access to the file.
 - seealso: #newBufferedReader
 */
+ (id<JavaUtilList>)readAllLinesWithJavaNioFilePath:(id<JavaNioFilePath>)path
                          withJavaNioCharsetCharset:(JavaNioCharsetCharset *)cs;

/*!
 @brief Reads a file's attributes as a bulk operation.
 <p> The <code>type</code> parameter is the type of the attributes required
  and this method returns an instance of that type if supported. All
  implementations support a basic set of file attributes and so invoking
  this method with a  <code>type</code> parameter of <code>BasicFileAttributes.class</code>
  will not throw <code>UnsupportedOperationException</code>
 .
  
 <p> The <code>options</code> array may be used to indicate how symbolic links
  are handled for the case that the file is a symbolic link. By default,
  symbolic links are followed and the file attribute of the final target
  of the link is read. If the option <code>NOFOLLOW_LINKS</code>
  is present then symbolic links are not followed. 
 <p> It is implementation specific if all file attributes are read as an
  atomic operation with respect to other file system operations. 
 <p> <b>Usage Example:</b>
  Suppose we want to read a file's attributes in bulk: 
 @code

     Path path = ...
     BasicFileAttributes attrs = Files.readAttributes(path, BasicFileAttributes.class); 
  
@endcode
  Alternatively, suppose we want to read file's POSIX attributes without
  following symbolic links: 
 @code

     PosixFileAttributes attrs = Files.readAttributes(path, PosixFileAttributes.class, NOFOLLOW_LINKS); 
  
@endcode
 @param path the path to the file
 @param type the 
 <code>Class</code>  of the file attributes required           to read
 @param options options indicating how symbolic links are handled
 @return the file attributes
 @throw UnsupportedOperationException
 if an attributes of the given type are not supported
 @throw IOException
 if an I/O error occurs
 @throw SecurityException
 In the case of the default provider, a security manager is
           installed, its <code>checkRead</code>
           method is invoked to check read access to the file. If this
           method is invoked to read security sensitive attributes then the
           security manager may be invoke to check for additional permissions.
 */
+ (id<JavaNioFileAttributeBasicFileAttributes>)readAttributesWithJavaNioFilePath:(id<JavaNioFilePath>)path
                                                                    withIOSClass:(IOSClass *)type
                                                  withJavaNioFileLinkOptionArray:(IOSObjectArray *)options;

/*!
 @brief Reads a set of file attributes as a bulk operation.
 <p> The <code>attributes</code> parameter identifies the attributes to be read
  and takes the form: 
 <blockquote>
  [<i>view-name</i><b>:</b>]<i>attribute-list</i>
  </blockquote>
  where square brackets [...] delineate an optional component and the
  character <code>':'</code> stands for itself. 
 <p> <i>view-name</i> is the <code>name</code> of a <code>FileAttributeView</code>
  that identifies a set of file attributes. If not
  specified then it defaults to <code>"basic"</code>, the name of the file
  attribute view that identifies the basic set of file attributes common to
  many file systems. 
 <p> The <i>attribute-list</i> component is a comma separated list of
  zero or more names of attributes to read. If the list contains the value 
 <code>"*"</code> then all attributes are read. Attributes that are not supported
  are ignored and will not be present in the returned map. It is
  implementation specific if all attributes are read as an atomic operation
  with respect to other file system operations. 
 <p> The following examples demonstrate possible values for the <code>attributes</code>
  parameter: 
 <blockquote>
  <table border="0" summary="Possible values">
  <tr>
    <td> <code>"*"</code> </td>
    <td> Read all <code>basic-file-attributes</code>. </td>
  </tr>
  <tr>
    <td> <code>"size,lastModifiedTime,lastAccessTime"</code> </td>
    <td> Reads the file size, last modified time, and last access time
      attributes. </td>
  </tr>
  <tr>
    <td> <code>"posix:*"</code> </td>
    <td> Read all <code>POSIX-file-attributes</code>. </td>
  </tr>
  <tr>
    <td> <code>"posix:permissions,owner,size"</code> </td>
    <td> Reads the POSX file permissions, owner, and file size. </td>
  </tr>
  </table>
  </blockquote>
  
 <p> The <code>options</code> array may be used to indicate how symbolic links
  are handled for the case that the file is a symbolic link. By default,
  symbolic links are followed and the file attribute of the final target
  of the link is read. If the option <code>NOFOLLOW_LINKS</code>
  is present then symbolic links are not followed.
 @param path the path to the file
 @param attributes the attributes to read
 @param options options indicating how symbolic links are handled
 @return a map of the attributes returned; The map's keys are the
           attribute names, its values are the attribute values
 @throw UnsupportedOperationException
 if the attribute view is not available
 @throw IllegalArgumentException
 if no attributes are specified or an unrecognized attributes is
           specified
 @throw IOException
 if an I/O error occurs
 @throw SecurityException
 In the case of the default provider, and a security manager is
           installed, its <code>checkRead</code>
           method denies read access to the file. If this method is invoked
           to read security sensitive attributes then the security manager
           may be invoke to check for additional permissions.
 */
+ (id<JavaUtilMap>)readAttributesWithJavaNioFilePath:(id<JavaNioFilePath>)path
                                        withNSString:(NSString *)attributes
                      withJavaNioFileLinkOptionArray:(IOSObjectArray *)options;

/*!
 @brief Reads the target of a symbolic link <i>(optional operation)</i>.
 <p> If the file system supports <a href="package-summary.html#links">symbolic
  links</a> then this method is used to read the target of the link, failing
  if the file is not a symbolic link. The target of the link need not exist.
  The returned <code>Path</code> object will be associated with the same file
  system as <code>link</code>.
 @param link the path to the symbolic link
 @return a <code>Path</code> object representing the target of the link
 @throw UnsupportedOperationException
 if the implementation does not support symbolic links
 @throw NotLinkException
 if the target could otherwise not be read because the file
           is not a symbolic link <i>(optional specific exception)</i>
 @throw IOException
 if an I/O error occurs
 @throw SecurityException
 In the case of the default provider, and a security manager
           is installed, it checks that <code>FilePermission</code> has been
           granted with the "<code>readlink</code>" action to read the link.
 */
+ (id<JavaNioFilePath>)readSymbolicLinkWithJavaNioFilePath:(id<JavaNioFilePath>)link;

/*!
 @brief Sets the value of a file attribute.
 <p> The <code>attribute</code> parameter identifies the attribute to be set
  and takes the form: 
 <blockquote>
  [<i>view-name</i><b>:</b>]<i>attribute-name</i>
  </blockquote>
  where square brackets [...] delineate an optional component and the
  character <code>':'</code> stands for itself. 
 <p> <i>view-name</i> is the <code>name</code> of a <code>FileAttributeView</code>
  that identifies a set of file attributes. If not
  specified then it defaults to <code>"basic"</code>, the name of the file
  attribute view that identifies the basic set of file attributes common to
  many file systems. <i>attribute-name</i> is the name of the attribute
  within the set. 
 <p> The <code>options</code> array may be used to indicate how symbolic links
  are handled for the case that the file is a symbolic link. By default,
  symbolic links are followed and the file attribute of the final target
  of the link is set. If the option <code>NOFOLLOW_LINKS</code>
  is present then symbolic links are not followed. 
 <p> <b>Usage Example:</b>
  Suppose we want to set the DOS "hidden" attribute: 
 @code

     Path path = ...
     Files.setAttribute(path, "dos:hidden", true); 
  
@endcode
 @param path the path to the file
 @param attribute the attribute to set
 @param value the attribute value
 @param options options indicating how symbolic links are handled
 @return the <code>path</code> parameter
 @throw UnsupportedOperationException
 if the attribute view is not available
 @throw IllegalArgumentException
 if the attribute name is not specified, or is not recognized, or
           the attribute value is of the correct type but has an
           inappropriate value
 @throw ClassCastException
 if the attribute value is not of the expected type or is a
           collection containing elements that are not of the expected
           type
 @throw IOException
 if an I/O error occurs
 @throw SecurityException
 In the case of the default provider, and a security manager is
           installed, its <code>checkWrite</code>
           method denies write access to the file. If this method is invoked
           to set security sensitive attributes then the security manager
           may be invoked to check for additional permissions.
 */
+ (id<JavaNioFilePath>)setAttributeWithJavaNioFilePath:(id<JavaNioFilePath>)path
                                          withNSString:(NSString *)attribute
                                                withId:(id)value
                        withJavaNioFileLinkOptionArray:(IOSObjectArray *)options;

/*!
 @brief Updates a file's last modified time attribute.The file time is converted
  to the epoch and precision supported by the file system.
 Converting from
  finer to coarser granularities result in precision loss. The behavior of
  this method when attempting to set the last modified time when it is not
  supported by the file system or is outside the range supported by the
  underlying file store is not defined. It may or not fail by throwing an 
 <code>IOException</code>.
  
 <p> <b>Usage Example:</b>
  Suppose we want to set the last modified time to the current time: 
 @code

     Path path = ...
     FileTime now = FileTime.fromMillis(System.currentTimeMillis());
     Files.setLastModifiedTime(path, now); 
  
@endcode
 @param path the path to the file
 @param time the new last modified time
 @return the path
 @throw IOException
 if an I/O error occurs
 @throw SecurityException
 In the case of the default provider, the security manager's <code>checkWrite</code>
  method is invoked
           to check write access to file
 - seealso: BasicFileAttributeView#setTimes
 */
+ (id<JavaNioFilePath>)setLastModifiedTimeWithJavaNioFilePath:(id<JavaNioFilePath>)path
                             withJavaNioFileAttributeFileTime:(JavaNioFileAttributeFileTime *)time;

/*!
 @brief Updates the file owner.
 <p> The <code>path</code> parameter is associated with a file system that
  supports <code>FileOwnerAttributeView</code>. This file attribute view provides
  access to a file attribute that is the owner of the file. 
 <p> <b>Usage Example:</b>
  Suppose we want to make "joe" the owner of a file: 
 @code

      Path path = ...
      UserPrincipalLookupService lookupService =
          provider(path).getUserPrincipalLookupService();
      UserPrincipal joe = lookupService.lookupPrincipalByName("joe");
      Files.setOwner(path, joe); 
  
@endcode
 @param path The path to the file
 @param owner The new file owner
 @return The path
 @throw UnsupportedOperationException
 if the associated file system does not support the <code>FileOwnerAttributeView</code>
 @throw IOException
 if an I/O error occurs
 @throw SecurityException
 In the case of the default provider, and a security manager is
           installed, it denies <code>RuntimePermission</code><tt>("accessUserInformation")</tt>
           or its <code>checkWrite</code>
           method denies write access to the file.
 - seealso: FileSystem#getUserPrincipalLookupService
 - seealso: java.nio.file.attribute.UserPrincipalLookupService
 */
+ (id<JavaNioFilePath>)setOwnerWithJavaNioFilePath:(id<JavaNioFilePath>)path
             withJavaNioFileAttributeUserPrincipal:(id<JavaNioFileAttributeUserPrincipal>)owner;

/*!
 @brief Sets a file's POSIX permissions.
 <p> The <code>path</code> parameter is associated with a <code>FileSystem</code>
  that supports the <code>PosixFileAttributeView</code>. This attribute view
  provides access to file attributes commonly associated with files on file
  systems used by operating systems that implement the Portable Operating
  System Interface (POSIX) family of standards.
 @param path The path to the file
 @param perms The new set of permissions
 @return The path
 @throw UnsupportedOperationException
 if the associated file system does not support the <code>PosixFileAttributeView</code>
 @throw ClassCastException
 if the sets contains elements that are not of type <code>PosixFilePermission</code>
 @throw IOException
 if an I/O error occurs
 @throw SecurityException
 In the case of the default provider, and a security manager is
           installed, it denies <code>RuntimePermission</code><tt>("accessUserInformation")</tt>
           or its <code>checkWrite</code>
           method denies write access to the file.
 */
+ (id<JavaNioFilePath>)setPosixFilePermissionsWithJavaNioFilePath:(id<JavaNioFilePath>)path
                                                  withJavaUtilSet:(id<JavaUtilSet>)perms;

/*!
 @brief Returns the size of a file (in bytes).The size may differ from the
  actual size on the file system due to compression, support for sparse
  files, or other reasons.
 The size of files that are not <code>regular</code>
  files is implementation specific and
  therefore unspecified.
 @param path the path to the file
 @return the file size, in bytes
 @throw IOException
 if an I/O error occurs
 @throw SecurityException
 In the case of the default provider, and a security manager is
           installed, its <code>checkRead</code>
           method denies read access to the file.
 - seealso: BasicFileAttributes#size
 */
+ (jlong)sizeWithJavaNioFilePath:(id<JavaNioFilePath>)path;

/*!
 @brief Return a <code>Stream</code> that is lazily populated with <code>Path</code>
  by walking the file tree rooted at a given starting file.The
  file tree is traversed <em>depth-first</em>, the elements in the stream
  are <code>Path</code> objects that are obtained as if by <code>resolving</code>
  the relative path against <code>start</code>.
 <p> This method works as if invoking it were equivalent to evaluating the
  expression: 
 <blockquote>@code

  walk(start, Integer.MAX_VALUE, options) 
  
@endcode</blockquote>
  In other words, it visits all levels of the file tree. 
 <p> The returned stream encapsulates one or more <code>DirectoryStream</code>s.
  If timely disposal of file system resources is required, the 
 <code>try</code>-with-resources construct should be used to ensure that the
  stream's <code>close</code> method is invoked after the stream
  operations are completed.  Operating on a closed stream will result in an 
 <code>java.lang.IllegalStateException</code>.
 @param start the starting file
 @param options options to configure the traversal
 @return the <code>Stream</code> of <code>Path</code>
 @throw SecurityException
 If the security manager denies access to the starting file.
           In the case of the default provider, the <code>checkRead</code>
  method is invoked
           to check read access to the directory.
 @throw IOException
 if an I/O error is thrown when accessing the starting file.
 - seealso: #walk(Path, int, FileVisitOption...)
 @since 1.8
 */
+ (id<JavaUtilStreamStream>)walkWithJavaNioFilePath:(id<JavaNioFilePath>)start
                withJavaNioFileFileVisitOptionArray:(IOSObjectArray *)options;

/*!
 @brief Return a <code>Stream</code> that is lazily populated with <code>Path</code>
  by walking the file tree rooted at a given starting file.The
  file tree is traversed <em>depth-first</em>, the elements in the stream
  are <code>Path</code> objects that are obtained as if by <code>resolving</code>
  the relative path against <code>start</code>.
 <p> The <code>stream</code> walks the file tree as elements are consumed.
  The <code>Stream</code> returned is guaranteed to have at least one
  element, the starting file itself. For each file visited, the stream
  attempts to read its <code>BasicFileAttributes</code>. If the file is a
  directory and can be opened successfully, entries in the directory, and
  their <em>descendants</em> will follow the directory in the stream as
  they are encountered. When all entries have been visited, then the
  directory is closed. The file tree walk then continues at the next 
 <em>sibling</em> of the directory. 
 <p> The stream is <i>weakly consistent</i>. It does not freeze the
  file tree while iterating, so it may (or may not) reflect updates to
  the file tree that occur after returned from this method. 
 <p> By default, symbolic links are not automatically followed by this
  method. If the <code>options</code> parameter contains the <code>FOLLOW_LINKS</code>
  option then symbolic links are
  followed. When following links, and the attributes of the target cannot
  be read, then this method attempts to get the <code>BasicFileAttributes</code>
  of the link. 
 <p> If the <code>options</code> parameter contains the <code>FOLLOW_LINKS</code>
  option then the stream keeps
  track of directories visited so that cycles can be detected. A cycle
  arises when there is an entry in a directory that is an ancestor of the
  directory. Cycle detection is done by recording the <code>file-key</code>
  of directories,
  or if file keys are not available, by invoking the <code>isSameFile</code>
  method to test if a directory is the same file as an
  ancestor. When a cycle is detected it is treated as an I/O error with
  an instance of <code>FileSystemLoopException</code>.
  
 <p> The <code>maxDepth</code> parameter is the maximum number of levels of
  directories to visit. A value of <code>0</code> means that only the starting
  file is visited, unless denied by the security manager. A value of 
 <code>MAX_VALUE</code> may be used to indicate that all
  levels should be visited. 
 <p> When a security manager is installed and it denies access to a file
  (or directory), then it is ignored and not included in the stream. 
 <p> The returned stream encapsulates one or more <code>DirectoryStream</code>s.
  If timely disposal of file system resources is required, the 
 <code>try</code>-with-resources construct should be used to ensure that the
  stream's <code>close</code> method is invoked after the stream
  operations are completed.  Operating on a closed stream will result in an 
 <code>java.lang.IllegalStateException</code>.
  
 <p> If an <code>IOException</code> is thrown when accessing the directory
  after this method has returned, it is wrapped in an <code>UncheckedIOException</code>
  which will be thrown from the method that caused
  the access to take place.
 @param start the starting file
 @param maxDepth the maximum number of directory levels to visit
 @param options options to configure the traversal
 @return the <code>Stream</code> of <code>Path</code>
 @throw IllegalArgumentException
 if the <code>maxDepth</code> parameter is negative
 @throw SecurityException
 If the security manager denies access to the starting file.
           In the case of the default provider, the <code>checkRead</code>
  method is invoked
           to check read access to the directory.
 @throw IOException
 if an I/O error is thrown when accessing the starting file.
 @since 1.8
 */
+ (id<JavaUtilStreamStream>)walkWithJavaNioFilePath:(id<JavaNioFilePath>)start
                                            withInt:(jint)maxDepth
                withJavaNioFileFileVisitOptionArray:(IOSObjectArray *)options;

/*!
 @brief Walks a file tree.
 <p> This method works as if invoking it were equivalent to evaluating the
  expression: 
 <blockquote>@code

  walkFileTree(start, EnumSet.noneOf(FileVisitOption.class), Integer.MAX_VALUE, visitor) 
  
@endcode</blockquote>
  In other words, it does not follow symbolic links, and visits all levels
  of the file tree.
 @param start the starting file
 @param visitor the file visitor to invoke for each file
 @return the starting file
 @throw SecurityException
 If the security manager denies access to the starting file.
           In the case of the default provider, the <code>checkRead</code>
  method is invoked
           to check read access to the directory.
 @throw IOException
 if an I/O error is thrown by a visitor method
 */
+ (id<JavaNioFilePath>)walkFileTreeWithJavaNioFilePath:(id<JavaNioFilePath>)start
                            withJavaNioFileFileVisitor:(id<JavaNioFileFileVisitor>)visitor;

/*!
 @brief Walks a file tree.
 <p> This method walks a file tree rooted at a given starting file. The
  file tree traversal is <em>depth-first</em> with the given <code>FileVisitor</code>
  invoked for each file encountered. File tree traversal
  completes when all accessible files in the tree have been visited, or a
  visit method returns a result of <code>TERMINATE</code>
 . Where a visit method terminates due an <code>IOException</code>,
  an uncaught error, or runtime exception, then the traversal is terminated
  and the error or exception is propagated to the caller of this method. 
 <p> For each file encountered this method attempts to read its <code>java.nio.file.attribute.BasicFileAttributes</code>
 . If the file is not a
  directory then the <code>visitFile</code> method is
  invoked with the file attributes. If the file attributes cannot be read,
  due to an I/O exception, then the <code>visitFileFailed</code>
  method is invoked with the I/O exception. 
 <p> Where the file is a directory, and the directory could not be opened,
  then the <code>visitFileFailed</code> method is invoked with the I/O exception,
  after which, the file tree walk continues, by default, at the next 
 <em>sibling</em> of the directory. 
 <p> Where the directory is opened successfully, then the entries in the
  directory, and their <em>descendants</em> are visited. When all entries
  have been visited, or an I/O error occurs during iteration of the
  directory, then the directory is closed and the visitor's <code>postVisitDirectory</code>
  method is invoked.
  The file tree walk then continues, by default, at the next <em>sibling</em>
  of the directory. 
 <p> By default, symbolic links are not automatically followed by this
  method. If the <code>options</code> parameter contains the <code>FOLLOW_LINKS</code>
  option then symbolic links are
  followed. When following links, and the attributes of the target cannot
  be read, then this method attempts to get the <code>BasicFileAttributes</code>
  of the link. If they can be read then the <code>visitFile</code> method is
  invoked with the attributes of the link (otherwise the <code>visitFileFailed</code>
  method is invoked as specified above). 
 <p> If the <code>options</code> parameter contains the <code>FOLLOW_LINKS</code>
  option then this method keeps
  track of directories visited so that cycles can be detected. A cycle
  arises when there is an entry in a directory that is an ancestor of the
  directory. Cycle detection is done by recording the <code>file-key</code>
  of directories,
  or if file keys are not available, by invoking the <code>isSameFile</code>
  method to test if a directory is the same file as an
  ancestor. When a cycle is detected it is treated as an I/O error, and the 
 <code>visitFileFailed</code> method is invoked with
  an instance of <code>FileSystemLoopException</code>.
  
 <p> The <code>maxDepth</code> parameter is the maximum number of levels of
  directories to visit. A value of <code>0</code> means that only the starting
  file is visited, unless denied by the security manager. A value of 
 <code>MAX_VALUE</code> may be used to indicate that all
  levels should be visited. The <code>visitFile</code> method is invoked for all
  files, including directories, encountered at <code>maxDepth</code>, unless the
  basic file attributes cannot be read, in which case the <code>visitFileFailed</code>
  method is invoked. 
 <p> If a visitor returns a result of <code>null</code> then <code>NullPointerException</code>
  is thrown. 
 <p> When a security manager is installed and it denies access to a file
  (or directory), then it is ignored and the visitor is not invoked for
  that file (or directory).
 @param start the starting file
 @param options options to configure the traversal
 @param maxDepth the maximum number of directory levels to visit
 @param visitor the file visitor to invoke for each file
 @return the starting file
 @throw IllegalArgumentException
 if the <code>maxDepth</code> parameter is negative
 @throw SecurityException
 If the security manager denies access to the starting file.
           In the case of the default provider, the <code>checkRead</code>
  method is invoked
           to check read access to the directory.
 @throw IOException
 if an I/O error is thrown by a visitor method
 */
+ (id<JavaNioFilePath>)walkFileTreeWithJavaNioFilePath:(id<JavaNioFilePath>)start
                                       withJavaUtilSet:(id<JavaUtilSet>)options
                                               withInt:(jint)maxDepth
                            withJavaNioFileFileVisitor:(id<JavaNioFileFileVisitor>)visitor;

/*!
 @brief Writes bytes to a file.The <code>options</code> parameter specifies how the
  the file is created or opened.
 If no options are present then this method
  works as if the <code>CREATE</code>, <code>TRUNCATE_EXISTING</code>
 , and <code>WRITE</code>
  options are present. In other words, it
  opens the file for writing, creating the file if it doesn't exist, or
  initially truncating an existing <code>regular-file</code> to
  a size of <code>0</code>. All bytes in the byte array are written to the file.
  The method ensures that the file is closed when all bytes have been
  written (or an I/O error or other runtime exception is thrown). If an I/O
  error occurs then it may do so after the file has created or truncated,
  or after some bytes have been written to the file. 
 <p> <b>Usage example</b>: By default the method creates a new file or
  overwrites an existing file. Suppose you instead want to append bytes
  to an existing file: 
 @code

      Path path = ...
      byte[] bytes = ...
      Files.write(path, bytes, StandardOpenOption.APPEND); 
  
@endcode
 @param path the path to the file
 @param bytes the byte array with the bytes to write
 @param options options specifying how the file is opened
 @return the path
 @throw IOException
 if an I/O error occurs writing to or creating the file
 @throw UnsupportedOperationException
 if an unsupported option is specified
 @throw SecurityException
 In the case of the default provider, and a security manager is
           installed, the <code>checkWrite</code>
           method is invoked to check write access to the file.
 */
+ (id<JavaNioFilePath>)writeWithJavaNioFilePath:(id<JavaNioFilePath>)path
                                  withByteArray:(IOSByteArray *)bytes
                 withJavaNioFileOpenOptionArray:(IOSObjectArray *)options;

/*!
 @brief Write lines of text to a file.Each line is a char sequence and is
  written to the file in sequence with each line terminated by the
  platform's line separator, as defined by the system property <code>line.separator</code>
 .
 Characters are encoded into bytes using the specified
  charset. 
 <p> The <code>options</code> parameter specifies how the the file is created
  or opened. If no options are present then this method works as if the 
 <code>CREATE</code>, <code>TRUNCATE_EXISTING</code>
 , and <code>WRITE</code>
  options are present. In other words, it
  opens the file for writing, creating the file if it doesn't exist, or
  initially truncating an existing <code>regular-file</code> to
  a size of <code>0</code>. The method ensures that the file is closed when all
  lines have been written (or an I/O error or other runtime exception is
  thrown). If an I/O error occurs then it may do so after the file has
  created or truncated, or after some bytes have been written to the file.
 @param path the path to the file
 @param lines an object to iterate over the char sequences
 @param cs the charset to use for encoding
 @param options options specifying how the file is opened
 @return the path
 @throw IOException
 if an I/O error occurs writing to or creating the file, or the
           text cannot be encoded using the specified charset
 @throw UnsupportedOperationException
 if an unsupported option is specified
 @throw SecurityException
 In the case of the default provider, and a security manager is
           installed, the <code>checkWrite</code>
           method is invoked to check write access to the file.
 */
+ (id<JavaNioFilePath>)writeWithJavaNioFilePath:(id<JavaNioFilePath>)path
                           withJavaLangIterable:(id<JavaLangIterable>)lines
                      withJavaNioCharsetCharset:(JavaNioCharsetCharset *)cs
                 withJavaNioFileOpenOptionArray:(IOSObjectArray *)options;

/*!
 @brief Write lines of text to a file.Characters are encoded into bytes using
  the <code>UTF-8</code> <code>charset</code>.
 <p> This method works as if invoking it were equivalent to evaluating the
  expression: 
 @code
 Files.write(path, lines, StandardCharsets.UTF_8, options); 
 
@endcode
 @param path the path to the file
 @param lines an object to iterate over the char sequences
 @param options options specifying how the file is opened
 @return the path
 @throw IOException
 if an I/O error occurs writing to or creating the file, or the
           text cannot be encoded as <code>UTF-8</code>
 @throw UnsupportedOperationException
 if an unsupported option is specified
 @throw SecurityException
 In the case of the default provider, and a security manager is
           installed, the <code>checkWrite</code>
           method is invoked to check write access to the file.
 @since 1.8
 */
+ (id<JavaNioFilePath>)writeWithJavaNioFilePath:(id<JavaNioFilePath>)path
                           withJavaLangIterable:(id<JavaLangIterable>)lines
                 withJavaNioFileOpenOptionArray:(IOSObjectArray *)options;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaNioFileFiles)

FOUNDATION_EXPORT JavaIoInputStream *JavaNioFileFiles_newInputStreamWithJavaNioFilePath_withJavaNioFileOpenOptionArray_(id<JavaNioFilePath> path, IOSObjectArray *options);

FOUNDATION_EXPORT JavaIoOutputStream *JavaNioFileFiles_newOutputStreamWithJavaNioFilePath_withJavaNioFileOpenOptionArray_(id<JavaNioFilePath> path, IOSObjectArray *options);

FOUNDATION_EXPORT id<JavaNioChannelsSeekableByteChannel> JavaNioFileFiles_newByteChannelWithJavaNioFilePath_withJavaUtilSet_withJavaNioFileAttributeFileAttributeArray_(id<JavaNioFilePath> path, id<JavaUtilSet> options, IOSObjectArray *attrs);

FOUNDATION_EXPORT id<JavaNioChannelsSeekableByteChannel> JavaNioFileFiles_newByteChannelWithJavaNioFilePath_withJavaNioFileOpenOptionArray_(id<JavaNioFilePath> path, IOSObjectArray *options);

FOUNDATION_EXPORT id<JavaNioFileDirectoryStream> JavaNioFileFiles_newDirectoryStreamWithJavaNioFilePath_(id<JavaNioFilePath> dir);

FOUNDATION_EXPORT id<JavaNioFileDirectoryStream> JavaNioFileFiles_newDirectoryStreamWithJavaNioFilePath_withNSString_(id<JavaNioFilePath> dir, NSString *glob);

FOUNDATION_EXPORT id<JavaNioFileDirectoryStream> JavaNioFileFiles_newDirectoryStreamWithJavaNioFilePath_withJavaNioFileDirectoryStream_Filter_(id<JavaNioFilePath> dir, id<JavaNioFileDirectoryStream_Filter> filter);

FOUNDATION_EXPORT id<JavaNioFilePath> JavaNioFileFiles_createFileWithJavaNioFilePath_withJavaNioFileAttributeFileAttributeArray_(id<JavaNioFilePath> path, IOSObjectArray *attrs);

FOUNDATION_EXPORT id<JavaNioFilePath> JavaNioFileFiles_createDirectoryWithJavaNioFilePath_withJavaNioFileAttributeFileAttributeArray_(id<JavaNioFilePath> dir, IOSObjectArray *attrs);

FOUNDATION_EXPORT id<JavaNioFilePath> JavaNioFileFiles_createDirectoriesWithJavaNioFilePath_withJavaNioFileAttributeFileAttributeArray_(id<JavaNioFilePath> dir, IOSObjectArray *attrs);

FOUNDATION_EXPORT id<JavaNioFilePath> JavaNioFileFiles_createTempFileWithJavaNioFilePath_withNSString_withNSString_withJavaNioFileAttributeFileAttributeArray_(id<JavaNioFilePath> dir, NSString *prefix, NSString *suffix, IOSObjectArray *attrs);

FOUNDATION_EXPORT id<JavaNioFilePath> JavaNioFileFiles_createTempFileWithNSString_withNSString_withJavaNioFileAttributeFileAttributeArray_(NSString *prefix, NSString *suffix, IOSObjectArray *attrs);

FOUNDATION_EXPORT id<JavaNioFilePath> JavaNioFileFiles_createTempDirectoryWithJavaNioFilePath_withNSString_withJavaNioFileAttributeFileAttributeArray_(id<JavaNioFilePath> dir, NSString *prefix, IOSObjectArray *attrs);

FOUNDATION_EXPORT id<JavaNioFilePath> JavaNioFileFiles_createTempDirectoryWithNSString_withJavaNioFileAttributeFileAttributeArray_(NSString *prefix, IOSObjectArray *attrs);

FOUNDATION_EXPORT id<JavaNioFilePath> JavaNioFileFiles_createSymbolicLinkWithJavaNioFilePath_withJavaNioFilePath_withJavaNioFileAttributeFileAttributeArray_(id<JavaNioFilePath> link, id<JavaNioFilePath> target, IOSObjectArray *attrs);

FOUNDATION_EXPORT id<JavaNioFilePath> JavaNioFileFiles_createLinkWithJavaNioFilePath_withJavaNioFilePath_(id<JavaNioFilePath> link, id<JavaNioFilePath> existing);

FOUNDATION_EXPORT void JavaNioFileFiles_delete__WithJavaNioFilePath_(id<JavaNioFilePath> path);

FOUNDATION_EXPORT jboolean JavaNioFileFiles_deleteIfExistsWithJavaNioFilePath_(id<JavaNioFilePath> path);

FOUNDATION_EXPORT id<JavaNioFilePath> JavaNioFileFiles_copy__WithJavaNioFilePath_withJavaNioFilePath_withJavaNioFileCopyOptionArray_(id<JavaNioFilePath> source, id<JavaNioFilePath> target, IOSObjectArray *options);

FOUNDATION_EXPORT id<JavaNioFilePath> JavaNioFileFiles_moveWithJavaNioFilePath_withJavaNioFilePath_withJavaNioFileCopyOptionArray_(id<JavaNioFilePath> source, id<JavaNioFilePath> target, IOSObjectArray *options);

FOUNDATION_EXPORT id<JavaNioFilePath> JavaNioFileFiles_readSymbolicLinkWithJavaNioFilePath_(id<JavaNioFilePath> link);

FOUNDATION_EXPORT JavaNioFileFileStore *JavaNioFileFiles_getFileStoreWithJavaNioFilePath_(id<JavaNioFilePath> path);

FOUNDATION_EXPORT jboolean JavaNioFileFiles_isSameFileWithJavaNioFilePath_withJavaNioFilePath_(id<JavaNioFilePath> path, id<JavaNioFilePath> path2);

FOUNDATION_EXPORT jboolean JavaNioFileFiles_isHiddenWithJavaNioFilePath_(id<JavaNioFilePath> path);

FOUNDATION_EXPORT NSString *JavaNioFileFiles_probeContentTypeWithJavaNioFilePath_(id<JavaNioFilePath> path);

FOUNDATION_EXPORT id<JavaNioFileAttributeFileAttributeView> JavaNioFileFiles_getFileAttributeViewWithJavaNioFilePath_withIOSClass_withJavaNioFileLinkOptionArray_(id<JavaNioFilePath> path, IOSClass *type, IOSObjectArray *options);

FOUNDATION_EXPORT id<JavaNioFileAttributeBasicFileAttributes> JavaNioFileFiles_readAttributesWithJavaNioFilePath_withIOSClass_withJavaNioFileLinkOptionArray_(id<JavaNioFilePath> path, IOSClass *type, IOSObjectArray *options);

FOUNDATION_EXPORT id<JavaNioFilePath> JavaNioFileFiles_setAttributeWithJavaNioFilePath_withNSString_withId_withJavaNioFileLinkOptionArray_(id<JavaNioFilePath> path, NSString *attribute, id value, IOSObjectArray *options);

FOUNDATION_EXPORT id JavaNioFileFiles_getAttributeWithJavaNioFilePath_withNSString_withJavaNioFileLinkOptionArray_(id<JavaNioFilePath> path, NSString *attribute, IOSObjectArray *options);

FOUNDATION_EXPORT id<JavaUtilMap> JavaNioFileFiles_readAttributesWithJavaNioFilePath_withNSString_withJavaNioFileLinkOptionArray_(id<JavaNioFilePath> path, NSString *attributes, IOSObjectArray *options);

FOUNDATION_EXPORT id<JavaUtilSet> JavaNioFileFiles_getPosixFilePermissionsWithJavaNioFilePath_withJavaNioFileLinkOptionArray_(id<JavaNioFilePath> path, IOSObjectArray *options);

FOUNDATION_EXPORT id<JavaNioFilePath> JavaNioFileFiles_setPosixFilePermissionsWithJavaNioFilePath_withJavaUtilSet_(id<JavaNioFilePath> path, id<JavaUtilSet> perms);

FOUNDATION_EXPORT id<JavaNioFileAttributeUserPrincipal> JavaNioFileFiles_getOwnerWithJavaNioFilePath_withJavaNioFileLinkOptionArray_(id<JavaNioFilePath> path, IOSObjectArray *options);

FOUNDATION_EXPORT id<JavaNioFilePath> JavaNioFileFiles_setOwnerWithJavaNioFilePath_withJavaNioFileAttributeUserPrincipal_(id<JavaNioFilePath> path, id<JavaNioFileAttributeUserPrincipal> owner);

FOUNDATION_EXPORT jboolean JavaNioFileFiles_isSymbolicLinkWithJavaNioFilePath_(id<JavaNioFilePath> path);

FOUNDATION_EXPORT jboolean JavaNioFileFiles_isDirectoryWithJavaNioFilePath_withJavaNioFileLinkOptionArray_(id<JavaNioFilePath> path, IOSObjectArray *options);

FOUNDATION_EXPORT jboolean JavaNioFileFiles_isRegularFileWithJavaNioFilePath_withJavaNioFileLinkOptionArray_(id<JavaNioFilePath> path, IOSObjectArray *options);

FOUNDATION_EXPORT JavaNioFileAttributeFileTime *JavaNioFileFiles_getLastModifiedTimeWithJavaNioFilePath_withJavaNioFileLinkOptionArray_(id<JavaNioFilePath> path, IOSObjectArray *options);

FOUNDATION_EXPORT id<JavaNioFilePath> JavaNioFileFiles_setLastModifiedTimeWithJavaNioFilePath_withJavaNioFileAttributeFileTime_(id<JavaNioFilePath> path, JavaNioFileAttributeFileTime *time);

FOUNDATION_EXPORT jlong JavaNioFileFiles_sizeWithJavaNioFilePath_(id<JavaNioFilePath> path);

FOUNDATION_EXPORT jboolean JavaNioFileFiles_existsWithJavaNioFilePath_withJavaNioFileLinkOptionArray_(id<JavaNioFilePath> path, IOSObjectArray *options);

FOUNDATION_EXPORT jboolean JavaNioFileFiles_notExistsWithJavaNioFilePath_withJavaNioFileLinkOptionArray_(id<JavaNioFilePath> path, IOSObjectArray *options);

FOUNDATION_EXPORT jboolean JavaNioFileFiles_isReadableWithJavaNioFilePath_(id<JavaNioFilePath> path);

FOUNDATION_EXPORT jboolean JavaNioFileFiles_isWritableWithJavaNioFilePath_(id<JavaNioFilePath> path);

FOUNDATION_EXPORT jboolean JavaNioFileFiles_isExecutableWithJavaNioFilePath_(id<JavaNioFilePath> path);

FOUNDATION_EXPORT id<JavaNioFilePath> JavaNioFileFiles_walkFileTreeWithJavaNioFilePath_withJavaUtilSet_withInt_withJavaNioFileFileVisitor_(id<JavaNioFilePath> start, id<JavaUtilSet> options, jint maxDepth, id<JavaNioFileFileVisitor> visitor);

FOUNDATION_EXPORT id<JavaNioFilePath> JavaNioFileFiles_walkFileTreeWithJavaNioFilePath_withJavaNioFileFileVisitor_(id<JavaNioFilePath> start, id<JavaNioFileFileVisitor> visitor);

FOUNDATION_EXPORT JavaIoBufferedReader *JavaNioFileFiles_newBufferedReaderWithJavaNioFilePath_withJavaNioCharsetCharset_(id<JavaNioFilePath> path, JavaNioCharsetCharset *cs);

FOUNDATION_EXPORT JavaIoBufferedReader *JavaNioFileFiles_newBufferedReaderWithJavaNioFilePath_(id<JavaNioFilePath> path);

FOUNDATION_EXPORT JavaIoBufferedWriter *JavaNioFileFiles_newBufferedWriterWithJavaNioFilePath_withJavaNioCharsetCharset_withJavaNioFileOpenOptionArray_(id<JavaNioFilePath> path, JavaNioCharsetCharset *cs, IOSObjectArray *options);

FOUNDATION_EXPORT JavaIoBufferedWriter *JavaNioFileFiles_newBufferedWriterWithJavaNioFilePath_withJavaNioFileOpenOptionArray_(id<JavaNioFilePath> path, IOSObjectArray *options);

FOUNDATION_EXPORT jlong JavaNioFileFiles_copy__WithJavaIoInputStream_withJavaNioFilePath_withJavaNioFileCopyOptionArray_(JavaIoInputStream *inArg, id<JavaNioFilePath> target, IOSObjectArray *options);

FOUNDATION_EXPORT jlong JavaNioFileFiles_copy__WithJavaNioFilePath_withJavaIoOutputStream_(id<JavaNioFilePath> source, JavaIoOutputStream *outArg);

FOUNDATION_EXPORT IOSByteArray *JavaNioFileFiles_readAllBytesWithJavaNioFilePath_(id<JavaNioFilePath> path);

FOUNDATION_EXPORT id<JavaUtilList> JavaNioFileFiles_readAllLinesWithJavaNioFilePath_withJavaNioCharsetCharset_(id<JavaNioFilePath> path, JavaNioCharsetCharset *cs);

FOUNDATION_EXPORT id<JavaUtilList> JavaNioFileFiles_readAllLinesWithJavaNioFilePath_(id<JavaNioFilePath> path);

FOUNDATION_EXPORT id<JavaNioFilePath> JavaNioFileFiles_writeWithJavaNioFilePath_withByteArray_withJavaNioFileOpenOptionArray_(id<JavaNioFilePath> path, IOSByteArray *bytes, IOSObjectArray *options);

FOUNDATION_EXPORT id<JavaNioFilePath> JavaNioFileFiles_writeWithJavaNioFilePath_withJavaLangIterable_withJavaNioCharsetCharset_withJavaNioFileOpenOptionArray_(id<JavaNioFilePath> path, id<JavaLangIterable> lines, JavaNioCharsetCharset *cs, IOSObjectArray *options);

FOUNDATION_EXPORT id<JavaNioFilePath> JavaNioFileFiles_writeWithJavaNioFilePath_withJavaLangIterable_withJavaNioFileOpenOptionArray_(id<JavaNioFilePath> path, id<JavaLangIterable> lines, IOSObjectArray *options);

FOUNDATION_EXPORT id<JavaUtilStreamStream> JavaNioFileFiles_listWithJavaNioFilePath_(id<JavaNioFilePath> dir);

FOUNDATION_EXPORT id<JavaUtilStreamStream> JavaNioFileFiles_walkWithJavaNioFilePath_withInt_withJavaNioFileFileVisitOptionArray_(id<JavaNioFilePath> start, jint maxDepth, IOSObjectArray *options);

FOUNDATION_EXPORT id<JavaUtilStreamStream> JavaNioFileFiles_walkWithJavaNioFilePath_withJavaNioFileFileVisitOptionArray_(id<JavaNioFilePath> start, IOSObjectArray *options);

FOUNDATION_EXPORT id<JavaUtilStreamStream> JavaNioFileFiles_findWithJavaNioFilePath_withInt_withJavaUtilFunctionBiPredicate_withJavaNioFileFileVisitOptionArray_(id<JavaNioFilePath> start, jint maxDepth, id<JavaUtilFunctionBiPredicate> matcher, IOSObjectArray *options);

FOUNDATION_EXPORT id<JavaUtilStreamStream> JavaNioFileFiles_linesWithJavaNioFilePath_withJavaNioCharsetCharset_(id<JavaNioFilePath> path, JavaNioCharsetCharset *cs);

FOUNDATION_EXPORT id<JavaUtilStreamStream> JavaNioFileFiles_linesWithJavaNioFilePath_(id<JavaNioFilePath> path);

J2OBJC_TYPE_LITERAL_HEADER(JavaNioFileFiles)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif
#pragma pop_macro("INCLUDE_ALL_JavaNioFileFiles")
