//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/platform/libcore/ojluni/src/main/java/java/nio/file/FileSystem.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_JavaNioFileFileSystem")
#ifdef RESTRICT_JavaNioFileFileSystem
#define INCLUDE_ALL_JavaNioFileFileSystem 0
#else
#define INCLUDE_ALL_JavaNioFileFileSystem 1
#endif
#undef RESTRICT_JavaNioFileFileSystem

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (JavaNioFileFileSystem_) && (INCLUDE_ALL_JavaNioFileFileSystem || defined(INCLUDE_JavaNioFileFileSystem))
#define JavaNioFileFileSystem_

#define RESTRICT_JavaIoCloseable 1
#define INCLUDE_JavaIoCloseable 1
#include "java/io/Closeable.h"

@class IOSObjectArray;
@class JavaLangBoolean;
@class JavaNioFileAttributeUserPrincipalLookupService;
@class JavaNioFileSpiFileSystemProvider;
@protocol JavaLangIterable;
@protocol JavaNioFilePath;
@protocol JavaNioFilePathMatcher;
@protocol JavaNioFileWatchService;
@protocol JavaUtilSet;

/*!
 @brief Provides an interface to a file system and is the factory for objects to
  access files and other objects in the file system.
 <p> The default file system, obtained by invoking the <code>FileSystems.getDefault</code>
  method, provides access to the file system that is
  accessible to the Java virtual machine. The <code>FileSystems</code> class defines
  methods to create file systems that provide access to other types of (custom)
  file systems. 
 <p> A file system is the factory for several types of objects: 
 <ul>
    <li><p> The <code>getPath</code> method converts a system dependent
      <em>path string</em>, returning a <code>Path</code> object that may be used
      to locate and access a file. </p></li>
    <li><p> The <code>getPathMatcher</code> method is used
      to create a <code>PathMatcher</code> that performs match operations on
      paths. </p></li>
    <li><p> The <code>getFileStores</code> method returns an iterator
      over the underlying <code>file-stores</code>. </p></li>
    <li><p> The <code>getUserPrincipalLookupService</code>
      method returns the <code>UserPrincipalLookupService</code> to lookup users or
      groups by name. </p></li>
    <li><p> The <code>newWatchService</code> method creates a
      <code>WatchService</code> that may be used to watch objects for changes and
      events. </p></li>
  </ul>
  
 <p> File systems vary greatly. In some cases the file system is a single
  hierarchy of files with one top-level root directory. In other cases it may
  have several distinct file hierarchies, each with its own top-level root
  directory. The <code>getRootDirectories</code> method may be
  used to iterate over the root directories in the file system. A file system
  is typically composed of one or more underlying <code>file-stores</code>
  that provide the storage for the files. Theses file stores can also vary in
  the features they support, and the file attributes or <em>meta-data</em> that
  they associate with files. 
 <p> A file system is open upon creation and can be closed by invoking its 
 <code>close</code> method. Once closed, any further attempt to access
  objects in the file system cause <code>ClosedFileSystemException</code> to be
  thrown. File systems created by the default <code>provider</code>
  cannot be closed. 
 <p> A <code>FileSystem</code> can provide read-only or read-write access to the
  file system. Whether or not a file system provides read-only access is
  established when the <code>FileSystem</code> is created and can be tested by invoking
  its <code>isReadOnly</code> method. Attempts to write to file stores
  by means of an object associated with a read-only file system throws <code>ReadOnlyFileSystemException</code>
 .
  
 <p> File systems are safe for use by multiple concurrent threads. The <code>close</code>
  method may be invoked at any time to close a file system but
  whether a file system is <i>asynchronously closeable</i> is provider specific
  and therefore unspecified. In other words, if a thread is accessing an
  object in a file system, and another thread invokes the <code>close</code> method
  then it may require to block until the first operation is complete. Closing
  a file system causes all open channels, watch services, and other <code>closeable</code>
  objects associated with the file system to be closed.
 @since 1.7
 */
@interface JavaNioFileFileSystem : NSObject < JavaIoCloseable >

#pragma mark Public

/*!
 @brief Closes this file system.
 <p> After a file system is closed then all subsequent access to the file
  system, either by methods defined by this class or on objects associated
  with this file system, throw <code>ClosedFileSystemException</code>. If the
  file system is already closed then invoking this method has no effect. 
 <p> Closing a file system will close all open <code>channels</code>
 , <code>directory-streams</code>,
  <code>watch-service</code>, and other closeable objects associated
  with this file system. The <code>default</code> file
  system cannot be closed.
 @throw IOException
 If an I/O error occurs
 @throw UnsupportedOperationException
 Thrown in the case of the default file system
 */
- (void)close;

/*!
 @brief Returns an object to iterate over the underlying file stores.
 <p> The elements of the returned iterator are the <code>FileStores</code>
  for this file system. The order of the elements is
  not defined and the file stores may change during the lifetime of the
  Java virtual machine. When an I/O error occurs, perhaps because a file
  store is not accessible, then it is not returned by the iterator. 
 <p> In the case of the default provider, and a security manager is
  installed, the security manager is invoked to check <code>RuntimePermission</code>
 <code>("getFileStoreAttributes")</code>. If denied, then
  no file stores are returned by the iterator. In addition, the security
  manager's <code>SecurityManager.checkRead(String)</code> method is invoked to
  check read access to the file store's <em>top-most</em> directory. If
  denied, the file store is not returned by the iterator. It is system
  dependent if the permission checks are done when the iterator is obtained
  or during iteration. 
 <p> <b>Usage Example:</b>
  Suppose we want to print the space usage for all file stores: 
 @code

      for (FileStore store: FileSystems.getDefault().getFileStores()) {
          long total = store.getTotalSpace() / 1024;
          long used = (store.getTotalSpace() - store.getUnallocatedSpace()) / 1024;
          long avail = store.getUsableSpace() / 1024;
          System.out.format("%-20s %12d %12d %12d%n", store, total, used, avail);
      } 
  
@endcode
 @return An object to iterate over the backing file stores
 */
- (id<JavaLangIterable>)getFileStores;

/*!
 @brief Converts a path string, or a sequence of strings that when joined form
  a path string, to a <code>Path</code>.If <code>more</code> does not specify any
  elements then the value of the <code>first</code> parameter is the path string
  to convert.
 If <code>more</code> specifies one or more elements then each
  non-empty string, including <code>first</code>, is considered to be a sequence
  of name elements (see <code>Path</code>) and is joined to form a path string.
  The details as to how the Strings are joined is provider specific but
  typically they will be joined using the <code>name-separator</code>
  as the separator. For example, if the name separator is
  "<code>/</code>" and <code>getPath("/foo","bar","gus")</code> is invoked, then the
  path string <code>"/foo/bar/gus"</code> is converted to a <code>Path</code>.
  A <code>Path</code> representing an empty path is returned if <code>first</code>
  is the empty string and <code>more</code> does not contain any non-empty
  strings. 
 <p> The parsing and conversion to a path object is inherently
  implementation dependent. In the simplest case, the path string is rejected,
  and <code>InvalidPathException</code> thrown, if the path string contains
  characters that cannot be converted to characters that are <em>legal</em>
  to the file store. For example, on UNIX systems, the NUL (&#92;u0000)
  character is not allowed to be present in a path. An implementation may
  choose to reject path strings that contain names that are longer than those
  allowed by any file store, and where an implementation supports a complex
  path syntax, it may choose to reject path strings that are <em>badly
  formed</em>.
  
 <p> In the case of the default provider, path strings are parsed based
  on the definition of paths at the platform or virtual file system level.
  For example, an operating system may not allow specific characters to be
  present in a file name, but a specific underlying file store may impose
  different or additional restrictions on the set of legal
  characters. 
 <p> This method throws <code>InvalidPathException</code> when the path string
  cannot be converted to a path. Where possible, and where applicable,
  the exception is created with an <code>index</code>
  value indicating the first position in the <code>path</code> parameter
  that caused the path string to be rejected.
 @param first the path string or initial part of the path string
 @param more additional strings to be joined to form the path string
 @return the resulting <code>Path</code>
 @throw InvalidPathException
 If the path string cannot be converted
 */
- (id<JavaNioFilePath>)getPathWithNSString:(NSString *)first
                         withNSStringArray:(IOSObjectArray *)more;

/*!
 @brief Returns a <code>PathMatcher</code> that performs match operations on the 
 <code>String</code> representation of <code>Path</code> objects by interpreting a
  given pattern.
 The <code>syntaxAndPattern</code> parameter identifies the syntax and the
  pattern and takes the form: 
 <blockquote>@code

   <i>syntax</i><b>:</b><i>pattern</i>
   
@endcode</blockquote>
  where <code>':'</code> stands for itself. 
 <p> A <code>FileSystem</code> implementation supports the "<code>glob</code>" and
  "<code>regex</code>" syntaxes, and may support others. The value of the syntax
  component is compared without regard to case. 
 <p> When the syntax is "<code>glob</code>" then the <code>String</code>
  representation of the path is matched using a limited pattern language
  that resembles regular expressions but with a simpler syntax. For example: 
 <table class="striped" style="text-align:left; margin-left:2em">
  <caption style="display:none">Pattern Language</caption>
  <thead>
  <tr>
    <th scope="col">Example
    <th scope="col">Description
  </tr>
  </thead>
  <tbody>
  <tr>
    <th scope="row"><code>*.java</code></th>
    <td>Matches a path that represents a file name ending in <code>.java</code></td>
  </tr>
  <tr>
    <th scope="row"><code>*.*</code></th>
    <td>Matches file names containing a dot</td>
  </tr>
  <tr>
    <th scope="row"><code>*.{java,class}</code></th>
    <td>Matches file names ending with <code>.java</code> or <code>.class</code></td>
  </tr>
  <tr>
    <th scope="row"><code>foo.?</code></th>
    <td>Matches file names starting with <code>foo.</code> and a single
    character extension</td>
  </tr>
  <tr>
    <th scope="row"><code>&#47;home&#47;*&#47;
 *</code>   <td>Matches <code>&#47;home&#47;gus&#47;data</code></td>
  </tr>
  <tr>
    <th scope="row"><code>&#47;home&#47;
 **</code>   <td>Matches <code>&#47;home&#47;gus</code> and   <code>&#47;home&#47;gus&#47;data</code></td> </tr> </tbody> </table> <p> The following rules are used to interpret glob patterns: <ul>   <li><p> The <code>*</code> character matches zero or more <code>characters</code> of a <code>name</code> component without   crossing directory boundaries. </p></li>   <li><p> The <code>**</code> characters matches zero or more <code>characters</code>
  crossing directory boundaries. </p></li>
    
 <li><p> The <code>?</code> character matches exactly one character of a
    name component.</p></li>
    
 <li><p> The backslash character (<code>\</code>) is used to escape characters
    that would otherwise be interpreted as special characters. The expression   
 <code>\\</code> matches a single backslash and "\{" matches a left brace
    for example.  </p></li>
    
 <li><p> The <code>[ ]</code> characters are a <i>bracket expression</i> that
    match a single character of a name component out of a set of characters.
    For example, <code>[abc]</code> matches <code>"a"</code>, <code>"b"</code>, or <code>"c"</code>.
    The hyphen (<code>-</code>) may be used to specify a range so <code>[a-z]</code>
    specifies a range that matches from <code>"a"</code> to <code>"z"</code> (inclusive).
    These forms can be mixed so [abce-g] matches <code>"a"</code>, <code>"b"</code>,
    <code>"c"</code>, <code>"e"</code>, <code>"f"</code> or <code>"g"</code>. If the character
    after the <code>[</code> is a <code>!</code> then it is used for negation so <code>[!a-c]</code>
  matches any character except <code>"a"</code>, <code>"b"</code>, or <code>"c"</code>
 .
    <p> Within a bracket expression the <code>*</code>, <code>?</code> and <code>\</code>
    characters match themselves. The (<code>-</code>) character matches itself if
    it is the first character within the brackets, or the first character
    after the <code>!</code> if negating.</p></li>
    
 <li><p> The <code>{ }</code> characters are a group of subpatterns, where
    the group matches if any subpattern in the group matches. The <code>","</code>
    character is used to separate the subpatterns. Groups cannot be nested.   
 </p></li>
    
 <li><p> Leading period<code>&#47;</code>dot characters in file name are
    treated as regular characters in match operations. For example,
    the <code>"*"</code> glob pattern matches file name <code>".login"</code>.
    The <code>Files.isHidden</code> method may be used to test whether a file
    is considered hidden.   
 </p></li>
    
 <li><p> All other characters match themselves in an implementation
    dependent manner. This includes characters representing any <code>name-separators</code>
 . </p></li>
    
 <li><p> The matching of <code>root</code> components is highly
    implementation-dependent and is not specified. </p></li>
  
 </ul>
  
 <p> When the syntax is "<code>regex</code>" then the pattern component is a
  regular expression as defined by the <code>java.util.regex.Pattern</code>
  class. 
 <p>  For both the glob and regex syntaxes, the matching details, such as
  whether the matching is case sensitive, are implementation-dependent
  and therefore not specified.
 @param syntaxAndPattern The syntax and pattern
 @return A path matcher that may be used to match paths against the pattern
 @throw IllegalArgumentException
 If the parameter does not take the form: <code>syntax:pattern</code>
 @throw java.util.regex.PatternSyntaxException
 If the pattern is invalid
 @throw UnsupportedOperationException
 If the pattern syntax is not known to the implementation
 - seealso: Files#newDirectoryStream(Path,String)
 */
- (id<JavaNioFilePathMatcher>)getPathMatcherWithNSString:(NSString *)syntaxAndPattern;

/*!
 @brief Returns an object to iterate over the paths of the root directories.
 <p> A file system provides access to a file store that may be composed
  of a number of distinct file hierarchies, each with its own top-level
  root directory. Unless denied by the security manager, each element in
  the returned iterator corresponds to the root directory of a distinct
  file hierarchy. The order of the elements is not defined. The file
  hierarchies may change during the lifetime of the Java virtual machine.
  For example, in some implementations, the insertion of removable media
  may result in the creation of a new file hierarchy with its own
  top-level directory. 
 <p> When a security manager is installed, it is invoked to check access
  to the each root directory. If denied, the root directory is not returned
  by the iterator. In the case of the default provider, the <code>SecurityManager.checkRead(String)</code>
  method is invoked to check read access
  to each root directory. It is system dependent if the permission checks
  are done when the iterator is obtained or during iteration.
 @return An object to iterate over the root directories
 */
- (id<JavaLangIterable>)getRootDirectories;

/*!
 @brief Returns the name separator, represented as a string.
 <p> The name separator is used to separate names in a path string. An
  implementation may support multiple name separators in which case this
  method returns an implementation specific <em>default</em> name separator.
  This separator is used when creating path strings by invoking the <code>toString()</code>
  method. 
 <p> In the case of the default provider, this method returns the same
  separator as <code>java.io.File.separator</code>.
 @return The name separator
 */
- (NSString *)getSeparator;

/*!
 @brief Returns the <code>UserPrincipalLookupService</code> for this file system 
 <i>(optional operation)</i>.The resulting lookup service may be used to
  lookup user or group names.
 <p> <b>Usage Example:</b>
  Suppose we want to make "joe" the owner of a file: 
 @code

      UserPrincipalLookupService lookupService = FileSystems.getDefault().getUserPrincipalLookupService();
      Files.setOwner(path, lookupService.lookupPrincipalByName("joe")); 
  
@endcode
 @throw UnsupportedOperationException
 If this <code>FileSystem</code> does not does have a lookup service
 @return The <code>UserPrincipalLookupService</code> for this file system
 */
- (JavaNioFileAttributeUserPrincipalLookupService *)getUserPrincipalLookupService;

/*!
 @brief Tells whether or not this file system is open.
 <p> File systems created by the default provider are always open.
 @return <code>true</code> if, and only if, this file system is open
 */
- (jboolean)isOpen;

/*!
 @brief Tells whether or not this file system allows only read-only access to
  its file stores.
 @return <code>true</code> if, and only if, this file system provides
           read-only access
 */
- (jboolean)isReadOnly;

/*!
 @brief Constructs a new <code>WatchService</code> <i>(optional operation)</i>.
 <p> This method constructs a new watch service that may be used to watch
  registered objects for changes and events.
 @return a new watch service
 @throw UnsupportedOperationException
 If this <code>FileSystem</code> does not support watching file system
           objects for changes and events. This exception is not thrown
           by <code>FileSystems</code> created by the default provider.
 @throw IOException
 If an I/O error occurs
 */
- (id<JavaNioFileWatchService>)newWatchService OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Returns the provider that created this file system.
 @return The provider that created this file system.
 */
- (JavaNioFileSpiFileSystemProvider *)provider;

/*!
 @brief Returns the set of the <code>names</code> of the file
  attribute views supported by this <code>FileSystem</code>.
 <p> The <code>BasicFileAttributeView</code> is required to be supported and
  therefore the set contains at least one element, "basic". 
 <p> The <code>supportsFileAttributeView(String)</code>
  method may be used to test if an
  underlying <code>FileStore</code> supports the file attributes identified by a
  file attribute view.
 @return An unmodifiable set of the names of the supported file attribute
           views
 */
- (id<JavaUtilSet>)supportedFileAttributeViews;

#pragma mark Protected

/*!
 @brief Initializes a new instance of this class.
 */
- (instancetype __nonnull)init;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaNioFileFileSystem)

FOUNDATION_EXPORT void JavaNioFileFileSystem_init(JavaNioFileFileSystem *self);

J2OBJC_TYPE_LITERAL_HEADER(JavaNioFileFileSystem)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif
#pragma pop_macro("INCLUDE_ALL_JavaNioFileFileSystem")
