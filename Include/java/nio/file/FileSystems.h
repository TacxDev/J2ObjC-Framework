//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/platform/libcore/ojluni/src/main/java/java/nio/file/FileSystems.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_JavaNioFileFileSystems")
#ifdef RESTRICT_JavaNioFileFileSystems
#define INCLUDE_ALL_JavaNioFileFileSystems 0
#else
#define INCLUDE_ALL_JavaNioFileFileSystems 1
#endif
#undef RESTRICT_JavaNioFileFileSystems

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (JavaNioFileFileSystems_) && (INCLUDE_ALL_JavaNioFileFileSystems || defined(INCLUDE_JavaNioFileFileSystems))
#define JavaNioFileFileSystems_

@class JavaLangClassLoader;
@class JavaNetURI;
@class JavaNioFileFileSystem;
@protocol JavaNioFilePath;
@protocol JavaUtilMap;

/*!
 @brief Factory methods for file systems.This class defines the <code>getDefault</code>
  method to get the default file system and factory methods to
  construct other types of file systems.
 <p> The first invocation of any of the methods defined by this class causes
  the default <code>provider</code> to be loaded. The default
  provider, identified by the URI scheme "file", creates the <code>FileSystem</code>
  that provides access to the file systems accessible to the Java virtual
  machine. If the process of loading or initializing the default provider fails
  then an unspecified error is thrown. 
 <p> The first invocation of the <code>installedProviders</code>
  method, by way of invoking any of the <code>newFileSystem</code>
  methods defined by this class, locates and loads all
  installed file system providers. Installed providers are loaded using the
  service-provider loading facility defined by the <code>ServiceLoader</code> class.
  Installed providers are loaded using the system class loader. If the
  system class loader cannot be found then the extension class loader is used;
  if there is no extension class loader then the bootstrap class loader is used.
  Providers are typically installed by placing them in a JAR file on the
  application class path or in the extension directory, the JAR file contains a
  provider-configuration file named <code>java.nio.file.spi.FileSystemProvider</code>
  in the resource directory <code>META-INF/services</code>, and the file lists one or
  more fully-qualified names of concrete subclass of <code>FileSystemProvider</code>
  that have a zero argument constructor.
  The ordering that installed providers are located is implementation specific.
  If a provider is instantiated and its <code>getScheme</code>
  returns the same URI scheme of a provider that was previously
  instantiated then the most recently instantiated duplicate is discarded. URI
  schemes are compared without regard to case. During construction a provider
  may safely access files associated with the default provider but care needs
  to be taken to avoid circular loading of other installed providers. If
  circular loading of installed providers is detected then an unspecified error
  is thrown. 
 <p> This class also defines factory methods that allow a <code>ClassLoader</code>
  to be specified when locating a provider. As with installed providers, the
  provider classes are identified by placing the provider configuration file
  in the resource directory <code>META-INF/services</code>.
  
 <p> If a thread initiates the loading of the installed file system providers
  and another thread invokes a method that also attempts to load the providers
  then the method will block until the loading completes.
 @since 1.7
 */
@interface JavaNioFileFileSystems : NSObject

#pragma mark Public

/*!
 @brief Returns the default <code>FileSystem</code>.The default file system creates
  objects that provide access to the file systems accessible to the Java
  virtual machine.
 The <em>working directory</em> of the file system is
  the current user directory, named by the system property <code>user.dir</code>.
  This allows for interoperability with the <code>java.io.File</code>
  class. 
 <p> The first invocation of any of the methods defined by this class
  locates the default <code>provider</code> object. Where the
  system property <code>java.nio.file.spi.DefaultFileSystemProvider</code> is
  not defined then the default provider is a system-default provider that
  is invoked to create the default file system. 
 <p> If the system property <code>java.nio.file.spi.DefaultFileSystemProvider</code>
  is defined then it is taken to be a list of one or more fully-qualified
  names of concrete provider classes identified by the URI scheme 
 <code>"file"</code>. Where the property is a list of more than one name then
  the names are separated by a comma. Each class is loaded, using the system
  class loader, and instantiated by invoking a one argument constructor
  whose formal parameter type is <code>FileSystemProvider</code>. The providers
  are loaded and instantiated in the order they are listed in the property.
  If this process fails or a provider's scheme is not equal to <code>"file"</code>
  then an unspecified error is thrown. URI schemes are normally compared
  without regard to case but for the default provider, the scheme is
  required to be <code>"file"</code>. The first provider class is instantiated
  by invoking it with a reference to the system-default provider.
  The second provider class is instantiated by invoking it with a reference
  to the first provider instance. The third provider class is instantiated
  by invoking it with a reference to the second instance, and so on. The
  last provider to be instantiated becomes the default provider; its <code>getFileSystem</code>
  method is invoked with the URI <code>"file:///"</code> to
  get a reference to the default file system. 
 <p> Subsequent invocations of this method return the file system that was
  returned by the first invocation.
 @return the default file system
 */
+ (JavaNioFileFileSystem *)getDefault;

/*!
 @brief Returns a reference to an existing <code>FileSystem</code>.
 <p> This method iterates over the <code>installed</code>
  providers to locate the provider that is identified by the URI 
 <code>scheme</code> of the given URI. URI schemes are compared
  without regard to case. The exact form of the URI is highly provider
  dependent. If found, the provider's <code>getFileSystem</code>
  method is invoked to obtain a reference to the <code>FileSystem</code>
 .
  
 <p> Once a file system created by this provider is <code>closed</code>
  it is provider-dependent if this method returns a reference to
  the closed file system or throws <code>FileSystemNotFoundException</code>.
  If the provider allows a new file system to be created with the same URI
  as a file system it previously created then this method throws the
  exception if invoked after the file system is closed (and before a new
  instance is created by the <code>newFileSystem</code> method). 
 <p> If a security manager is installed then a provider implementation
  may require to check a permission before returning a reference to an
  existing file system. In the case of the <code>default</code>
  file system, no permission check is required.
 @param uri the URI to locate the file system
 @return the reference to the file system
 @throw IllegalArgumentException
 if the pre-conditions for the <code>uri</code> parameter are not met
 @throw FileSystemNotFoundException
 if the file system, identified by the URI, does not exist
 @throw ProviderNotFoundException
 if a provider supporting the URI scheme is not installed
 @throw SecurityException
 if a security manager is installed and it denies an unspecified
           permission
 */
+ (JavaNioFileFileSystem *)getFileSystemWithJavaNetURI:(JavaNetURI *)uri;

/*!
 @brief Constructs a new <code>FileSystem</code> to access the contents of a file as a
  file system.
 <p> This method makes use of specialized providers that create pseudo file
  systems where the contents of one or more files is treated as a file
  system. 
 <p> This method iterates over the <code>installed</code>
  providers. It invokes, in turn, each provider's <code>newFileSystem(Path,Map)</code>
  method
  with an empty map. If a provider returns a file system then the iteration
  terminates and the file system is returned. If none of the installed
  providers return a <code>FileSystem</code> then an attempt is made to locate
  the provider using the given class loader. If a provider returns a file
  system then the lookup terminates and the file system is returned.
 @param path the path to the file
 @param loader the class loader to locate the provider or 
 <code>null</code>  to only           attempt to locate an installed provider
 @return a new file system
 @throw ProviderNotFoundException
 if a provider supporting this file type cannot be located
 @throw ServiceConfigurationError
 when an error occurs while loading a service provider
 @throw IOException
 if an I/O error occurs
 @throw SecurityException
 if a security manager is installed and it denies an unspecified
           permission
 */
+ (JavaNioFileFileSystem *)newFileSystemWithJavaNioFilePath:(id<JavaNioFilePath>)path
                                    withJavaLangClassLoader:(JavaLangClassLoader *)loader OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Constructs a new file system that is identified by a <code>URI</code>
  
 <p> This method iterates over the <code>installed</code>
  providers to locate the provider that is identified by the URI 
 <code>scheme</code> of the given URI.
 URI schemes are compared
  without regard to case. The exact form of the URI is highly provider
  dependent. If found, the provider's <code>newFileSystem(URI,Map)</code>
  method is invoked to construct the new file system. 
 <p> Once a file system is <code>closed</code> it is
  provider-dependent if the provider allows a new file system to be created
  with the same URI as a file system it previously created. 
 <p> <b>Usage Example:</b>
  Suppose there is a provider identified by the scheme <code>"memory"</code>
  installed: 
 @code

    Map&lt;String,String&gt; env = new HashMap&lt;&gt;();
    env.put("capacity", "16G");
    env.put("blockSize", "4k");
    FileSystem fs = FileSystems.newFileSystem(URI.create("memory:///?name=logfs"), env); 
  
@endcode
 @param uri the URI identifying the file system
 @param env a map of provider specific properties to configure the file system;
            may be empty
 @return a new file system
 @throw IllegalArgumentException
 if the pre-conditions for the <code>uri</code> parameter are not met,
           or the <code>env</code> parameter does not contain properties required
           by the provider, or a property value is invalid
 @throw FileSystemAlreadyExistsException
 if the file system has already been created
 @throw ProviderNotFoundException
 if a provider supporting the URI scheme is not installed
 @throw IOException
 if an I/O error occurs creating the file system
 @throw SecurityException
 if a security manager is installed and it denies an unspecified
           permission required by the file system provider implementation
 */
+ (JavaNioFileFileSystem *)newFileSystemWithJavaNetURI:(JavaNetURI *)uri
                                       withJavaUtilMap:(id<JavaUtilMap>)env OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Constructs a new file system that is identified by a <code>URI</code>
  
 <p> This method first attempts to locate an installed provider in exactly
  the same manner as the <code>newFileSystem(URI,Map)</code>
  method.
 If none of the installed providers support the URI scheme then an
  attempt is made to locate the provider using the given class loader. If a
  provider supporting the URI scheme is located then its <code>newFileSystem(URI,Map)</code>
  is
  invoked to construct the new file system.
 @param uri the URI identifying the file system
 @param env a map of provider specific properties to configure the file system;
            may be empty
 @param loader the class loader to locate the provider or 
 <code>null</code>  to only           attempt to locate an installed provider
 @return a new file system
 @throw IllegalArgumentException
 if the pre-conditions for the <code>uri</code> parameter are not met,
           or the <code>env</code> parameter does not contain properties required
           by the provider, or a property value is invalid
 @throw FileSystemAlreadyExistsException
 if the URI scheme identifies an installed provider and the file
           system has already been created
 @throw ProviderNotFoundException
 if a provider supporting the URI scheme is not found
 @throw ServiceConfigurationError
 when an error occurs while loading a service provider
 @throw IOException
 an I/O error occurs creating the file system
 @throw SecurityException
 if a security manager is installed and it denies an unspecified
           permission required by the file system provider implementation
 */
+ (JavaNioFileFileSystem *)newFileSystemWithJavaNetURI:(JavaNetURI *)uri
                                       withJavaUtilMap:(id<JavaUtilMap>)env
                               withJavaLangClassLoader:(JavaLangClassLoader *)loader OBJC_METHOD_FAMILY_NONE;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaNioFileFileSystems)

FOUNDATION_EXPORT JavaNioFileFileSystem *JavaNioFileFileSystems_getDefault(void);

FOUNDATION_EXPORT JavaNioFileFileSystem *JavaNioFileFileSystems_getFileSystemWithJavaNetURI_(JavaNetURI *uri);

FOUNDATION_EXPORT JavaNioFileFileSystem *JavaNioFileFileSystems_newFileSystemWithJavaNetURI_withJavaUtilMap_(JavaNetURI *uri, id<JavaUtilMap> env);

FOUNDATION_EXPORT JavaNioFileFileSystem *JavaNioFileFileSystems_newFileSystemWithJavaNetURI_withJavaUtilMap_withJavaLangClassLoader_(JavaNetURI *uri, id<JavaUtilMap> env, JavaLangClassLoader *loader);

FOUNDATION_EXPORT JavaNioFileFileSystem *JavaNioFileFileSystems_newFileSystemWithJavaNioFilePath_withJavaLangClassLoader_(id<JavaNioFilePath> path, JavaLangClassLoader *loader);

J2OBJC_TYPE_LITERAL_HEADER(JavaNioFileFileSystems)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif
#pragma pop_macro("INCLUDE_ALL_JavaNioFileFileSystems")
