//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/platform/libcore/ojluni/src/main/java/java/nio/file/spi/FileSystemProvider.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_JavaNioFileSpiFileSystemProvider")
#ifdef RESTRICT_JavaNioFileSpiFileSystemProvider
#define INCLUDE_ALL_JavaNioFileSpiFileSystemProvider 0
#else
#define INCLUDE_ALL_JavaNioFileSpiFileSystemProvider 1
#endif
#undef RESTRICT_JavaNioFileSpiFileSystemProvider

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (JavaNioFileSpiFileSystemProvider_) && (INCLUDE_ALL_JavaNioFileSpiFileSystemProvider || defined(INCLUDE_JavaNioFileSpiFileSystemProvider))
#define JavaNioFileSpiFileSystemProvider_

@class IOSClass;
@class IOSObjectArray;
@class JavaIoInputStream;
@class JavaIoOutputStream;
@class JavaLangBoolean;
@class JavaNetURI;
@class JavaNioChannelsAsynchronousFileChannel;
@class JavaNioChannelsFileChannel;
@class JavaNioFileFileStore;
@class JavaNioFileFileSystem;
@protocol JavaNioChannelsSeekableByteChannel;
@protocol JavaNioFileAttributeBasicFileAttributes;
@protocol JavaNioFileAttributeFileAttributeView;
@protocol JavaNioFileDirectoryStream;
@protocol JavaNioFileDirectoryStream_Filter;
@protocol JavaNioFilePath;
@protocol JavaUtilConcurrentExecutorService;
@protocol JavaUtilList;
@protocol JavaUtilMap;
@protocol JavaUtilSet;

/*!
 @brief Service-provider class for file systems.The methods defined by the <code>java.nio.file.Files</code>
  class will typically delegate to an instance of this
  class.
 <p> A file system provider is a concrete implementation of this class that
  implements the abstract methods defined by this class. A provider is
  identified by a <code>URI</code> <code>scheme</code>. The default provider
  is identified by the URI scheme "file". It creates the <code>FileSystem</code> that
  provides access to the file systems accessible to the Java virtual machine.
  The <code>FileSystems</code> class defines how file system providers are located
  and loaded. The default provider is typically a system-default provider but
  may be overridden if the system property <code>java.nio.file.spi.DefaultFileSystemProvider</code>
  is set. In that case, the
  provider has a one argument constructor whose formal parameter type is <code>FileSystemProvider</code>
 . All other providers have a zero argument constructor
  that initializes the provider. 
 <p> A provider is a factory for one or more <code>FileSystem</code> instances. Each
  file system is identified by a <code>URI</code> where the URI's scheme matches
  the provider's <code>scheme</code>. The default file system, for example,
  is identified by the URI <code>"file:///"</code>. A memory-based file system,
  for example, may be identified by a URI such as <code>"memory:///?name=logfs"</code>.
  The <code>newFileSystem</code> method may be used to create a file
  system, and the <code>getFileSystem</code> method may be used to
  obtain a reference to an existing file system created by the provider. Where
  a provider is the factory for a single file system then it is provider dependent
  if the file system is created when the provider is initialized, or later when the 
 <code>newFileSystem</code> method is invoked. In the case of the default
  provider, the <code>FileSystem</code> is created when the provider is initialized. 
 <p> All of the methods in this class are safe for use by multiple concurrent
  threads.
 @since 1.7
 */
@interface JavaNioFileSpiFileSystemProvider : NSObject

#pragma mark Public

/*!
 @brief Checks the existence, and optionally the accessibility, of a file.
 <p> This method may be used by the <code>isReadable</code>,
  <code>isWritable</code> and <code>isExecutable</code>
  methods to check the accessibility of a file. 
 <p> This method checks the existence of a file and that this Java virtual
  machine has appropriate privileges that would allow it access the file
  according to all of access modes specified in the <code>modes</code> parameter
  as follows: 
 <table border=1 cellpadding=5 summary="">
  <tr> <th>Value</th> <th>Description</th> </tr>
  <tr>
    <td> <code>READ</code> </td>
    <td> Checks that the file exists and that the Java virtual machine has
      permission to read the file. </td>
  </tr>
  <tr>
    <td> <code>WRITE</code> </td>
    <td> Checks that the file exists and that the Java virtual machine has
      permission to write to the file, </td>
  </tr>
  <tr>
    <td> <code>EXECUTE</code> </td>
    <td> Checks that the file exists and that the Java virtual machine has
      permission to <code>execute</code> the file. The semantics
      may differ when checking access to a directory. For example, on UNIX
      systems, checking for <code>EXECUTE</code> access checks that the Java
      virtual machine has permission to search the directory in order to
      access file or subdirectories. </td>
  </tr>
  </table>
  
 <p> If the <code>modes</code> parameter is of length zero, then the existence
  of the file is checked. 
 <p> This method follows symbolic links if the file referenced by this
  object is a symbolic link. Depending on the implementation, this method
  may require to read file permissions, access control lists, or other
  file attributes in order to check the effective access to the file. To
  determine the effective access to a file may require access to several
  attributes and so in some implementations this method may not be atomic
  with respect to other file system operations.
 @param path the path to the file to check
 @param modes The access modes to check; may have zero elements
 @throw UnsupportedOperationException
 an implementation is required to support checking for
           <code>READ</code>, <code>WRITE</code>, and <code>EXECUTE</code> access. This
           exception is specified to allow for the <code>Access</code> enum to
           be extended in future releases.
 @throw NoSuchFileException
 if a file does not exist <i>(optional specific exception)</i>
 @throw AccessDeniedException
 the requested access would be denied or the access cannot be
           determined because the Java virtual machine has insufficient
           privileges or other reasons. <i>(optional specific exception)</i>
 @throw IOException
 if an I/O error occurs
 @throw SecurityException
 In the case of the default provider, and a security manager is
           installed, the <code>checkRead</code>
           is invoked when checking read access to the file or only the
           existence of the file, the <code>checkWrite</code>
  is invoked when checking write access to the file,
           and <code>checkExec</code> is invoked
           when checking execute access.
 */
- (void)checkAccessWithJavaNioFilePath:(id<JavaNioFilePath>)path
        withJavaNioFileAccessModeArray:(IOSObjectArray *)modes;

/*!
 @brief Copy a file to a target file.This method works in exactly the manner
  specified by the <code>Files.copy(Path,Path,CopyOption[])</code> method
  except that both the source and target paths must be associated with
  this provider.
 @param source the path to the file to copy
 @param target the path to the target file
 @param options options specifying how the copy should be done
 @throw UnsupportedOperationException
 if the array contains a copy option that is not supported
 @throw FileAlreadyExistsException
 if the target file exists but cannot be replaced because the
           <code>REPLACE_EXISTING</code> option is not specified <i>(optional
           specific exception)</i>
 @throw DirectoryNotEmptyException
 the <code>REPLACE_EXISTING</code> option is specified but the file
           cannot be replaced because it is a non-empty directory          
 <i>(optional specific exception)</i>
 @throw IOException
 if an I/O error occurs
 @throw SecurityException
 In the case of the default provider, and a security manager is
           installed, the <code>checkRead</code>
           method is invoked to check read access to the source file, the          
 <code>checkWrite</code> is invoked
           to check write access to the target file. If a symbolic link is
           copied the security manager is invoked to check <code>LinkPermission</code>
 <code>("symbolic")</code>.
 */
- (void)copy__WithJavaNioFilePath:(id<JavaNioFilePath>)source
              withJavaNioFilePath:(id<JavaNioFilePath>)target
   withJavaNioFileCopyOptionArray:(IOSObjectArray *)options OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Creates a new directory.This method works in exactly the manner
  specified by the <code>Files.createDirectory</code> method.
 @param dir the directory to create
 @param attrs an optional list of file attributes to set atomically when
            creating the directory
 @throw UnsupportedOperationException
 if the array contains an attribute that cannot be set atomically
           when creating the directory
 @throw FileAlreadyExistsException
 if a directory could not otherwise be created because a file of
           that name already exists <i>(optional specific exception)</i>
 @throw IOException
 if an I/O error occurs or the parent directory does not exist
 @throw SecurityException
 In the case of the default provider, and a security manager is
           installed, the <code>checkWrite</code>
           method is invoked to check write access to the new directory.
 */
- (void)createDirectoryWithJavaNioFilePath:(id<JavaNioFilePath>)dir
withJavaNioFileAttributeFileAttributeArray:(IOSObjectArray *)attrs;

/*!
 @brief Creates a new link (directory entry) for an existing file.This method
  works in exactly the manner specified by the <code>Files.createLink</code>
  method.
 <p> The default implementation of this method throws <code>UnsupportedOperationException</code>
 .
 @param link the link (directory entry) to create
 @param existing a path to an existing file
 @throw UnsupportedOperationException
 if the implementation does not support adding an existing file
           to a directory
 @throw FileAlreadyExistsException
 if the entry could not otherwise be created because a file of
           that name already exists <i>(optional specific exception)</i>
 @throw IOException
 if an I/O error occurs
 @throw SecurityException
 In the case of the default provider, and a security manager
           is installed, it denies <code>LinkPermission</code><tt>("hard")</tt>
           or its <code>checkWrite</code>
           method denies write access to either the  link or the
           existing file.
 */
- (void)createLinkWithJavaNioFilePath:(id<JavaNioFilePath>)link
                  withJavaNioFilePath:(id<JavaNioFilePath>)existing;

/*!
 @brief Creates a symbolic link to a target.This method works in exactly the
  manner specified by the <code>Files.createSymbolicLink</code> method.
 <p> The default implementation of this method throws <code>UnsupportedOperationException</code>
 .
 @param link the path of the symbolic link to create
 @param target the target of the symbolic link
 @param attrs the array of attributes to set atomically when creating the
            symbolic link
 @throw UnsupportedOperationException
 if the implementation does not support symbolic links or the
           array contains an attribute that cannot be set atomically when
           creating the symbolic link
 @throw FileAlreadyExistsException
 if a file with the name already exists <i>(optional specific
           exception)</i>
 @throw IOException
 if an I/O error occurs
 @throw SecurityException
 In the case of the default provider, and a security manager
           is installed, it denies <code>LinkPermission</code><tt>("symbolic")</tt>
           or its <code>checkWrite</code>
           method denies write access to the path of the symbolic link.
 */
- (void)createSymbolicLinkWithJavaNioFilePath:(id<JavaNioFilePath>)link
                          withJavaNioFilePath:(id<JavaNioFilePath>)target
   withJavaNioFileAttributeFileAttributeArray:(IOSObjectArray *)attrs;

/*!
 @brief Deletes a file.This method works in exactly the  manner specified by the 
 <code>Files.delete</code> method.
 @param path the path to the file to delete
 @throw NoSuchFileException
 if the file does not exist <i>(optional specific exception)</i>
 @throw DirectoryNotEmptyException
 if the file is a directory and could not otherwise be deleted
           because the directory is not empty <i>(optional specific
           exception)</i>
 @throw IOException
 if an I/O error occurs
 @throw SecurityException
 In the case of the default provider, and a security manager is
           installed, the <code>SecurityManager.checkDelete(String)</code> method
           is invoked to check delete access to the file
 */
- (void)delete__WithJavaNioFilePath:(id<JavaNioFilePath>)path;

/*!
 @brief Deletes a file if it exists.This method works in exactly the manner
  specified by the <code>Files.deleteIfExists</code> method.
 <p> The default implementation of this method simply invokes <code>delete</code>
  ignoring the <code>NoSuchFileException</code> when the file does not
  exist. It may be overridden where appropriate.
 @param path the path to the file to delete
 @return <code>true</code> if the file was deleted by this method; <code>false</code>
  if the file could not be deleted because it did not
           exist
 @throw DirectoryNotEmptyException
 if the file is a directory and could not otherwise be deleted
           because the directory is not empty <i>(optional specific
           exception)</i>
 @throw IOException
 if an I/O error occurs
 @throw SecurityException
 In the case of the default provider, and a security manager is
           installed, the <code>SecurityManager.checkDelete(String)</code> method
           is invoked to check delete access to the file
 */
- (jboolean)deleteIfExistsWithJavaNioFilePath:(id<JavaNioFilePath>)path;

/*!
 @brief Returns a file attribute view of a given type.This method works in
  exactly the manner specified by the <code>Files.getFileAttributeView</code>
  method.
 @param path the path to the file
 @param type the 
 <code>Class</code>  object corresponding to the file attribute view
 @param options options indicating how symbolic links are handled
 @return a file attribute view of the specified type, or <code>null</code> if
           the attribute view type is not available
 */
- (id<JavaNioFileAttributeFileAttributeView>)getFileAttributeViewWithJavaNioFilePath:(id<JavaNioFilePath>)path
                                                                        withIOSClass:(IOSClass *)type
                                                      withJavaNioFileLinkOptionArray:(IOSObjectArray *)options;

/*!
 @brief Returns the <code>FileStore</code> representing the file store where a file
  is located.This method works in exactly the manner specified by the 
 <code>Files.getFileStore</code> method.
 @param path the path to the file
 @return the file store where the file is stored
 @throw IOException
 if an I/O error occurs
 @throw SecurityException
 In the case of the default provider, and a security manager is
           installed, the <code>checkRead</code>
           method is invoked to check read access to the file, and in
           addition it checks <code>RuntimePermission</code><tt>
           ("getFileStoreAttributes")</tt>
 */
- (JavaNioFileFileStore *)getFileStoreWithJavaNioFilePath:(id<JavaNioFilePath>)path;

/*!
 @brief Returns an existing <code>FileSystem</code> created by this provider.
 <p> This method returns a reference to a <code>FileSystem</code> that was
  created by invoking the <code>newFileSystem(URI,Map)</code>
  method. File systems created the <code>newFileSystem(Path,Map)</code>
  method are not returned by this method.
  The file system is identified by its <code>URI</code>. Its exact form
  is highly provider dependent. In the case of the default provider the URI's
  path component is <code>"/"</code> and the authority, query and fragment components
  are undefined (Undefined components are represented by <code>null</code>).
  
 <p> Once a file system created by this provider is <code>closed</code>
  it is provider-dependent if this
  method returns a reference to the closed file system or throws <code>FileSystemNotFoundException</code>
 . If the provider allows a new file system to
  be created with the same URI as a file system it previously created then
  this method throws the exception if invoked after the file system is
  closed (and before a new instance is created by the <code>newFileSystem</code>
  method). 
 <p> If a security manager is installed then a provider implementation
  may require to check a permission before returning a reference to an
  existing file system. In the case of the <code>default</code>
  file system, no permission check is required.
 @param uri URI reference
 @return The file system
 @throw IllegalArgumentException
 If the pre-conditions for the <code>uri</code> parameter aren't met
 @throw FileSystemNotFoundException
 If the file system does not exist
 @throw SecurityException
 If a security manager is installed and it denies an unspecified
           permission.
 */
- (JavaNioFileFileSystem *)getFileSystemWithJavaNetURI:(JavaNetURI *)uri;

/*!
 @brief Return a <code>Path</code> object by converting the given <code>URI</code>.The
  resulting <code>Path</code> is associated with a <code>FileSystem</code> that
  already exists or is constructed automatically.
 <p> The exact form of the URI is file system provider dependent. In the
  case of the default provider, the URI scheme is <code>"file"</code> and the
  given URI has a non-empty path component, and undefined query, and
  fragment components. The resulting <code>Path</code> is associated with the
  default <code>default</code> <code>FileSystem</code>.
  
 <p> If a security manager is installed then a provider implementation
  may require to check a permission. In the case of the <code>default</code>
  file system, no permission check is
  required.
 @param uri The URI to convert
 @return The resulting <code>Path</code>
 @throw IllegalArgumentException
 If the URI scheme does not identify this provider or other
           preconditions on the uri parameter do not hold
 @throw FileSystemNotFoundException
 The file system, identified by the URI, does not exist and
           cannot be created automatically
 @throw SecurityException
 If a security manager is installed and it denies an unspecified
           permission.
 */
- (id<JavaNioFilePath>)getPathWithJavaNetURI:(JavaNetURI *)uri;

/*!
 @brief Returns the URI scheme that identifies this provider.
 @return The URI scheme
 */
- (NSString *)getScheme;

/*!
 @brief Returns a list of the installed file system providers.
 <p> The first invocation of this method causes the default provider to be
  initialized (if not already initialized) and loads any other installed
  providers as described by the <code>FileSystems</code> class.
 @return An unmodifiable list of the installed file system providers. The
           list contains at least one element, that is the default file
           system provider
 @throw ServiceConfigurationError
 When an error occurs while loading a service provider
 */
+ (id<JavaUtilList>)installedProviders;

/*!
 @brief Tells whether or not a file is considered <em>hidden</em>.This method
  works in exactly the manner specified by the <code>Files.isHidden</code>
  method.
 <p> This method is invoked by the <code>isHidden</code> method.
 @param path the path to the file to test
 @return <code>true</code> if the file is considered hidden
 @throw IOException
 if an I/O error occurs
 @throw SecurityException
 In the case of the default provider, and a security manager is
           installed, the <code>checkRead</code>
           method is invoked to check read access to the file.
 */
- (jboolean)isHiddenWithJavaNioFilePath:(id<JavaNioFilePath>)path;

/*!
 @brief Tests if two paths locate the same file.This method works in exactly the
  manner specified by the <code>Files.isSameFile</code> method.
 @param path one path to the file
 @param path2 the other path
 @return <code>true</code> if, and only if, the two paths locate the same file
 @throw IOException
 if an I/O error occurs
 @throw SecurityException
 In the case of the default provider, and a security manager is
           installed, the <code>checkRead</code>
           method is invoked to check read access to both files.
 */
- (jboolean)isSameFileWithJavaNioFilePath:(id<JavaNioFilePath>)path
                      withJavaNioFilePath:(id<JavaNioFilePath>)path2;

/*!
 @brief Move or rename a file to a target file.This method works in exactly the
  manner specified by the <code>Files.move</code> method except that both the
  source and target paths must be associated with this provider.
 @param source the path to the file to move
 @param target the path to the target file
 @param options options specifying how the move should be done
 @throw UnsupportedOperationException
 if the array contains a copy option that is not supported
 @throw FileAlreadyExistsException
 if the target file exists but cannot be replaced because the
           <code>REPLACE_EXISTING</code> option is not specified <i>(optional
           specific exception)</i>
 @throw DirectoryNotEmptyException
 the <code>REPLACE_EXISTING</code> option is specified but the file
           cannot be replaced because it is a non-empty directory          
 <i>(optional specific exception)</i>
 @throw AtomicMoveNotSupportedException
 if the options array contains the <code>ATOMIC_MOVE</code> option but
           the file cannot be moved as an atomic file system operation.
 @throw IOException
 if an I/O error occurs
 @throw SecurityException
 In the case of the default provider, and a security manager is
           installed, the <code>checkWrite</code>
           method is invoked to check write access to both the source and
           target file.
 */
- (void)moveWithJavaNioFilePath:(id<JavaNioFilePath>)source
            withJavaNioFilePath:(id<JavaNioFilePath>)target
 withJavaNioFileCopyOptionArray:(IOSObjectArray *)options;

/*!
 @brief Opens or creates a file for reading and/or writing, returning an
  asynchronous file channel to access the file.This method works in
  exactly the manner specified by the <code>AsynchronousFileChannel.open</code>
  method.
 A provider that does not support all the features required to construct
  an asynchronous file channel throws <code>UnsupportedOperationException</code>.
  The default provider is required to support the creation of asynchronous
  file channels. When not overridden, the default implementation of this
  method throws <code>UnsupportedOperationException</code>.
 @param path the path of the file to open or create
 @param options options specifying how the file is opened
 @param executor the thread pool or 
 <code>null</code>  to associate the channel with           the default thread pool
 @param attrs an optional list of file attributes to set atomically when
            creating the file
 @return a new asynchronous file channel
 @throw IllegalArgumentException
 If the set contains an invalid combination of options
 @throw UnsupportedOperationException
 If this provider that does not support creating asynchronous file
           channels, or an unsupported open option or file attribute is
           specified
 @throw IOException
 If an I/O error occurs
 @throw SecurityException
 In the case of the default file system, the <code>SecurityManager.checkRead(String)</code>
  method is invoked to check
           read access if the file is opened for reading. The <code>SecurityManager.checkWrite(String)</code>
  method is invoked to check
           write access if the file is opened for writing
 */
- (JavaNioChannelsAsynchronousFileChannel *)newAsynchronousFileChannelWithJavaNioFilePath:(id<JavaNioFilePath>)path
                                                                          withJavaUtilSet:(id<JavaUtilSet>)options
                                                    withJavaUtilConcurrentExecutorService:(id<JavaUtilConcurrentExecutorService>)executor
                                               withJavaNioFileAttributeFileAttributeArray:(IOSObjectArray *)attrs OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Opens or creates a file, returning a seekable byte channel to access the
  file.This method works in exactly the manner specified by the <code>Files.newByteChannel(Path,Set,FileAttribute[])</code>
  method.
 @param path the path to the file to open or create
 @param options options specifying how the file is opened
 @param attrs an optional list of file attributes to set atomically when
            creating the file
 @return a new seekable byte channel
 @throw IllegalArgumentException
 if the set contains an invalid combination of options
 @throw UnsupportedOperationException
 if an unsupported open option is specified or the array contains
           attributes that cannot be set atomically when creating the file
 @throw FileAlreadyExistsException
 if a file of that name already exists and the <code>CREATE_NEW</code>
  option is specified
           <i>(optional specific exception)</i>
 @throw IOException
 if an I/O error occurs
 @throw SecurityException
 In the case of the default provider, and a security manager is
           installed, the <code>checkRead</code>
           method is invoked to check read access to the path if the file is
           opened for reading. The <code>checkWrite</code>
  method is invoked to check write access to the path
           if the file is opened for writing. The <code>checkDelete</code>
  method is
           invoked to check delete access if the file is opened with the          
 <code>DELETE_ON_CLOSE</code> option.
 */
- (id<JavaNioChannelsSeekableByteChannel>)newByteChannelWithJavaNioFilePath:(id<JavaNioFilePath>)path
                                                            withJavaUtilSet:(id<JavaUtilSet>)options
                                 withJavaNioFileAttributeFileAttributeArray:(IOSObjectArray *)attrs OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Opens a directory, returning a <code>DirectoryStream</code> to iterate over
  the entries in the directory.This method works in exactly the manner
  specified by the <code>Files.newDirectoryStream(java.nio.file.Path, java.nio.file.DirectoryStream.Filter)</code>
  method.
 @param dir the path to the directory
 @param filter the directory stream filter
 @return a new and open <code>DirectoryStream</code> object
 @throw NotDirectoryException
 if the file could not otherwise be opened because it is not
           a directory <i>(optional specific exception)</i>
 @throw IOException
 if an I/O error occurs
 @throw SecurityException
 In the case of the default provider, and a security manager is
           installed, the <code>checkRead</code>
           method is invoked to check read access to the directory.
 */
- (id<JavaNioFileDirectoryStream>)newDirectoryStreamWithJavaNioFilePath:(id<JavaNioFilePath>)dir
                                  withJavaNioFileDirectoryStream_Filter:(id<JavaNioFileDirectoryStream_Filter>)filter OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Opens or creates a file for reading and/or writing, returning a file
  channel to access the file.This method works in exactly the manner
  specified by the <code>FileChannel.open</code>
  method.
 A provider that does not support all the
  features required to construct a file channel throws <code>UnsupportedOperationException</code>
 . The default provider is required to
  support the creation of file channels. When not overridden, the default
  implementation throws <code>UnsupportedOperationException</code>.
 @param path the path of the file to open or create
 @param options options specifying how the file is opened
 @param attrs an optional list of file attributes to set atomically when
            creating the file
 @return a new file channel
 @throw IllegalArgumentException
 If the set contains an invalid combination of options
 @throw UnsupportedOperationException
 If this provider that does not support creating file channels,
           or an unsupported open option or file attribute is specified
 @throw IOException
 If an I/O error occurs
 @throw SecurityException
 In the case of the default file system, the <code>SecurityManager.checkRead(String)</code>
  method is invoked to check
           read access if the file is opened for reading. The <code>SecurityManager.checkWrite(String)</code>
  method is invoked to check
           write access if the file is opened for writing
 */
- (JavaNioChannelsFileChannel *)newFileChannelWithJavaNioFilePath:(id<JavaNioFilePath>)path
                                                  withJavaUtilSet:(id<JavaUtilSet>)options
                       withJavaNioFileAttributeFileAttributeArray:(IOSObjectArray *)attrs OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Constructs a new <code>FileSystem</code> to access the contents of a file as a
  file system.
 <p> This method is intended for specialized providers of pseudo file
  systems where the contents of one or more files is treated as a file
  system. The <code>env</code> parameter is a map of provider specific properties
  to configure the file system. 
 <p> If this provider does not support the creation of such file systems
  or if the provider does not recognize the file type of the given file then
  it throws <code>UnsupportedOperationException</code>. The default implementation
  of this method throws <code>UnsupportedOperationException</code>.
 @param path The path to the file
 @param env A map of provider specific properties to configure the file system;
            may be empty
 @return A new file system
 @throw UnsupportedOperationException
 If this provider does not support access to the contents as a
           file system or it does not recognize the file type of the
           given file
 @throw IllegalArgumentException
 If the <code>env</code> parameter does not contain properties required
           by the provider, or a property value is invalid
 @throw IOException
 If an I/O error occurs
 @throw SecurityException
 If a security manager is installed and it denies an unspecified
           permission.
 */
- (JavaNioFileFileSystem *)newFileSystemWithJavaNioFilePath:(id<JavaNioFilePath>)path
                                            withJavaUtilMap:(id<JavaUtilMap>)env OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Constructs a new <code>FileSystem</code> object identified by a URI.This
  method is invoked by the <code>FileSystems.newFileSystem(URI,Map)</code>
  method to open a new file system identified by a URI.
 <p> The <code>uri</code> parameter is an absolute, hierarchical URI, with a
  scheme equal (without regard to case) to the scheme supported by this
  provider. The exact form of the URI is highly provider dependent. The 
 <code>env</code> parameter is a map of provider specific properties to configure
  the file system. 
 <p> This method throws <code>FileSystemAlreadyExistsException</code> if the
  file system already exists because it was previously created by an
  invocation of this method. Once a file system is <code>closed</code>
  it is provider-dependent if the
  provider allows a new file system to be created with the same URI as a
  file system it previously created.
 @param uri URI reference
 @param env A map of provider specific properties to configure the file system;
            may be empty
 @return A new file system
 @throw IllegalArgumentException
 If the pre-conditions for the <code>uri</code> parameter aren't met,
           or the <code>env</code> parameter does not contain properties required
           by the provider, or a property value is invalid
 @throw IOException
 An I/O error occurs creating the file system
 @throw SecurityException
 If a security manager is installed and it denies an unspecified
           permission required by the file system provider implementation
 @throw FileSystemAlreadyExistsException
 If the file system has already been created
 */
- (JavaNioFileFileSystem *)newFileSystemWithJavaNetURI:(JavaNetURI *)uri
                                       withJavaUtilMap:(id<JavaUtilMap>)env OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Opens a file, returning an input stream to read from the file.This
  method works in exactly the manner specified by the <code>Files.newInputStream</code>
  method.
 <p> The default implementation of this method opens a channel to the file
  as if by invoking the <code>newByteChannel</code> method and constructs a
  stream that reads bytes from the channel. This method should be overridden
  where appropriate.
 @param path the path to the file to open
 @param options options specifying how the file is opened
 @return a new input stream
 @throw IllegalArgumentException
 if an invalid combination of options is specified
 @throw UnsupportedOperationException
 if an unsupported option is specified
 @throw IOException
 if an I/O error occurs
 @throw SecurityException
 In the case of the default provider, and a security manager is
           installed, the <code>checkRead</code>
           method is invoked to check read access to the file.
 */
- (JavaIoInputStream *)newInputStreamWithJavaNioFilePath:(id<JavaNioFilePath>)path
                          withJavaNioFileOpenOptionArray:(IOSObjectArray *)options OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Opens or creates a file, returning an output stream that may be used to
  write bytes to the file.This method works in exactly the manner
  specified by the <code>Files.newOutputStream</code> method.
 <p> The default implementation of this method opens a channel to the file
  as if by invoking the <code>newByteChannel</code> method and constructs a
  stream that writes bytes to the channel. This method should be overridden
  where appropriate.
 @param path the path to the file to open or create
 @param options options specifying how the file is opened
 @return a new output stream
 @throw IllegalArgumentException
 if <code>options</code> contains an invalid combination of options
 @throw UnsupportedOperationException
 if an unsupported option is specified
 @throw IOException
 if an I/O error occurs
 @throw SecurityException
 In the case of the default provider, and a security manager is
           installed, the <code>checkWrite</code>
           method is invoked to check write access to the file. The <code>checkDelete</code>
  method is
           invoked to check delete access if the file is opened with the          
 <code>DELETE_ON_CLOSE</code> option.
 */
- (JavaIoOutputStream *)newOutputStreamWithJavaNioFilePath:(id<JavaNioFilePath>)path
                            withJavaNioFileOpenOptionArray:(IOSObjectArray *)options OBJC_METHOD_FAMILY_NONE;

/*!
 @brief Reads a file's attributes as a bulk operation.This method works in
  exactly the manner specified by the <code>Files.readAttributes(Path,Class,LinkOption[])</code>
  method.
 @param path the path to the file
 @param type the 
 <code>Class</code>  of the file attributes required           to read
 @param options options indicating how symbolic links are handled
 @return the file attributes
 @throw UnsupportedOperationException
 if an attributes of the given type are not supported
 @throw IOException
 if an I/O error occurs
 @throw SecurityException
 In the case of the default provider, a security manager is
           installed, its <code>checkRead</code>
           method is invoked to check read access to the file
 */
- (id<JavaNioFileAttributeBasicFileAttributes>)readAttributesWithJavaNioFilePath:(id<JavaNioFilePath>)path
                                                                    withIOSClass:(IOSClass *)type
                                                  withJavaNioFileLinkOptionArray:(IOSObjectArray *)options;

/*!
 @brief Reads a set of file attributes as a bulk operation.This method works in
  exactly the manner specified by the <code>Files.readAttributes(Path,String,LinkOption[])</code>
  method.
 @param path the path to the file
 @param attributes the attributes to read
 @param options options indicating how symbolic links are handled
 @return a map of the attributes returned; may be empty. The map's keys
           are the attribute names, its values are the attribute values
 @throw UnsupportedOperationException
 if the attribute view is not available
 @throw IllegalArgumentException
 if no attributes are specified or an unrecognized attributes is
           specified
 @throw IOException
 If an I/O error occurs
 @throw SecurityException
 In the case of the default provider, and a security manager is
           installed, its <code>checkRead</code>
           method denies read access to the file. If this method is invoked
           to read security sensitive attributes then the security manager
           may be invoke to check for additional permissions.
 */
- (id<JavaUtilMap>)readAttributesWithJavaNioFilePath:(id<JavaNioFilePath>)path
                                        withNSString:(NSString *)attributes
                      withJavaNioFileLinkOptionArray:(IOSObjectArray *)options;

/*!
 @brief Reads the target of a symbolic link.This method works in exactly the
  manner specified by the <code>Files.readSymbolicLink</code> method.
 <p> The default implementation of this method throws <code>UnsupportedOperationException</code>
 .
 @param link the path to the symbolic link
 @return The target of the symbolic link
 @throw UnsupportedOperationException
 if the implementation does not support symbolic links
 @throw NotLinkException
 if the target could otherwise not be read because the file
           is not a symbolic link <i>(optional specific exception)</i>
 @throw IOException
 if an I/O error occurs
 @throw SecurityException
 In the case of the default provider, and a security manager
           is installed, it checks that <code>FilePermission</code> has been
           granted with the "<code>readlink</code>" action to read the link.
 */
- (id<JavaNioFilePath>)readSymbolicLinkWithJavaNioFilePath:(id<JavaNioFilePath>)link;

/*!
 @brief Sets the value of a file attribute.This method works in exactly the
  manner specified by the <code>Files.setAttribute</code> method.
 @param path the path to the file
 @param attribute the attribute to set
 @param value the attribute value
 @param options options indicating how symbolic links are handled
 @throw UnsupportedOperationException
 if the attribute view is not available
 @throw IllegalArgumentException
 if the attribute name is not specified, or is not recognized, or
           the attribute value is of the correct type but has an
           inappropriate value
 @throw ClassCastException
 If the attribute value is not of the expected type or is a
           collection containing elements that are not of the expected
           type
 @throw IOException
 If an I/O error occurs
 @throw SecurityException
 In the case of the default provider, and a security manager is
           installed, its <code>checkWrite</code>
           method denies write access to the file. If this method is invoked
           to set security sensitive attributes then the security manager
           may be invoked to check for additional permissions.
 */
- (void)setAttributeWithJavaNioFilePath:(id<JavaNioFilePath>)path
                           withNSString:(NSString *)attribute
                                 withId:(id)value
         withJavaNioFileLinkOptionArray:(IOSObjectArray *)options;

#pragma mark Protected

/*!
 @brief Initializes a new instance of this class.
 <p> During construction a provider may safely access files associated
  with the default provider but care needs to be taken to avoid circular
  loading of other installed providers. If circular loading of installed
  providers is detected then an unspecified error is thrown.
 @throw SecurityException
 If a security manager has been installed and it denies
           <code>RuntimePermission</code><tt>("fileSystemProvider")</tt>
 */
- (instancetype __nonnull)init;

@end

J2OBJC_STATIC_INIT(JavaNioFileSpiFileSystemProvider)

FOUNDATION_EXPORT void JavaNioFileSpiFileSystemProvider_init(JavaNioFileSpiFileSystemProvider *self);

FOUNDATION_EXPORT id<JavaUtilList> JavaNioFileSpiFileSystemProvider_installedProviders(void);

J2OBJC_TYPE_LITERAL_HEADER(JavaNioFileSpiFileSystemProvider)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif
#pragma pop_macro("INCLUDE_ALL_JavaNioFileSpiFileSystemProvider")
