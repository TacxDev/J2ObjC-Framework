//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/platform/libcore/ojluni/src/main/java/java/text/DateFormat.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_JavaTextDateFormat")
#ifdef RESTRICT_JavaTextDateFormat
#define INCLUDE_ALL_JavaTextDateFormat 0
#else
#define INCLUDE_ALL_JavaTextDateFormat 1
#endif
#undef RESTRICT_JavaTextDateFormat

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (JavaTextDateFormat_) && (INCLUDE_ALL_JavaTextDateFormat || defined(INCLUDE_JavaTextDateFormat))
#define JavaTextDateFormat_

#define RESTRICT_JavaTextFormat 1
#define INCLUDE_JavaTextFormat 1
#include "java/text/Format.h"

@class IOSObjectArray;
@class JavaLangBoolean;
@class JavaLangInteger;
@class JavaLangStringBuffer;
@class JavaTextFieldPosition;
@class JavaTextNumberFormat;
@class JavaTextParsePosition;
@class JavaUtilCalendar;
@class JavaUtilDate;
@class JavaUtilLocale;
@class JavaUtilTimeZone;

/*!
 @brief <code>DateFormat</code> is an abstract class for date/time formatting subclasses which
  formats and parses dates or time in a language-independent manner.
 The date/time formatting subclass, such as <code>SimpleDateFormat</code>, allows for
  formatting (i.e., date &rarr; text), parsing (text &rarr; date), and
  normalization.  The date is represented as a <code>Date</code> object or
  as the milliseconds since January 1, 1970, 00:00:00 GMT. 
 <p><code>DateFormat</code> provides many class methods for obtaining default date/time
  formatters based on the default or a given locale and a number of formatting
  styles. The formatting styles include <code>FULL</code>, <code>LONG</code>, <code>MEDIUM</code>, and <code>SHORT</code>. More
  detail and examples of using these styles are provided in the method
  descriptions. 
 <p><code>DateFormat</code> helps you to format and parse dates for any locale.
  Your code can be completely independent of the locale conventions for
  months, days of the week, or even the calendar format: lunar vs. solar. 
 <p>To format a date for the current Locale, use one of the
  static factory methods: 
 <blockquote>
  @code
 myString = DateFormat.getDateInstance().format(myDate); 
 
@endcode
  </blockquote>
  <p>If you are formatting multiple dates, it is
  more efficient to get the format and use it multiple times so that
  the system doesn't have to fetch the information about the local
  language and country conventions multiple times. 
 <blockquote>
  @code
 DateFormat df = DateFormat.getDateInstance();
  for (int i = 0; i < myDate.length; ++i) {
      output.println(df.format(myDate[i]) + "; ");
  } 
 
@endcode
  </blockquote>
  <p>To format a date for a different Locale, specify it in the
  call to <code>getDateInstance()</code>.
  <blockquote>
  @code
 DateFormat df = DateFormat.getDateInstance(DateFormat.LONG, Locale.FRANCE); 
 
@endcode
  </blockquote>
  
 <p>You can use a DateFormat to parse also. 
 <blockquote>
  @code
 myDate = df.parse(myString); 
 
@endcode
  </blockquote>
  <p>Use <code>getDateInstance</code> to get the normal date format for that country.
  There are other static factory methods available.
  Use <code>getTimeInstance</code> to get the time format for that country.
  Use <code>getDateTimeInstance</code> to get a date and time format. You can pass in
  different options to these factory methods to control the length of the
  result; from <code>SHORT</code> to <code>MEDIUM</code> to <code>LONG</code> to <code>FULL</code>. The exact result depends
  on the locale, but generally: 
 <ul><li><code>SHORT</code> is completely numeric, such as <code>12.13.52</code> or <code>3:30pm</code>
  <li><code>MEDIUM</code> is longer, such as <code>Jan 12, 1952</code>
  <li><code>LONG</code> is longer, such as <code>January 12, 1952</code> or <code>3:30:32pm</code>
  <li><code>FULL</code> is pretty completely specified, such as 
 <code>Tuesday, April 12, 1952 AD or 3:30:42pm PST</code>.
  </ul>
  
 <p>You can also set the time zone on the format if you wish.
  If you want even more control over the format or parsing,
  (or want to give your users more control),
  you can try casting the <code>DateFormat</code> you get from the factory methods
  to a <code>SimpleDateFormat</code>. This will work for the majority
  of countries; just remember to put it in a <code>try</code> block in case you
  encounter an unusual one. 
 <p>You can also use forms of the parse and format methods with 
 <code>ParsePosition</code> and <code>FieldPosition</code> to
  allow you to 
 <ul><li>progressively parse through pieces of a string. 
 <li>align any particular field, or find out where it is for selection
  on the screen. 
 </ul>
  
 <h3><a id="synchronization">Synchronization</a></h3>
  
 <p>
  Date formats are not synchronized.
  It is recommended to create separate format instances for each thread.
  If multiple threads access a format concurrently, it must be synchronized
  externally.
 - seealso: Format
 - seealso: NumberFormat
 - seealso: SimpleDateFormat
 - seealso: java.util.Calendar
 - seealso: java.util.GregorianCalendar
 - seealso: java.util.TimeZone
 @author Mark Davis, Chen-Lieh Huang, Alan Liu
 @since 1.1
 */
@interface JavaTextDateFormat : JavaTextFormat {
 @public
  /*!
   @brief The <code>Calendar</code> instance used for calculating the date-time fields
  and the instant of time.This field is used for both formatting and
  parsing.
   <p>Subclasses should initialize this field to a <code>Calendar</code>
  appropriate for the <code>Locale</code> associated with this 
 <code>DateFormat</code>.
   */
  JavaUtilCalendar *calendar_;
  /*!
   @brief The number formatter that <code>DateFormat</code> uses to format numbers
  in dates and times.Subclasses should initialize this to a number format
  appropriate for the locale associated with this <code>DateFormat</code>.
   */
  JavaTextNumberFormat *numberFormat_;
}

#pragma mark Public

/*!
 @brief Overrides Cloneable
 */
- (id __nonnull)java_clone;

/*!
 @brief Overrides equals
 */
- (jboolean)isEqual:(id)obj;

/*!
 @brief Formats a <code>Date</code> into a date-time string.
 @param date the time value to be formatted into a date-time string.
 @return the formatted date-time string.
 */
- (NSString * __nonnull)formatWithJavaUtilDate:(JavaUtilDate *)date;

/*!
 @brief Formats a <code>Date</code> into a date-time string.The formatted
  string is appended to the given <code>StringBuffer</code>.
 @param date a Date to be formatted into a date-time string.
 @param toAppendTo the string buffer for the returning date-time string.
 @param fieldPosition keeps track on the position of the field within  the returned string. For example, given a date-time text
   <code>"1996.07.10 AD at 15:08:56 PDT"</code>
  , if the given <code>fieldPosition</code>  is <code>DateFormat.YEAR_FIELD</code>
  , the begin index and end index of  <code>fieldPosition</code>
   will be set to 0 and 4, respectively.  Notice that if the same date-time field appears more than once in a
   pattern, the <code>fieldPosition</code>
   will be set for the first occurrence  of that date-time field. For instance, formatting a 
 <code>Date</code>  to the  date-time string <code>"1 PM PDT (Pacific Daylight Time)"</code>
   using the  pattern <code>"h a z (zzzz)"</code>  and the alignment field
   <code>DateFormat.TIMEZONE_FIELD</code> , the begin index and end index of
   <code>fieldPosition</code>  will be set to 5 and 8, respectively, for the
   first occurrence of the timezone pattern character <code>'z'</code>
  .
 @return the string buffer passed in as <code>toAppendTo</code>, with formatted
  text appended.
 */
- (JavaLangStringBuffer * __nonnull)formatWithJavaUtilDate:(JavaUtilDate *)date
                                  withJavaLangStringBuffer:(JavaLangStringBuffer *)toAppendTo
                                 withJavaTextFieldPosition:(JavaTextFieldPosition *)fieldPosition;

/*!
 @brief Formats the given <code>Object</code> into a date-time string.The formatted
  string is appended to the given <code>StringBuffer</code>.
 @param obj Must be a <code>Date</code>  or a <code>Number</code>  representing a
   millisecond offset from the  <a href="../util/Calendar.html#Epoch"> Epoch </a> .
 @param toAppendTo The string buffer for the returning date-time string.
 @param fieldPosition keeps track on the position of the field within  the returned string. For example, given a date-time text
   <code>"1996.07.10 AD at 15:08:56 PDT"</code>
  , if the given <code>fieldPosition</code>  is <code>DateFormat.YEAR_FIELD</code>
  , the begin index and end index of  <code>fieldPosition</code>
   will be set to 0 and 4, respectively.  Notice that if the same date-time field appears more than once in a
   pattern, the <code>fieldPosition</code>
   will be set for the first occurrence  of that date-time field. For instance, formatting a 
 <code>Date</code>  to the  date-time string <code>"1 PM PDT (Pacific Daylight Time)"</code>
   using the  pattern <code>"h a z (zzzz)"</code>  and the alignment field
   <code>DateFormat.TIMEZONE_FIELD</code> , the begin index and end index of
   <code>fieldPosition</code>  will be set to 5 and 8, respectively, for the
   first occurrence of the timezone pattern character <code>'z'</code>
  .
 @return the string buffer passed in as <code>toAppendTo</code>,
          with formatted text appended.
 @throw IllegalArgumentExceptionif the <code>Format</code> cannot format
             the given <code>obj</code>.
 - seealso: java.text.Format
 */
- (JavaLangStringBuffer * __nonnull)formatWithId:(id)obj
                        withJavaLangStringBuffer:(JavaLangStringBuffer *)toAppendTo
                       withJavaTextFieldPosition:(JavaTextFieldPosition *)fieldPosition;

/*!
 @brief Returns an array of all locales for which the 
 <code>get*Instance</code> methods of this class can return
  localized instances.
 @return An array of locales for which localized
          <code>DateFormat</code> instances are available.
 */
+ (IOSObjectArray * __nonnull)getAvailableLocales;

/*!
 @brief Gets the calendar associated with this date/time formatter.
 @return the calendar associated with this date/time formatter.
 */
- (JavaUtilCalendar * __nonnull)getCalendar;

/*!
 @brief Gets the date formatter with the default formatting style
  for the default <code>FORMAT</code> locale.
 <p>This is equivalent to calling 
 <code>getDateInstance(DEFAULT,
      Locale.getDefault(Locale.Category.FORMAT))</code>
 .
 - seealso: java.util.Locale#getDefault(java.util.Locale.Category)
 - seealso: java.util.Locale.Category#FORMAT
 @return a date formatter.
 */
+ (JavaTextDateFormat * __nonnull)getDateInstance;

/*!
 @brief Gets the date formatter with the given formatting style
  for the default <code>FORMAT</code> locale.
 <p>This is equivalent to calling 
 <code>getDateInstance(style,
      Locale.getDefault(Locale.Category.FORMAT))</code>
 .
 - seealso: java.util.Locale#getDefault(java.util.Locale.Category)
 - seealso: java.util.Locale.Category#FORMAT
 @param style the given formatting style. For example,  SHORT for "M/d/yy" in the US locale.
 @return a date formatter.
 */
+ (JavaTextDateFormat * __nonnull)getDateInstanceWithInt:(jint)style;

/*!
 @brief Gets the date formatter with the given formatting style
  for the given locale.
 @param style the given formatting style. For example,  SHORT for "M/d/yy" in the US locale.
 @param aLocale the given locale.
 @return a date formatter.
 */
+ (JavaTextDateFormat * __nonnull)getDateInstanceWithInt:(jint)style
                                      withJavaUtilLocale:(JavaUtilLocale *)aLocale;

/*!
 @brief Gets the date/time formatter with the default formatting style
  for the default <code>FORMAT</code> locale.
 <p>This is equivalent to calling 
 <code>getDateTimeInstance(DEFAULT,
      DEFAULT, Locale.getDefault(Locale.Category.FORMAT))</code>
 .
 - seealso: java.util.Locale#getDefault(java.util.Locale.Category)
 - seealso: java.util.Locale.Category#FORMAT
 @return a date/time formatter.
 */
+ (JavaTextDateFormat * __nonnull)getDateTimeInstance;

/*!
 @brief Gets the date/time formatter with the given date and time
  formatting styles for the default <code>FORMAT</code> locale.
 <p>This is equivalent to calling 
 <code>getDateTimeInstance(dateStyle,
      timeStyle, Locale.getDefault(Locale.Category.FORMAT))</code>
 .
 - seealso: java.util.Locale#getDefault(java.util.Locale.Category)
 - seealso: java.util.Locale.Category#FORMAT
 @param dateStyle the given date formatting style. For example,  SHORT for "M/d/yy" in the US locale.
 @param timeStyle the given time formatting style. For example,  SHORT for "h:mm a" in the US locale.
 @return a date/time formatter.
 */
+ (JavaTextDateFormat * __nonnull)getDateTimeInstanceWithInt:(jint)dateStyle
                                                     withInt:(jint)timeStyle;

/*!
 @brief Gets the date/time formatter with the given formatting styles
  for the given locale.
 @param dateStyle the given date formatting style.
 @param timeStyle the given time formatting style.
 @param aLocale the given locale.
 @return a date/time formatter.
 */
+ (JavaTextDateFormat * __nonnull)getDateTimeInstanceWithInt:(jint)dateStyle
                                                     withInt:(jint)timeStyle
                                          withJavaUtilLocale:(JavaUtilLocale *)aLocale;

/*!
 @brief Get a default date/time formatter that uses the SHORT style for both the
  date and the time.
 @return a date/time formatter
 */
+ (JavaTextDateFormat * __nonnull)getInstance;

/*!
 @brief Gets the number formatter which this date/time formatter uses to
  format and parse a time.
 @return the number formatter which this date/time formatter uses.
 */
- (JavaTextNumberFormat * __nonnull)getNumberFormat;

/*!
 @brief Gets the time formatter with the default formatting style
  for the default <code>FORMAT</code> locale.
 <p>This is equivalent to calling 
 <code>getTimeInstance(DEFAULT,
      Locale.getDefault(Locale.Category.FORMAT))</code>
 .
 - seealso: java.util.Locale#getDefault(java.util.Locale.Category)
 - seealso: java.util.Locale.Category#FORMAT
 @return a time formatter.
 */
+ (JavaTextDateFormat * __nonnull)getTimeInstance;

/*!
 @brief Gets the time formatter with the given formatting style
  for the default <code>FORMAT</code> locale.
 <p>This is equivalent to calling 
 <code>getTimeInstance(style,
      Locale.getDefault(Locale.Category.FORMAT))</code>
 .
 - seealso: java.util.Locale#getDefault(java.util.Locale.Category)
 - seealso: java.util.Locale.Category#FORMAT
 @param style the given formatting style. For example,  SHORT for "h:mm a" in the US locale.
 @return a time formatter.
 */
+ (JavaTextDateFormat * __nonnull)getTimeInstanceWithInt:(jint)style;

/*!
 @brief Gets the time formatter with the given formatting style
  for the given locale.
 @param style the given formatting style. For example,  SHORT for "h:mm a" in the US locale.
 @param aLocale the given locale.
 @return a time formatter.
 */
+ (JavaTextDateFormat * __nonnull)getTimeInstanceWithInt:(jint)style
                                      withJavaUtilLocale:(JavaUtilLocale *)aLocale;

/*!
 @brief Gets the time zone.
 This method is equivalent to the following call. 
 <blockquote>@code
 getCalendar().getTimeZone() 
 
@endcode</blockquote>
 @return the time zone associated with the calendar of DateFormat.
 */
- (JavaUtilTimeZone * __nonnull)getTimeZone;

/*!
 @brief Overrides hashCode
 */
- (NSUInteger)hash;

/*!
 @brief Tell whether date/time parsing is to be lenient.
 This method is equivalent to the following call. 
 <blockquote>@code
 getCalendar().isLenient() 
 
@endcode</blockquote>
 @return <code>true</code> if the <code>calendar</code> is lenient;
          <code>false</code> otherwise.
 - seealso: java.util.Calendar#isLenient()
 */
- (jboolean)isLenient;

/*!
 @brief Parses text from the beginning of the given string to produce a date.
 The method may not use the entire text of the given string. 
 <p>
  See the <code>parse(String, ParsePosition)</code> method for more information
  on date parsing.
 @param source A  <code> String </code>  whose beginning should be parsed.
 @return A <code>Date</code> parsed from the string.
 @throw ParseExceptionif the beginning of the specified string
             cannot be parsed.
 */
- (JavaUtilDate * __nullable)parseWithNSString:(NSString *)source;

/*!
 @brief Parse a date/time string according to the given parse position.For
  example, a time text <code>"07/10/96 4:5 PM, PDT"</code> will be parsed into a <code>Date</code>
  that is equivalent to <code>Date(837039900000L)</code>.
 <p> By default, parsing is lenient: If the input is not in the form used
  by this object's format method but can still be parsed as a date, then
  the parse succeeds.  Clients may insist on strict adherence to the
  format by calling <code>setLenient(false)</code>.
  
 <p>This parsing operation uses the <code>calendar</code> to produce
  a <code>Date</code>. As a result, the <code>calendar</code>'s date-time
  fields and the <code>TimeZone</code> value may have been
  overwritten, depending on subclass implementations. Any <code>TimeZone</code>
  value that has previously been set by a call to 
 <code>setTimeZone</code> may need
  to be restored for further operations.
 @param source The date/time string to be parsed
 @param pos On input, the position at which to start parsing; on               output, the position at which parsing terminated, or the
                start position if the parse failed.
 @return A <code>Date</code>, or <code>null</code> if the input could not be parsed
 */
- (JavaUtilDate * __nullable)parseWithNSString:(NSString *)source
                     withJavaTextParsePosition:(JavaTextParsePosition *)pos;

/*!
 @brief Parses text from a string to produce a <code>Date</code>.
 <p>
  The method attempts to parse text starting at the index given by 
 <code>pos</code>.
  If parsing succeeds, then the index of <code>pos</code> is updated
  to the index after the last character used (parsing does not necessarily
  use all characters up to the end of the string), and the parsed
  date is returned. The updated <code>pos</code> can be used to
  indicate the starting point for the next call to this method.
  If an error occurs, then the index of <code>pos</code> is not
  changed, the error index of <code>pos</code> is set to the index of
  the character where the error occurred, and null is returned. 
 <p>
  See the <code>parse(String, ParsePosition)</code> method for more information
  on date parsing.
 @param source A  <code> String </code> , part of which should be parsed.
 @param pos A  <code> ParsePosition </code>  object with index and error
              index information as described above.
 @return A <code>Date</code> parsed from the string. In case of
          error, returns null.
 @throw NullPointerExceptionif <code>source</code> or <code>pos</code> is null.
 */
- (id __nullable)parseObjectWithNSString:(NSString *)source
               withJavaTextParsePosition:(JavaTextParsePosition *)pos;

/*!
 @brief Override the time formatting behavior for <code>SHORT</code> and <code>MEDIUM</code> time formats.
 Accepts one of the following: 
 <ul>
    <li><code>null</code>: use Locale default/li>
    <li><code>true</code>: force 24-hour format</li>
    <li><code>false</code> force 12-hour format</li>
  </ul>
 @param is24Hour whether to use 24-hour format or not. <code>null</code>  uses locale default.
 */
+ (void)set24HourTimePrefWithJavaLangBoolean:(JavaLangBoolean *)is24Hour;

/*!
 @brief Set the calendar to be used by this date format.Initially, the default
  calendar for the specified or default locale is used.
 <p>Any <code>TimeZone</code> and leniency
  values that have previously been set are
  overwritten by <code>newCalendar</code>'s values.
 @param newCalendar the new <code>Calendar</code>  to be used by the date format
 */
- (void)setCalendarWithJavaUtilCalendar:(JavaUtilCalendar *)newCalendar;

/*!
 @brief Specify whether or not date/time parsing is to be lenient.With
  lenient parsing, the parser may use heuristics to interpret inputs that
  do not precisely match this object's format.
 With strict parsing,
  inputs must match this object's format. 
 <p>This method is equivalent to the following call. 
 <blockquote>@code
 getCalendar().setLenient(lenient) 
 
@endcode</blockquote>
  
 <p>This leniency value is overwritten by a call to <code>setCalendar()</code>
 .
 @param lenient when <code>true</code> , parsing is lenient
 - seealso: java.util.Calendar#setLenient(boolean)
 */
- (void)setLenientWithBoolean:(jboolean)lenient;

/*!
 @brief Allows you to set the number formatter.
 @param newNumberFormat the given new NumberFormat.
 */
- (void)setNumberFormatWithJavaTextNumberFormat:(JavaTextNumberFormat *)newNumberFormat;

/*!
 @brief Sets the time zone for the calendar of this <code>DateFormat</code> object.
 This method is equivalent to the following call. 
 <blockquote>@code
 getCalendar().setTimeZone(zone) 
 
@endcode</blockquote>
  
 <p>The <code>TimeZone</code> set by this method is overwritten by a 
 <code>setCalendar</code> call. 
 <p>The <code>TimeZone</code> set by this method may be overwritten as
  a result of a call to the parse method.
 @param zone the given new time zone.
 */
- (void)setTimeZoneWithJavaUtilTimeZone:(JavaUtilTimeZone *)zone;

#pragma mark Protected

/*!
 @brief Create a new date format.
 */
- (instancetype __nonnull)init;

@end

J2OBJC_EMPTY_STATIC_INIT(JavaTextDateFormat)

J2OBJC_FIELD_SETTER(JavaTextDateFormat, calendar_, JavaUtilCalendar *)
J2OBJC_FIELD_SETTER(JavaTextDateFormat, numberFormat_, JavaTextNumberFormat *)

/*!
 @brief Useful constant for ERA field alignment.
 Used in FieldPosition of date/time formatting.
 */
inline jint JavaTextDateFormat_get_ERA_FIELD(void);
#define JavaTextDateFormat_ERA_FIELD 0
J2OBJC_STATIC_FIELD_CONSTANT(JavaTextDateFormat, ERA_FIELD, jint)

/*!
 @brief Useful constant for YEAR field alignment.
 Used in FieldPosition of date/time formatting.
 */
inline jint JavaTextDateFormat_get_YEAR_FIELD(void);
#define JavaTextDateFormat_YEAR_FIELD 1
J2OBJC_STATIC_FIELD_CONSTANT(JavaTextDateFormat, YEAR_FIELD, jint)

/*!
 @brief Useful constant for MONTH field alignment.
 Used in FieldPosition of date/time formatting.
 */
inline jint JavaTextDateFormat_get_MONTH_FIELD(void);
#define JavaTextDateFormat_MONTH_FIELD 2
J2OBJC_STATIC_FIELD_CONSTANT(JavaTextDateFormat, MONTH_FIELD, jint)

/*!
 @brief Useful constant for DATE field alignment.
 Used in FieldPosition of date/time formatting.
 */
inline jint JavaTextDateFormat_get_DATE_FIELD(void);
#define JavaTextDateFormat_DATE_FIELD 3
J2OBJC_STATIC_FIELD_CONSTANT(JavaTextDateFormat, DATE_FIELD, jint)

/*!
 @brief Useful constant for one-based HOUR_OF_DAY field alignment.
 Used in FieldPosition of date/time formatting.
  HOUR_OF_DAY1_FIELD is used for the one-based 24-hour clock.
  For example, 23:59 + 01:00 results in 24:59.
 */
inline jint JavaTextDateFormat_get_HOUR_OF_DAY1_FIELD(void);
#define JavaTextDateFormat_HOUR_OF_DAY1_FIELD 4
J2OBJC_STATIC_FIELD_CONSTANT(JavaTextDateFormat, HOUR_OF_DAY1_FIELD, jint)

/*!
 @brief Useful constant for zero-based HOUR_OF_DAY field alignment.
 Used in FieldPosition of date/time formatting.
  HOUR_OF_DAY0_FIELD is used for the zero-based 24-hour clock.
  For example, 23:59 + 01:00 results in 00:59.
 */
inline jint JavaTextDateFormat_get_HOUR_OF_DAY0_FIELD(void);
#define JavaTextDateFormat_HOUR_OF_DAY0_FIELD 5
J2OBJC_STATIC_FIELD_CONSTANT(JavaTextDateFormat, HOUR_OF_DAY0_FIELD, jint)

/*!
 @brief Useful constant for MINUTE field alignment.
 Used in FieldPosition of date/time formatting.
 */
inline jint JavaTextDateFormat_get_MINUTE_FIELD(void);
#define JavaTextDateFormat_MINUTE_FIELD 6
J2OBJC_STATIC_FIELD_CONSTANT(JavaTextDateFormat, MINUTE_FIELD, jint)

/*!
 @brief Useful constant for SECOND field alignment.
 Used in FieldPosition of date/time formatting.
 */
inline jint JavaTextDateFormat_get_SECOND_FIELD(void);
#define JavaTextDateFormat_SECOND_FIELD 7
J2OBJC_STATIC_FIELD_CONSTANT(JavaTextDateFormat, SECOND_FIELD, jint)

/*!
 @brief Useful constant for MILLISECOND field alignment.
 Used in FieldPosition of date/time formatting.
 */
inline jint JavaTextDateFormat_get_MILLISECOND_FIELD(void);
#define JavaTextDateFormat_MILLISECOND_FIELD 8
J2OBJC_STATIC_FIELD_CONSTANT(JavaTextDateFormat, MILLISECOND_FIELD, jint)

/*!
 @brief Useful constant for DAY_OF_WEEK field alignment.
 Used in FieldPosition of date/time formatting.
 */
inline jint JavaTextDateFormat_get_DAY_OF_WEEK_FIELD(void);
#define JavaTextDateFormat_DAY_OF_WEEK_FIELD 9
J2OBJC_STATIC_FIELD_CONSTANT(JavaTextDateFormat, DAY_OF_WEEK_FIELD, jint)

/*!
 @brief Useful constant for DAY_OF_YEAR field alignment.
 Used in FieldPosition of date/time formatting.
 */
inline jint JavaTextDateFormat_get_DAY_OF_YEAR_FIELD(void);
#define JavaTextDateFormat_DAY_OF_YEAR_FIELD 10
J2OBJC_STATIC_FIELD_CONSTANT(JavaTextDateFormat, DAY_OF_YEAR_FIELD, jint)

/*!
 @brief Useful constant for DAY_OF_WEEK_IN_MONTH field alignment.
 Used in FieldPosition of date/time formatting.
 */
inline jint JavaTextDateFormat_get_DAY_OF_WEEK_IN_MONTH_FIELD(void);
#define JavaTextDateFormat_DAY_OF_WEEK_IN_MONTH_FIELD 11
J2OBJC_STATIC_FIELD_CONSTANT(JavaTextDateFormat, DAY_OF_WEEK_IN_MONTH_FIELD, jint)

/*!
 @brief Useful constant for WEEK_OF_YEAR field alignment.
 Used in FieldPosition of date/time formatting.
 */
inline jint JavaTextDateFormat_get_WEEK_OF_YEAR_FIELD(void);
#define JavaTextDateFormat_WEEK_OF_YEAR_FIELD 12
J2OBJC_STATIC_FIELD_CONSTANT(JavaTextDateFormat, WEEK_OF_YEAR_FIELD, jint)

/*!
 @brief Useful constant for WEEK_OF_MONTH field alignment.
 Used in FieldPosition of date/time formatting.
 */
inline jint JavaTextDateFormat_get_WEEK_OF_MONTH_FIELD(void);
#define JavaTextDateFormat_WEEK_OF_MONTH_FIELD 13
J2OBJC_STATIC_FIELD_CONSTANT(JavaTextDateFormat, WEEK_OF_MONTH_FIELD, jint)

/*!
 @brief Useful constant for AM_PM field alignment.
 Used in FieldPosition of date/time formatting.
 */
inline jint JavaTextDateFormat_get_AM_PM_FIELD(void);
#define JavaTextDateFormat_AM_PM_FIELD 14
J2OBJC_STATIC_FIELD_CONSTANT(JavaTextDateFormat, AM_PM_FIELD, jint)

/*!
 @brief Useful constant for one-based HOUR field alignment.
 Used in FieldPosition of date/time formatting.
  HOUR1_FIELD is used for the one-based 12-hour clock.
  For example, 11:30 PM + 1 hour results in 12:30 AM.
 */
inline jint JavaTextDateFormat_get_HOUR1_FIELD(void);
#define JavaTextDateFormat_HOUR1_FIELD 15
J2OBJC_STATIC_FIELD_CONSTANT(JavaTextDateFormat, HOUR1_FIELD, jint)

/*!
 @brief Useful constant for zero-based HOUR field alignment.
 Used in FieldPosition of date/time formatting.
  HOUR0_FIELD is used for the zero-based 12-hour clock.
  For example, 11:30 PM + 1 hour results in 00:30 AM.
 */
inline jint JavaTextDateFormat_get_HOUR0_FIELD(void);
#define JavaTextDateFormat_HOUR0_FIELD 16
J2OBJC_STATIC_FIELD_CONSTANT(JavaTextDateFormat, HOUR0_FIELD, jint)

/*!
 @brief Useful constant for TIMEZONE field alignment.
 Used in FieldPosition of date/time formatting.
 */
inline jint JavaTextDateFormat_get_TIMEZONE_FIELD(void);
#define JavaTextDateFormat_TIMEZONE_FIELD 17
J2OBJC_STATIC_FIELD_CONSTANT(JavaTextDateFormat, TIMEZONE_FIELD, jint)

/*!
 @brief Constant for full style pattern.
 */
inline jint JavaTextDateFormat_get_FULL(void);
#define JavaTextDateFormat_FULL 0
J2OBJC_STATIC_FIELD_CONSTANT(JavaTextDateFormat, FULL, jint)

/*!
 @brief Constant for long style pattern.
 */
inline jint JavaTextDateFormat_get_LONG(void);
#define JavaTextDateFormat_LONG 1
J2OBJC_STATIC_FIELD_CONSTANT(JavaTextDateFormat, LONG, jint)

/*!
 @brief Constant for medium style pattern.
 */
inline jint JavaTextDateFormat_get_MEDIUM(void);
#define JavaTextDateFormat_MEDIUM 2
J2OBJC_STATIC_FIELD_CONSTANT(JavaTextDateFormat, MEDIUM, jint)

/*!
 @brief Constant for short style pattern.
 */
inline jint JavaTextDateFormat_get_SHORT(void);
#define JavaTextDateFormat_SHORT 3
J2OBJC_STATIC_FIELD_CONSTANT(JavaTextDateFormat, SHORT, jint)

/*!
 @brief Constant for default style pattern.Its value is MEDIUM.
 */
inline jint JavaTextDateFormat_get_DEFAULT(void);
#define JavaTextDateFormat_DEFAULT 2
J2OBJC_STATIC_FIELD_CONSTANT(JavaTextDateFormat, DEFAULT, jint)

/*!
 @brief <code>null</code>: use Locale default.
 <code>true</code>: force 24-hour format. 
 <code>false</code> force 12-hour format.
 */
inline JavaLangBoolean *JavaTextDateFormat_get_is24Hour(void);
inline JavaLangBoolean *JavaTextDateFormat_set_is24Hour(JavaLangBoolean *value);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaLangBoolean *JavaTextDateFormat_is24Hour;
J2OBJC_STATIC_FIELD_OBJ(JavaTextDateFormat, is24Hour, JavaLangBoolean *)

FOUNDATION_EXPORT JavaTextDateFormat *JavaTextDateFormat_getTimeInstance(void);

FOUNDATION_EXPORT JavaTextDateFormat *JavaTextDateFormat_getTimeInstanceWithInt_(jint style);

FOUNDATION_EXPORT JavaTextDateFormat *JavaTextDateFormat_getTimeInstanceWithInt_withJavaUtilLocale_(jint style, JavaUtilLocale *aLocale);

FOUNDATION_EXPORT JavaTextDateFormat *JavaTextDateFormat_getDateInstance(void);

FOUNDATION_EXPORT JavaTextDateFormat *JavaTextDateFormat_getDateInstanceWithInt_(jint style);

FOUNDATION_EXPORT JavaTextDateFormat *JavaTextDateFormat_getDateInstanceWithInt_withJavaUtilLocale_(jint style, JavaUtilLocale *aLocale);

FOUNDATION_EXPORT JavaTextDateFormat *JavaTextDateFormat_getDateTimeInstance(void);

FOUNDATION_EXPORT JavaTextDateFormat *JavaTextDateFormat_getDateTimeInstanceWithInt_withInt_(jint dateStyle, jint timeStyle);

FOUNDATION_EXPORT JavaTextDateFormat *JavaTextDateFormat_getDateTimeInstanceWithInt_withInt_withJavaUtilLocale_(jint dateStyle, jint timeStyle, JavaUtilLocale *aLocale);

FOUNDATION_EXPORT JavaTextDateFormat *JavaTextDateFormat_getInstance(void);

FOUNDATION_EXPORT void JavaTextDateFormat_set24HourTimePrefWithJavaLangBoolean_(JavaLangBoolean *is24Hour);

FOUNDATION_EXPORT IOSObjectArray *JavaTextDateFormat_getAvailableLocales(void);

FOUNDATION_EXPORT void JavaTextDateFormat_init(JavaTextDateFormat *self);

J2OBJC_TYPE_LITERAL_HEADER(JavaTextDateFormat)

#endif

#if !defined (JavaTextDateFormat_Field_) && (INCLUDE_ALL_JavaTextDateFormat || defined(INCLUDE_JavaTextDateFormat_Field))
#define JavaTextDateFormat_Field_

#define RESTRICT_JavaTextFormat 1
#define INCLUDE_JavaTextFormat_Field 1
#include "java/text/Format.h"

@class JavaLangInteger;

/*!
 @brief Defines constants that are used as attribute keys in the 
 <code>AttributedCharacterIterator</code> returned
  from <code>DateFormat.formatToCharacterIterator</code> and as
  field identifiers in <code>FieldPosition</code>.
 <p>
  The class also provides two methods to map
  between its constants and the corresponding Calendar constants.
 @since 1.4
 - seealso: java.util.Calendar
 */
@interface JavaTextDateFormat_Field : JavaTextFormat_Field

#pragma mark Public

/*!
 @brief Returns the <code>Calendar</code> field associated with this
  attribute.For example, if this represents the hours field of
  a <code>Calendar</code>, this would return 
 <code>Calendar.HOUR</code>.
 If there is no corresponding 
 <code>Calendar</code> constant, this will return -1.
 @return Calendar constant for this field
 - seealso: java.util.Calendar
 */
- (jint)getCalendarField;

/*!
 @brief Returns the <code>Field</code> constant that corresponds to
  the <code>Calendar</code> constant <code>calendarField</code>.
 If there is no direct mapping between the <code>Calendar</code>
  constant and a <code>Field</code>, null is returned.
 @throw IllegalArgumentExceptionif <code>calendarField</code> is
          not the value of a <code>Calendar</code> field constant.
 @param calendarField Calendar field constant
 @return Field instance representing calendarField.
 - seealso: java.util.Calendar
 */
+ (JavaTextDateFormat_Field * __nonnull)ofCalendarFieldWithInt:(jint)calendarField;

#pragma mark Protected

/*!
 @brief Creates a <code>Field</code>.
 @param name the name of the  <code> Field </code>
 @param calendarField the  <code> Calendar </code>  constant this
           <code> Field </code>  corresponds to; any value, even one         outside the range of legal 
  <code> Calendar </code>  values may         be used, but 
  <code> -1 </code>  should be used for values         that don't correspond to legal 
  <code> Calendar </code>  values
 */
- (instancetype __nonnull)initWithNSString:(NSString *)name
                                   withInt:(jint)calendarField;

/*!
 @brief Resolves instances being deserialized to the predefined constants.
 @throw InvalidObjectExceptionif the constant could not be
          resolved.
 @return resolved DateFormat.Field constant
 */
- (id __nonnull)readResolve;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)initWithNSString:(NSString *)arg0 NS_UNAVAILABLE;

@end

J2OBJC_STATIC_INIT(JavaTextDateFormat_Field)

/*!
 @brief Constant identifying the era field.
 */
inline JavaTextDateFormat_Field *JavaTextDateFormat_Field_get_ERA(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaTextDateFormat_Field *JavaTextDateFormat_Field_ERA;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaTextDateFormat_Field, ERA, JavaTextDateFormat_Field *)

/*!
 @brief Constant identifying the year field.
 */
inline JavaTextDateFormat_Field *JavaTextDateFormat_Field_get_YEAR(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaTextDateFormat_Field *JavaTextDateFormat_Field_YEAR;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaTextDateFormat_Field, YEAR, JavaTextDateFormat_Field *)

/*!
 @brief Constant identifying the month field.
 */
inline JavaTextDateFormat_Field *JavaTextDateFormat_Field_get_MONTH(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaTextDateFormat_Field *JavaTextDateFormat_Field_MONTH;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaTextDateFormat_Field, MONTH, JavaTextDateFormat_Field *)

/*!
 @brief Constant identifying the day of month field.
 */
inline JavaTextDateFormat_Field *JavaTextDateFormat_Field_get_DAY_OF_MONTH(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaTextDateFormat_Field *JavaTextDateFormat_Field_DAY_OF_MONTH;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaTextDateFormat_Field, DAY_OF_MONTH, JavaTextDateFormat_Field *)

/*!
 @brief Constant identifying the hour of day field, where the legal values
  are 1 to 24.
 */
inline JavaTextDateFormat_Field *JavaTextDateFormat_Field_get_HOUR_OF_DAY1(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaTextDateFormat_Field *JavaTextDateFormat_Field_HOUR_OF_DAY1;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaTextDateFormat_Field, HOUR_OF_DAY1, JavaTextDateFormat_Field *)

/*!
 @brief Constant identifying the hour of day field, where the legal values
  are 0 to 23.
 */
inline JavaTextDateFormat_Field *JavaTextDateFormat_Field_get_HOUR_OF_DAY0(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaTextDateFormat_Field *JavaTextDateFormat_Field_HOUR_OF_DAY0;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaTextDateFormat_Field, HOUR_OF_DAY0, JavaTextDateFormat_Field *)

/*!
 @brief Constant identifying the minute field.
 */
inline JavaTextDateFormat_Field *JavaTextDateFormat_Field_get_MINUTE(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaTextDateFormat_Field *JavaTextDateFormat_Field_MINUTE;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaTextDateFormat_Field, MINUTE, JavaTextDateFormat_Field *)

/*!
 @brief Constant identifying the second field.
 */
inline JavaTextDateFormat_Field *JavaTextDateFormat_Field_get_SECOND(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaTextDateFormat_Field *JavaTextDateFormat_Field_SECOND;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaTextDateFormat_Field, SECOND, JavaTextDateFormat_Field *)

/*!
 @brief Constant identifying the millisecond field.
 */
inline JavaTextDateFormat_Field *JavaTextDateFormat_Field_get_MILLISECOND(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaTextDateFormat_Field *JavaTextDateFormat_Field_MILLISECOND;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaTextDateFormat_Field, MILLISECOND, JavaTextDateFormat_Field *)

/*!
 @brief Constant identifying the day of week field.
 */
inline JavaTextDateFormat_Field *JavaTextDateFormat_Field_get_DAY_OF_WEEK(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaTextDateFormat_Field *JavaTextDateFormat_Field_DAY_OF_WEEK;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaTextDateFormat_Field, DAY_OF_WEEK, JavaTextDateFormat_Field *)

/*!
 @brief Constant identifying the day of year field.
 */
inline JavaTextDateFormat_Field *JavaTextDateFormat_Field_get_DAY_OF_YEAR(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaTextDateFormat_Field *JavaTextDateFormat_Field_DAY_OF_YEAR;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaTextDateFormat_Field, DAY_OF_YEAR, JavaTextDateFormat_Field *)

/*!
 @brief Constant identifying the day of week field.
 */
inline JavaTextDateFormat_Field *JavaTextDateFormat_Field_get_DAY_OF_WEEK_IN_MONTH(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaTextDateFormat_Field *JavaTextDateFormat_Field_DAY_OF_WEEK_IN_MONTH;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaTextDateFormat_Field, DAY_OF_WEEK_IN_MONTH, JavaTextDateFormat_Field *)

/*!
 @brief Constant identifying the week of year field.
 */
inline JavaTextDateFormat_Field *JavaTextDateFormat_Field_get_WEEK_OF_YEAR(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaTextDateFormat_Field *JavaTextDateFormat_Field_WEEK_OF_YEAR;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaTextDateFormat_Field, WEEK_OF_YEAR, JavaTextDateFormat_Field *)

/*!
 @brief Constant identifying the week of month field.
 */
inline JavaTextDateFormat_Field *JavaTextDateFormat_Field_get_WEEK_OF_MONTH(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaTextDateFormat_Field *JavaTextDateFormat_Field_WEEK_OF_MONTH;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaTextDateFormat_Field, WEEK_OF_MONTH, JavaTextDateFormat_Field *)

/*!
 @brief Constant identifying the time of day indicator
  (e.g."
 a.m." or "p.m.") field.
 */
inline JavaTextDateFormat_Field *JavaTextDateFormat_Field_get_AM_PM(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaTextDateFormat_Field *JavaTextDateFormat_Field_AM_PM;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaTextDateFormat_Field, AM_PM, JavaTextDateFormat_Field *)

/*!
 @brief Constant identifying the hour field, where the legal values are
  1 to 12.
 */
inline JavaTextDateFormat_Field *JavaTextDateFormat_Field_get_HOUR1(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaTextDateFormat_Field *JavaTextDateFormat_Field_HOUR1;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaTextDateFormat_Field, HOUR1, JavaTextDateFormat_Field *)

/*!
 @brief Constant identifying the hour field, where the legal values are
  0 to 11.
 */
inline JavaTextDateFormat_Field *JavaTextDateFormat_Field_get_HOUR0(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaTextDateFormat_Field *JavaTextDateFormat_Field_HOUR0;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaTextDateFormat_Field, HOUR0, JavaTextDateFormat_Field *)

/*!
 @brief Constant identifying the time zone field.
 */
inline JavaTextDateFormat_Field *JavaTextDateFormat_Field_get_TIME_ZONE(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT JavaTextDateFormat_Field *JavaTextDateFormat_Field_TIME_ZONE;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaTextDateFormat_Field, TIME_ZONE, JavaTextDateFormat_Field *)

FOUNDATION_EXPORT JavaTextDateFormat_Field *JavaTextDateFormat_Field_ofCalendarFieldWithInt_(jint calendarField);

FOUNDATION_EXPORT void JavaTextDateFormat_Field_initWithNSString_withInt_(JavaTextDateFormat_Field *self, NSString *name, jint calendarField);

FOUNDATION_EXPORT JavaTextDateFormat_Field *new_JavaTextDateFormat_Field_initWithNSString_withInt_(NSString *name, jint calendarField) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaTextDateFormat_Field *create_JavaTextDateFormat_Field_initWithNSString_withInt_(NSString *name, jint calendarField);

J2OBJC_TYPE_LITERAL_HEADER(JavaTextDateFormat_Field)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif
#pragma pop_macro("INCLUDE_ALL_JavaTextDateFormat")
