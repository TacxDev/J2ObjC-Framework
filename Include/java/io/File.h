//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: android/platform/libcore/ojluni/src/main/java/java/io/File.java
//

#include "J2ObjC_header.h"

#pragma push_macro("INCLUDE_ALL_JavaIoFile")
#ifdef RESTRICT_JavaIoFile
#define INCLUDE_ALL_JavaIoFile 0
#else
#define INCLUDE_ALL_JavaIoFile 1
#endif
#undef RESTRICT_JavaIoFile

#if __has_feature(nullability)
#pragma clang diagnostic push
#pragma GCC diagnostic ignored "-Wnullability"
#pragma GCC diagnostic ignored "-Wnullability-completeness"
#endif

#if !defined (JavaIoFile_) && (INCLUDE_ALL_JavaIoFile || defined(INCLUDE_JavaIoFile))
#define JavaIoFile_

#define RESTRICT_JavaIoSerializable 1
#define INCLUDE_JavaIoSerializable 1
#include "java/io/Serializable.h"

#define RESTRICT_JavaLangComparable 1
#define INCLUDE_JavaLangComparable 1
#include "java/lang/Comparable.h"

@class IOSObjectArray;
@class JavaLangBoolean;
@class JavaLangCharacter;
@class JavaLangInteger;
@class JavaLangLong;
@class JavaNetURI;
@class JavaNetURL;
@protocol JavaIoFileFilter;
@protocol JavaIoFilenameFilter;
@protocol JavaNioFilePath;

/*!
 @brief An abstract representation of file and directory pathnames.
 <p> User interfaces and operating systems use system-dependent <em>pathname
  strings</em> to name files and directories.  This class presents an
  abstract, system-independent view of hierarchical pathnames.  An 
 <em>abstract pathname</em> has two components: 
 <ol>
  <li> An optional system-dependent <em>prefix</em> string,
       such as a disk-drive specifier, <code>"/"</code>&nbsp;for the UNIX root
       directory, or <code>"\\\\"</code>&nbsp;for a Microsoft Windows UNC pathname, and 
 <li> A sequence of zero or more string <em>names</em>.
  </ol>
  The first name in an abstract pathname may be a directory name or, in the
  case of Microsoft Windows UNC pathnames, a hostname.  Each subsequent name
  in an abstract pathname denotes a directory; the last name may denote
  either a directory or a file.  The <em>empty</em> abstract pathname has no
  prefix and an empty name sequence. 
 <p> The conversion of a pathname string to or from an abstract pathname is
  inherently system-dependent.  When an abstract pathname is converted into a
  pathname string, each name is separated from the next by a single copy of
  the default <em>separator character</em>.  The default name-separator
  character is defined by the system property <code>file.separator</code>, and
  is made available in the public static fields <code><code>separator</code>
 </code> and <code><code>separatorChar</code></code> of this class.
  When a pathname string is converted into an abstract pathname, the names
  within it may be separated by the default name-separator character or by any
  other name-separator character that is supported by the underlying system. 
 <p> A pathname, whether abstract or in string form, may be either 
 <em>absolute</em> or <em>relative</em>.  An absolute pathname is complete in
  that no other information is required in order to locate the file that it
  denotes.  A relative pathname, in contrast, must be interpreted in terms of
  information taken from some other pathname.  By default the classes in the 
 <code>java.io</code> package always resolve relative pathnames against the
  current user directory.  This directory is named by the system property 
 <code>user.dir</code>, and is typically the directory in which the Java
  virtual machine was invoked. 
 <p> The <em>parent</em> of an abstract pathname may be obtained by invoking
  the <code>getParent</code> method of this class and consists of the pathname's
  prefix and each name in the pathname's name sequence except for the last.
  Each directory's absolute pathname is an ancestor of any <tt>File</tt>
  object with an absolute abstract pathname which begins with the directory's
  absolute pathname.  For example, the directory denoted by the abstract
  pathname <tt>"/usr"</tt> is an ancestor of the directory denoted by the
  pathname <tt>"/usr/local/bin"</tt>.
  
 <p> The prefix concept is used to handle root directories on UNIX platforms,
  and drive specifiers, root directories and UNC pathnames on Microsoft Windows platforms,
  as follows: 
 <ul>
  
 <li> For UNIX platforms, the prefix of an absolute pathname is always 
 <code>"/"</code>.  Relative pathnames have no prefix.  The abstract pathname
  denoting the root directory has the prefix <code>"/"</code> and an empty
  name sequence. 
 <li> For Microsoft Windows platforms, the prefix of a pathname that contains a drive
  specifier consists of the drive letter followed by <code>":"</code> and
  possibly followed by <code>"\\"</code> if the pathname is absolute.  The
  prefix of a UNC pathname is <code>"\\\\"</code>; the hostname and the share
  name are the first two names in the name sequence.  A relative pathname that
  does not specify a drive has no prefix. 
 </ul>
  
 <p> Instances of this class may or may not denote an actual file-system
  object such as a file or a directory.  If it does denote such an object
  then that object resides in a <i>partition</i>.  A partition is an
  operating system-specific portion of storage for a file system.  A single
  storage device (e.g. a physical disk-drive, flash memory, CD-ROM) may
  contain multiple partitions.  The object, if any, will reside on the
  partition <a name="partName">named</a> by some ancestor of the absolute
  form of this pathname. 
 <p> A file system may implement restrictions to certain operations on the
  actual file-system object, such as reading, writing, and executing.  These
  restrictions are collectively known as <i>access permissions</i>.  The file
  system may have multiple sets of access permissions on a single object.
  For example, one set may apply to the object's <i>owner</i>, and another
  may apply to all other users.  The access permissions on an object may
  cause some methods in this class to fail. 
 <p> Instances of the <code>File</code> class are immutable; that is, once
  created, the abstract pathname represented by a <code>File</code> object
  will never change. 
 <h3>Interoperability with <code>java.nio.file</code> package</h3>
  
 <p> The <a href="../../java/nio/file/package-summary.html"><code>java.nio.file</code></a>
  package defines interfaces and classes for the Java virtual machine to access
  files, file attributes, and file systems. This API may be used to overcome
  many of the limitations of the <code>java.io.File</code> class.
  The <code>toPath</code> method may be used to obtain a <code>Path</code>
  that uses the abstract path represented by a <code>File</code> object to
  locate a file. The resulting <code>Path</code> may be used with the <code>java.nio.file.Files</code>
  class to provide more efficient and extensive access to
  additional file operations, file attributes, and I/O exceptions to help
  diagnose errors when an operation on a file fails. 
 <p>On Android strings are converted to UTF-8 byte sequences when sending filenames to
  the operating system, and byte sequences returned by the operating system (from the
  various <code>list</code> methods) are converted to strings by decoding them as UTF-8
  byte sequences.
 @author unascribed
 @since JDK1.0
 */
@interface JavaIoFile : NSObject < JavaIoSerializable, JavaLangComparable >

#pragma mark Public

/*!
 @brief Creates a new <code>File</code> instance from a parent abstract
  pathname and a child pathname string.
 <p> If <code>parent</code> is <code>null</code> then the new 
 <code>File</code> instance is created as if by invoking the
  single-argument <code>File</code> constructor on the given 
 <code>child</code> pathname string. 
 <p> Otherwise the <code>parent</code> abstract pathname is taken to
  denote a directory, and the <code>child</code> pathname string is taken
  to denote either a directory or a file.  If the <code>child</code>
  pathname string is absolute then it is converted into a relative
  pathname in a system-dependent way.  If <code>parent</code> is the empty
  abstract pathname then the new <code>File</code> instance is created by
  converting <code>child</code> into an abstract pathname and resolving
  the result against a system-dependent default directory.  Otherwise each
  pathname string is converted into an abstract pathname and the child
  abstract pathname is resolved against the parent.
 @param parent The parent abstract pathname
 @param child The child pathname string
 @throw NullPointerException
 If <code>child</code> is <code>null</code>
 */
- (instancetype __nonnull)initWithJavaIoFile:(JavaIoFile *)parent
                                withNSString:(NSString *)child;

/*!
 @brief Creates a new <code>File</code> instance by converting the given
  pathname string into an abstract pathname.If the given string is
  the empty string, then the result is the empty abstract pathname.
 @param pathname A pathname string
 @throw NullPointerException
 If the <code>pathname</code> argument is <code>null</code>
 */
- (instancetype __nonnull)initWithNSString:(NSString *)pathname;

/*!
 @brief Creates a new <code>File</code> instance from a parent pathname string
  and a child pathname string.
 <p> If <code>parent</code> is <code>null</code> then the new 
 <code>File</code> instance is created as if by invoking the
  single-argument <code>File</code> constructor on the given 
 <code>child</code> pathname string. 
 <p> Otherwise the <code>parent</code> pathname string is taken to denote
  a directory, and the <code>child</code> pathname string is taken to
  denote either a directory or a file.  If the <code>child</code> pathname
  string is absolute then it is converted into a relative pathname in a
  system-dependent way.  If <code>parent</code> is the empty string then
  the new <code>File</code> instance is created by converting 
 <code>child</code> into an abstract pathname and resolving the result
  against a system-dependent default directory.  Otherwise each pathname
  string is converted into an abstract pathname and the child abstract
  pathname is resolved against the parent.
 @param parent The parent pathname string
 @param child The child pathname string
 @throw NullPointerException
 If <code>child</code> is <code>null</code>
 */
- (instancetype __nonnull)initWithNSString:(NSString *)parent
                              withNSString:(NSString *)child;

/*!
 @brief Creates a new <tt>File</tt> instance by converting the given 
 <tt>file:</tt> URI into an abstract pathname.
 <p> The exact form of a <tt>file:</tt> URI is system-dependent, hence
  the transformation performed by this constructor is also
  system-dependent. 
 <p> For a given abstract pathname <i>f</i> it is guaranteed that 
 <blockquote><tt>
  new File(</tt><i>&nbsp;f</i><tt>.<code>toURI</code>()).equals(</tt><i>&nbsp;f</i><tt>.<code>getAbsoluteFile</code>())
  </tt></blockquote>
  so long as the original abstract pathname, the URI, and the new abstract
  pathname are all created in (possibly different invocations of) the same
  Java virtual machine.  This relationship typically does not hold,
  however, when a <tt>file:</tt> URI that is created in a virtual machine
  on one operating system is converted into an abstract pathname in a
  virtual machine on a different operating system.
 @param uri An absolute, hierarchical URI with a scheme equal to
            <tt> "file"
  </tt> , a non-empty path component, and undefined          authority, query, and fragment components
 @throw NullPointerException
 If <tt>uri</tt> is <tt>null</tt>
 @throw IllegalArgumentException
 If the preconditions on the parameter do not hold
 - seealso: #toURI()
 - seealso: java.net.URI
 @since 1.4
 */
- (instancetype __nonnull)initWithJavaNetURI:(JavaNetURI *)uri;

/*!
 @brief Tests whether the application can execute the file denoted by this
  abstract pathname.
 @return <code>true</code> if and only if the abstract pathname exists
           <em>and</em> the application is allowed to execute the file
 @throw SecurityException
 If a security manager exists and its <code><code>java.lang.SecurityManager.checkExec(java.lang.String)</code>
 </code>
           method denies execute access to the file
 @since 1.6
 */
- (jboolean)canExecute;

/*!
 @brief Tests whether the application can read the file denoted by this
  abstract pathname.
 @return <code>true</code> if and only if the file specified by this
           abstract pathname exists <em>and</em> can be read by the
           application; <code>false</code> otherwise
 @throw SecurityException
 If a security manager exists and its <code><code>java.lang.SecurityManager.checkRead(java.lang.String)</code>
 </code>
           method denies read access to the file
 */
- (jboolean)canRead;

/*!
 @brief Tests whether the application can modify the file denoted by this
  abstract pathname.
 @return <code>true</code> if and only if the file system actually
           contains a file denoted by this abstract pathname <em>and</em>
           the application is allowed to write to the file;          
 <code>false</code> otherwise.
 @throw SecurityException
 If a security manager exists and its <code><code>java.lang.SecurityManager.checkWrite(java.lang.String)</code>
 </code>
           method denies write access to the file
 */
- (jboolean)canWrite;

/*!
 @brief Compares two abstract pathnames lexicographically.The ordering
  defined by this method depends upon the underlying system.
 On UNIX
  systems, alphabetic case is significant in comparing pathnames; on Microsoft Windows
  systems it is not.
 @param pathname The abstract pathname to be compared to this abstract                     pathname
 @return Zero if the argument is equal to this abstract pathname, a
           value less than zero if this abstract pathname is
           lexicographically less than the argument, or a value greater
           than zero if this abstract pathname is lexicographically
           greater than the argument
 @since 1.2
 */
- (jint)compareToWithId:(JavaIoFile *)pathname;

/*!
 @brief Atomically creates a new, empty file named by this abstract pathname if
  and only if a file with this name does not yet exist.The check for the
  existence of the file and the creation of the file if it does not exist
  are a single operation that is atomic with respect to all other
  filesystem activities that might affect the file.
 <P>
  Note: this method should <i>not</i> be used for file-locking, as
  the resulting protocol cannot be made to work reliably. The 
 <code>FileLock</code>
  facility should be used instead.
 @return <code>true</code> if the named file does not exist and was
           successfully created; <code>false</code> if the named file
           already exists
 @throw IOException
 If an I/O error occurred
 @throw SecurityException
 If a security manager exists and its <code><code>java.lang.SecurityManager.checkWrite(java.lang.String)</code>
 </code>
           method denies write access to the file
 @since 1.2
 */
- (jboolean)createNewFile;

/*!
 @brief Creates an empty file in the default temporary-file directory, using
  the given prefix and suffix to generate its name.Invoking this method
  is equivalent to invoking <code><code>createTempFile(prefix,&nbsp;suffix,&nbsp;null)</code>
 </code>.
 <p> The <code>Files.createTempFile</code>
  method provides an alternative method to create an
  empty file in the temporary-file directory. Files created by that method
  may have more restrictive access permissions to files created by this
  method and so may be more suited to security-sensitive applications.
 @param prefix The prefix string to be used in generating the file's                     name; must be at least three characters long
 @param suffix The suffix string to be used in generating the file's                     name; may be 
  <code> null </code> , in which case the                     suffix 
  <code> ".tmp" </code>  will be used
 @return An abstract pathname denoting a newly-created empty file
 @throw IllegalArgumentException
 If the <code>prefix</code> argument contains fewer than three
           characters
 @throw IOExceptionIf a file could not be created
 @throw SecurityException
 If a security manager exists and its <code><code>java.lang.SecurityManager.checkWrite(java.lang.String)</code>
 </code>
           method does not allow a file to be created
 @since 1.2
 - seealso: java.nio.file.Files#createTempDirectory(String,FileAttribute[])
 */
+ (JavaIoFile * __nonnull)createTempFileWithNSString:(NSString *)prefix
                                        withNSString:(NSString *)suffix;

/*!
 @brief <p> Creates a new empty file in the specified directory, using the
  given prefix and suffix strings to generate its name.If this method
  returns successfully then it is guaranteed that: 
 <ol>
  <li> The file denoted by the returned abstract pathname did not exist
       before this method was invoked, and 
 <li> Neither this method nor any of its variants will return the same
       abstract pathname again in the current invocation of the virtual
       machine.
 </ol>
  This method provides only part of a temporary-file facility.  To arrange
  for a file created by this method to be deleted automatically, use the 
 <code><code>deleteOnExit</code></code> method. 
 <p> The <code>prefix</code> argument must be at least three characters
  long.  It is recommended that the prefix be a short, meaningful string
  such as <code>"hjb"</code> or <code>"mail"</code>.  The 
 <code>suffix</code> argument may be <code>null</code>, in which case the
  suffix <code>".tmp"</code> will be used. 
 <p> To create the new file, the prefix and the suffix may first be
  adjusted to fit the limitations of the underlying platform.  If the
  prefix is too long then it will be truncated, but its first three
  characters will always be preserved.  If the suffix is too long then it
  too will be truncated, but if it begins with a period character
  (<code>'.'</code>) then the period and the first three characters
  following it will always be preserved.  Once these adjustments have been
  made the name of the new file will be generated by concatenating the
  prefix, five or more internally-generated characters, and the suffix. 
 <p> If the <code>directory</code> argument is <code>null</code> then the
  system-dependent default temporary-file directory will be used.  The
  default temporary-file directory is specified by the system property 
 <code>java.io.tmpdir</code>.  On UNIX systems the default value of this
  property is typically <code>"/tmp"</code> or <code>"/var/tmp"</code>; on
  Microsoft Windows systems it is typically <code>"C:\\WINNT\\TEMP"</code>.  A different
  value may be given to this system property when the Java virtual machine
  is invoked, but programmatic changes to this property are not guaranteed
  to have any effect upon the temporary directory used by this method.
 @param prefix The prefix string to be used in generating the file's                     name; must be at least three characters long
 @param suffix The suffix string to be used in generating the file's                     name; may be 
  <code> null </code> , in which case the                     suffix 
  <code> ".tmp" </code>  will be used
 @param directory The directory in which the file is to be created, or                     
  <code> null </code>  if the default temporary-file                     directory is to be used
 @return An abstract pathname denoting a newly-created empty file
 @throw IllegalArgumentException
 If the <code>prefix</code> argument contains fewer than three
           characters
 @throw IOExceptionIf a file could not be created
 @throw SecurityException
 If a security manager exists and its <code><code>java.lang.SecurityManager.checkWrite(java.lang.String)</code>
 </code>
           method does not allow a file to be created
 @since 1.2
 */
+ (JavaIoFile * __nonnull)createTempFileWithNSString:(NSString *)prefix
                                        withNSString:(NSString *)suffix
                                      withJavaIoFile:(JavaIoFile *)directory;

/*!
 @brief Deletes the file or directory denoted by this abstract pathname.If
  this pathname denotes a directory, then the directory must be empty in
  order to be deleted.
 <p> Note that the <code>java.nio.file.Files</code> class defines the <code>delete</code>
  method to throw an <code>IOException</code>
  when a file cannot be deleted. This is useful for error reporting and to
  diagnose why a file cannot be deleted.
 @return <code>true</code> if and only if the file or directory is
           successfully deleted; <code>false</code> otherwise
 @throw SecurityException
 If a security manager exists and its <code><code>java.lang.SecurityManager.checkDelete</code>
 </code> method denies
           delete access to the file
 */
- (jboolean)delete__;

/*!
 @brief Requests that the file or directory denoted by this abstract
  pathname be deleted when the virtual machine terminates.
 Files (or directories) are deleted in the reverse order that
  they are registered. Invoking this method to delete a file or
  directory that is already registered for deletion has no effect.
  Deletion will be attempted only for normal termination of the
  virtual machine, as defined by the Java Language Specification. 
 <p> Once deletion has been requested, it is not possible to cancel the
  request.  This method should therefore be used with care. 
 <P>
  Note: this method should <i>not</i> be used for file-locking, as
  the resulting protocol cannot be made to work reliably. The 
 <code>FileLock</code>
  facility should be used instead. 
 <p><i>Note that on Android, the application lifecycle does not include VM termination,
  so calling this method will not ensure that files are deleted</i>. Instead, you should
  use the most appropriate out of: 
 <ul>
  <li>Use a <code>finally</code> clause to manually invoke <code>delete</code>.
  <li>Maintain your own set of files to delete, and process it at an appropriate point
  in your application's lifecycle. 
 <li>Use the Unix trick of deleting the file as soon as all readers and writers have
  opened it. No new readers/writers will be able to access the file, but all existing
  ones will still have access until the last one closes the file. 
 </ul>
 @throw SecurityException
 If a security manager exists and its <code><code>java.lang.SecurityManager.checkDelete</code>
 </code> method denies
           delete access to the file
 - seealso: #delete
 @since 1.2
 */
- (void)deleteOnExit;

/*!
 @brief Tests this abstract pathname for equality with the given object.
 Returns <code>true</code> if and only if the argument is not 
 <code>null</code> and is an abstract pathname that denotes the same file
  or directory as this abstract pathname.  Whether or not two abstract
  pathnames are equal depends upon the underlying system.  On UNIX
  systems, alphabetic case is significant in comparing pathnames; on Microsoft Windows
  systems it is not.
 @param obj The object to be compared with this abstract pathname
 @return <code>true</code> if and only if the objects are the same;
           <code>false</code> otherwise
 */
- (jboolean)isEqual:(id)obj;

/*!
 @brief Tests whether the file or directory denoted by this abstract pathname
  exists.
 @return <code>true</code> if and only if the file or directory denoted
           by this abstract pathname exists; <code>false</code> otherwise
 @throw SecurityException
 If a security manager exists and its <code><code>java.lang.SecurityManager.checkRead(java.lang.String)</code>
 </code>
           method denies read access to the file or directory
 */
- (jboolean)exists;

/*!
 @brief Returns the absolute form of this abstract pathname.Equivalent to 
 <code>new&nbsp;File(this.
 <code>getAbsolutePath</code>)</code>.
 @return The absolute abstract pathname denoting the same file or
           directory as this abstract pathname
 @throw SecurityException
 If a required system property value cannot be accessed.
 @since 1.2
 */
- (JavaIoFile * __nonnull)getAbsoluteFile;

/*!
 @brief Returns the absolute path of this file.An absolute path is a path that starts at a root
  of the file system.
 On Android, there is only one root: <code>/</code>.
  
 <p>A common use for absolute paths is when passing paths to a <code>Process</code> as
  command-line arguments, to remove the requirement implied by relative paths, that the
  child must have the same working directory as its parent.
 @return The absolute pathname string denoting the same file or
           directory as this abstract pathname
 - seealso: java.io.File#isAbsolute()
 */
- (NSString * __nonnull)getAbsolutePath;

/*!
 @brief Returns the canonical form of this abstract pathname.Equivalent to 
 <code>new&nbsp;File(this.
 <code>getCanonicalPath</code>)</code>.
 @return The canonical pathname string denoting the same file or
           directory as this abstract pathname
 @throw IOException
 If an I/O error occurs, which is possible because the
           construction of the canonical pathname may require
           filesystem queries
 @throw SecurityException
 If a required system property value cannot be accessed, or
           if a security manager exists and its <code><code>java.lang.SecurityManager.checkRead</code>
 </code> method denies
           read access to the file
 @since 1.2
 - seealso: Path#toRealPath
 */
- (JavaIoFile * __nonnull)getCanonicalFile;

/*!
 @brief Returns the canonical pathname string of this abstract pathname.
 <p> A canonical pathname is both absolute and unique.  The precise
  definition of canonical form is system-dependent.  This method first
  converts this pathname to absolute form if necessary, as if by invoking the 
 <code>getAbsolutePath</code> method, and then maps it to its unique form in a
  system-dependent way.  This typically involves removing redundant names
  such as <tt>"."</tt> and <tt>".."</tt> from the pathname, resolving
  symbolic links (on UNIX platforms), and converting drive letters to a
  standard case (on Microsoft Windows platforms). 
 <p> Every pathname that denotes an existing file or directory has a
  unique canonical form.  Every pathname that denotes a nonexistent file
  or directory also has a unique canonical form.  The canonical form of
  the pathname of a nonexistent file or directory may be different from
  the canonical form of the same pathname after the file or directory is
  created.  Similarly, the canonical form of the pathname of an existing
  file or directory may be different from the canonical form of the same
  pathname after the file or directory is deleted.
 @return The canonical pathname string denoting the same file or
           directory as this abstract pathname
 @throw IOException
 If an I/O error occurs, which is possible because the
           construction of the canonical pathname may require
           filesystem queries
 @throw SecurityException
 If a required system property value cannot be accessed, or
           if a security manager exists and its <code><code>java.lang.SecurityManager.checkRead</code>
 </code> method denies
           read access to the file
 @since JDK1.1
 - seealso: Path#toRealPath
 */
- (NSString * __nonnull)getCanonicalPath;

/*!
 @brief Returns the number of unallocated bytes in the partition <a href="#partName">
 named</a> by this abstract path name.
 <p> The returned number of unallocated bytes is a hint, but not
  a guarantee, that it is possible to use most or any of these
  bytes.  The number of unallocated bytes is most likely to be
  accurate immediately after this call.  It is likely to be made
  inaccurate by any external I/O operations including those made
  on the system outside of this virtual machine.  This method
  makes no guarantee that write operations to this file system
  will succeed.
 @return The number of unallocated bytes on the partition or <tt>0L</tt>
           if the abstract pathname does not name a partition.  This
           value will be less than or equal to the total file system size
           returned by <code>getTotalSpace</code>.
 @throw SecurityException
 If a security manager has been installed and it denies
           <code>RuntimePermission</code><tt>("getFileSystemAttributes")</tt>
           or its <code>SecurityManager.checkRead(String)</code> method denies
           read access to the file named by this abstract pathname
 @since 1.6
 */
- (jlong)getFreeSpace;

/*!
 @brief Returns the name of the file or directory denoted by this abstract
  pathname.This is just the last name in the pathname's name
  sequence.
 If the pathname's name sequence is empty, then the empty
  string is returned.
 @return The name of the file or directory denoted by this abstract
           pathname, or the empty string if this pathname's name sequence
           is empty
 */
- (NSString * __nonnull)getName;

/*!
 @brief Returns the pathname string of this abstract pathname's parent, or 
 <code>null</code> if this pathname does not name a parent directory.
 <p> The <em>parent</em> of an abstract pathname consists of the
  pathname's prefix, if any, and each name in the pathname's name
  sequence except for the last.  If the name sequence is empty then
  the pathname does not name a parent directory.
 @return The pathname string of the parent directory named by this
           abstract pathname, or <code>null</code> if this pathname
           does not name a parent
 */
- (NSString * __nullable)getParent;

/*!
 @brief Returns the abstract pathname of this abstract pathname's parent,
  or <code>null</code> if this pathname does not name a parent
  directory.
 <p> The <em>parent</em> of an abstract pathname consists of the
  pathname's prefix, if any, and each name in the pathname's name
  sequence except for the last.  If the name sequence is empty then
  the pathname does not name a parent directory.
 @return The abstract pathname of the parent directory named by this
           abstract pathname, or <code>null</code> if this pathname
           does not name a parent
 @since 1.2
 */
- (JavaIoFile * __nullable)getParentFile;

/*!
 @brief Converts this abstract pathname into a pathname string.The resulting
  string uses the <code>default name-separator character</code> to
  separate the names in the name sequence.
 @return The string form of this abstract pathname
 */
- (NSString * __nonnull)getPath;

/*!
 @brief Returns the size of the partition <a href="#partName">named</a> by this
  abstract pathname.
 @return The size, in bytes, of the partition or <tt>0L</tt> if this
           abstract pathname does not name a partition
 @throw SecurityException
 If a security manager has been installed and it denies
           <code>RuntimePermission</code><tt>("getFileSystemAttributes")</tt>
           or its <code>SecurityManager.checkRead(String)</code> method denies
           read access to the file named by this abstract pathname
 @since 1.6
 */
- (jlong)getTotalSpace;

/*!
 @brief Returns the number of bytes available to this virtual machine on the
  partition <a href="#partName">named</a> by this abstract pathname.When
  possible, this method checks for write permissions and other operating
  system restrictions and will therefore usually provide a more accurate
  estimate of how much new data can actually be written than <code>getFreeSpace</code>
 .
 <p> The returned number of available bytes is a hint, but not a
  guarantee, that it is possible to use most or any of these bytes.  The
  number of unallocated bytes is most likely to be accurate immediately
  after this call.  It is likely to be made inaccurate by any external
  I/O operations including those made on the system outside of this
  virtual machine.  This method makes no guarantee that write operations
  to this file system will succeed. 
 <p> On Android (and other Unix-based systems), this method returns the number of free bytes
  available to non-root users, regardless of whether you're actually running as root,
  and regardless of any quota or other restrictions that might apply to the user.
  (The <code>getFreeSpace</code> method returns the number of bytes potentially available to root.)
 @return The number of available bytes on the partition or <tt>0L</tt>
           if the abstract pathname does not name a partition.  On
           systems where this information is not available, this method
           will be equivalent to a call to <code>getFreeSpace</code>.
 @throw SecurityException
 If a security manager has been installed and it denies
           <code>RuntimePermission</code><tt>("getFileSystemAttributes")</tt>
           or its <code>SecurityManager.checkRead(String)</code> method denies
           read access to the file named by this abstract pathname
 @since 1.6
 */
- (jlong)getUsableSpace;

/*!
 @brief Computes a hash code for this abstract pathname.Because equality of
  abstract pathnames is inherently system-dependent, so is the computation
  of their hash codes.
 On UNIX systems, the hash code of an abstract
  pathname is equal to the exclusive <em>or</em> of the hash code
  of its pathname string and the decimal value 
 <code>1234321</code>.  On Microsoft Windows systems, the hash
  code is equal to the exclusive <em>or</em> of the hash code of
  its pathname string converted to lower case and the decimal
  value <code>1234321</code>.  Locale is not taken into account on
  lowercasing the pathname string.
 @return A hash code for this abstract pathname
 */
- (NSUInteger)hash;

/*!
 @brief Tests whether this abstract pathname is absolute.The definition of
  absolute pathname is system dependent.
 On Android, absolute paths start with
  the character '/'.
 @return <code>true</code> if this abstract pathname is absolute,
           <code>false</code> otherwise
 */
- (jboolean)isAbsolute;

/*!
 @brief Tests whether the file denoted by this abstract pathname is a
  directory.
 <p> Where it is required to distinguish an I/O exception from the case
  that the file is not a directory, or where several attributes of the
  same file are required at the same time, then the <code>Files.readAttributes</code>
  method may be used.
 @return <code>true</code> if and only if the file denoted by this
           abstract pathname exists <em>and</em> is a directory;
           <code>false</code> otherwise
 @throw SecurityException
 If a security manager exists and its <code><code>java.lang.SecurityManager.checkRead(java.lang.String)</code>
 </code>
           method denies read access to the file
 */
- (jboolean)isDirectory;

/*!
 @brief Tests whether the file denoted by this abstract pathname is a normal
  file.A file is <em>normal</em> if it is not a directory and, in
  addition, satisfies other system-dependent criteria.
 Any non-directory
  file created by a Java application is guaranteed to be a normal file. 
 <p> Where it is required to distinguish an I/O exception from the case
  that the file is not a normal file, or where several attributes of the
  same file are required at the same time, then the <code>Files.readAttributes</code>
  method may be used.
 @return <code>true</code> if and only if the file denoted by this
           abstract pathname exists <em>and</em> is a normal file;
           <code>false</code> otherwise
 @throw SecurityException
 If a security manager exists and its <code><code>java.lang.SecurityManager.checkRead(java.lang.String)</code>
 </code>
           method denies read access to the file
 */
- (jboolean)isFile;

/*!
 @brief Tests whether the file named by this abstract pathname is a hidden
  file.The exact definition of <em>hidden</em> is system-dependent.
 On
  UNIX systems, a file is considered to be hidden if its name begins with
  a period character (<code>'.'</code>).  On Microsoft Windows systems, a file is
  considered to be hidden if it has been marked as such in the filesystem.
 @return <code>true</code> if and only if the file denoted by this
           abstract pathname is hidden according to the conventions of the
           underlying platform
 @throw SecurityException
 If a security manager exists and its <code><code>java.lang.SecurityManager.checkRead(java.lang.String)</code>
 </code>
           method denies read access to the file
 @since 1.2
 */
- (jboolean)isHidden;

/*!
 @brief Returns the time that the file denoted by this abstract pathname was
  last modified.
 <p> Where it is required to distinguish an I/O exception from the case
  where <code>0L</code> is returned, or where several attributes of the
  same file are required at the same time, or where the time of last
  access or the creation time are required, then the <code>Files.readAttributes</code>
  method may be used.
 @return A <code>long</code> value representing the time the file was
           last modified, measured in milliseconds since the epoch
           (00:00:00 GMT, January 1, 1970), or <code>0L</code> if the
           file does not exist or if an I/O error occurs
 @throw SecurityException
 If a security manager exists and its <code><code>java.lang.SecurityManager.checkRead(java.lang.String)</code>
 </code>
           method denies read access to the file
 */
- (jlong)lastModified;

/*!
 @brief Returns the length of the file denoted by this abstract pathname.
 The return value is unspecified if this pathname denotes a directory. 
 <p> Where it is required to distinguish an I/O exception from the case
  that <code>0L</code> is returned, or where several attributes of the same file
  are required at the same time, then the <code>Files.readAttributes</code>
  method may be used.
 @return The length, in bytes, of the file denoted by this abstract
           pathname, or <code>0L</code> if the file does not exist.  Some
           operating systems may return <code>0L</code> for pathnames
           denoting system-dependent entities such as devices or pipes.
 @throw SecurityException
 If a security manager exists and its <code><code>java.lang.SecurityManager.checkRead(java.lang.String)</code>
 </code>
           method denies read access to the file
 */
- (jlong)length;

/*!
 @brief Returns an array of strings naming the files and directories in the
  directory denoted by this abstract pathname.
 <p> If this abstract pathname does not denote a directory, then this
  method returns <code>null</code>.  Otherwise an array of strings is
  returned, one for each file or directory in the directory.  Names
  denoting the directory itself and the directory's parent directory are
  not included in the result.  Each string is a file name rather than a
  complete path. 
 <p> There is no guarantee that the name strings in the resulting array
  will appear in any specific order; they are not, in particular,
  guaranteed to appear in alphabetical order. 
 <p> Note that the <code>java.nio.file.Files</code> class defines the <code>newDirectoryStream</code>
  method to
  open a directory and iterate over the names of the files in the directory.
  This may use less resources when working with very large directories, and
  may be more responsive when working with remote directories.
 @return An array of strings naming the files and directories in the
           directory denoted by this abstract pathname.  The array will be
           empty if the directory is empty.  Returns <code>null</code> if
           this abstract pathname does not denote a directory, or if an
           I/O error occurs.
 @throw SecurityException
 If a security manager exists and its <code>SecurityManager.checkRead(String)</code>
  method denies read access to
           the directory
 */
- (IOSObjectArray * __nullable)list;

/*!
 @brief Returns an array of strings naming the files and directories in the
  directory denoted by this abstract pathname that satisfy the specified
  filter.The behavior of this method is the same as that of the 
 <code>list()</code> method, except that the strings in the returned array
  must satisfy the filter.
 If the given <code>filter</code> is <code>null</code>
  then all names are accepted.  Otherwise, a name satisfies the filter if
  and only if the value <code>true</code> results when the <code>FilenameFilter.accept(File,&nbsp;String)</code>
  method
  of the filter is invoked on this abstract pathname and the name of a
  file or directory in the directory that it denotes.
 @param filter A filename filter
 @return An array of strings naming the files and directories in the
           directory denoted by this abstract pathname that were accepted
           by the given <code>filter</code>.  The array will be empty if the
           directory is empty or if no names were accepted by the filter.
           Returns <code>null</code> if this abstract pathname does not denote
           a directory, or if an I/O error occurs.
 @throw SecurityException
 If a security manager exists and its <code>SecurityManager.checkRead(String)</code>
  method denies read access to
           the directory
 - seealso: java.nio.file.Files#newDirectoryStream(Path,String)
 */
- (IOSObjectArray * __nullable)listWithJavaIoFilenameFilter:(id<JavaIoFilenameFilter>)filter;

/*!
 @brief Returns an array of abstract pathnames denoting the files in the
  directory denoted by this abstract pathname.
 <p> If this abstract pathname does not denote a directory, then this
  method returns <code>null</code>.  Otherwise an array of <code>File</code> objects
  is returned, one for each file or directory in the directory.  Pathnames
  denoting the directory itself and the directory's parent directory are
  not included in the result.  Each resulting abstract pathname is
  constructed from this abstract pathname using the <code>File(File,&nbsp;String)</code>
  constructor.  Therefore if this
  pathname is absolute then each resulting pathname is absolute; if this
  pathname is relative then each resulting pathname will be relative to
  the same directory. 
 <p> There is no guarantee that the name strings in the resulting array
  will appear in any specific order; they are not, in particular,
  guaranteed to appear in alphabetical order. 
 <p> Note that the <code>java.nio.file.Files</code> class defines the <code>newDirectoryStream</code>
  method
  to open a directory and iterate over the names of the files in the
  directory. This may use less resources when working with very large
  directories.
 @return An array of abstract pathnames denoting the files and
           directories in the directory denoted by this abstract pathname.
           The array will be empty if the directory is empty.  Returns          
 <code>null</code> if this abstract pathname does not denote a
           directory, or if an I/O error occurs.
 @throw SecurityException
 If a security manager exists and its <code>SecurityManager.checkRead(String)</code>
  method denies read access to
           the directory
 @since 1.2
 */
- (IOSObjectArray * __nullable)listFiles;

/*!
 @brief Returns an array of abstract pathnames denoting the files and
  directories in the directory denoted by this abstract pathname that
  satisfy the specified filter.The behavior of this method is the same
  as that of the <code>listFiles()</code> method, except that the pathnames in
  the returned array must satisfy the filter.
 If the given <code>filter</code>
  is <code>null</code> then all pathnames are accepted.  Otherwise, a pathname
  satisfies the filter if and only if the value <code>true</code> results when
  the <code>FileFilter.accept(File)</code> method of the
  filter is invoked on the pathname.
 @param filter A file filter
 @return An array of abstract pathnames denoting the files and
           directories in the directory denoted by this abstract pathname.
           The array will be empty if the directory is empty.  Returns          
 <code>null</code> if this abstract pathname does not denote a
           directory, or if an I/O error occurs.
 @throw SecurityException
 If a security manager exists and its <code>SecurityManager.checkRead(String)</code>
  method denies read access to
           the directory
 @since 1.2
 - seealso: java.nio.file.Files#newDirectoryStream(Path,java.nio.file.DirectoryStream.Filter)
 */
- (IOSObjectArray * __nullable)listFilesWithJavaIoFileFilter:(id<JavaIoFileFilter>)filter;

/*!
 @brief Returns an array of abstract pathnames denoting the files and
  directories in the directory denoted by this abstract pathname that
  satisfy the specified filter.The behavior of this method is the same
  as that of the <code>listFiles()</code> method, except that the pathnames in
  the returned array must satisfy the filter.
 If the given <code>filter</code>
  is <code>null</code> then all pathnames are accepted.  Otherwise, a pathname
  satisfies the filter if and only if the value <code>true</code> results when
  the <code>FilenameFilter.accept(File,&nbsp;String)</code>
  method of the filter is
  invoked on this abstract pathname and the name of a file or directory in
  the directory that it denotes.
 @param filter A filename filter
 @return An array of abstract pathnames denoting the files and
           directories in the directory denoted by this abstract pathname.
           The array will be empty if the directory is empty.  Returns          
 <code>null</code> if this abstract pathname does not denote a
           directory, or if an I/O error occurs.
 @throw SecurityException
 If a security manager exists and its <code>SecurityManager.checkRead(String)</code>
  method denies read access to
           the directory
 @since 1.2
 - seealso: java.nio.file.Files#newDirectoryStream(Path,String)
 */
- (IOSObjectArray * __nullable)listFilesWithJavaIoFilenameFilter:(id<JavaIoFilenameFilter>)filter;

/*!
 @brief Returns the file system roots.On Android and other Unix systems, there is
  a single root, <code>/</code>.
 */
+ (IOSObjectArray * __nonnull)listRoots;

/*!
 @brief Creates the directory named by this abstract pathname.
 @return <code>true</code> if and only if the directory was
           created; <code>false</code> otherwise
 @throw SecurityException
 If a security manager exists and its <code><code>java.lang.SecurityManager.checkWrite(java.lang.String)</code>
 </code>
           method does not permit the named directory to be created
 */
- (jboolean)mkdir;

/*!
 @brief Creates the directory named by this abstract pathname, including any
  necessary but nonexistent parent directories.Note that if this
  operation fails it may have succeeded in creating some of the necessary
  parent directories.
 @return <code>true</code> if and only if the directory was created,
           along with all necessary parent directories; <code>false</code>
           otherwise
 @throw SecurityException
 If a security manager exists and its <code><code>java.lang.SecurityManager.checkRead(java.lang.String)</code>
 </code>
           method does not permit verification of the existence of the
           named directory and all necessary parent directories; or if
           the <code><code>java.lang.SecurityManager.checkWrite(java.lang.String)</code>
 </code>
           method does not permit the named directory and all necessary
           parent directories to be created
 */
- (jboolean)mkdirs;

/*!
 @brief Renames the file denoted by this abstract pathname.
 <p>Many failures are possible. Some of the more likely failures include: 
 <ul>
  <li>Write permission is required on the directories containing both the source and
  destination paths. 
 <li>Search permission is required for all parents of both paths. 
 <li>Both paths be on the same mount point. On Android, applications are most likely to hit
  this restriction when attempting to copy between internal storage and an SD card. 
 </ul>
  
 <p>The return value should always be checked to make sure
  that the rename operation was successful. 
 <p> Note that the <code>java.nio.file.Files</code> class defines the <code>move</code>
  method to move or rename a file in a
  platform independent manner.
 @param dest The new abstract pathname for the named file
 @return <code>true</code> if and only if the renaming succeeded;
           <code>false</code> otherwise
 @throw SecurityException
 If a security manager exists and its <code><code>java.lang.SecurityManager.checkWrite(java.lang.String)</code>
 </code>
           method denies write access to either the old or new pathnames
 @throw NullPointerException
 If parameter <code>dest</code> is <code>null</code>
 */
- (jboolean)renameToWithJavaIoFile:(JavaIoFile *)dest;

/*!
 @brief A convenience method to set the owner's execute permission for this
  abstract pathname.
 <p>An invocation of this method of the form <tt>file.setExcutable(arg)</tt>
  behaves in exactly the same way as the invocation 
 @code

      file.setExecutable(arg, true) 
@endcode
 @param executable If 
  <code> true </code> , sets the access permission to allow execute           operations; if 
  <code> false </code>  to disallow execute operations
 @return <code>true</code> if and only if the operation succeeded.  The
            operation will fail if the user does not have permission to
            change the access permissions of this abstract pathname.  If           
 <code>executable</code> is <code>false</code> and the underlying
            file system does not implement an execute permission, then the
            operation will fail.
 @throw SecurityException
 If a security manager exists and its <code><code>java.lang.SecurityManager.checkWrite(java.lang.String)</code>
 </code>
           method denies write access to the file
 @since 1.6
 */
- (jboolean)setExecutableWithBoolean:(jboolean)executable;

/*!
 @brief Sets the owner's or everybody's execute permission for this abstract
  pathname.
 <p> The <code>java.nio.file.Files</code> class defines methods that operate on
  file attributes including file permissions. This may be used when finer
  manipulation of file permissions is required.
 @param executable If 
  <code> true </code> , sets the access permission to allow execute           operations; if 
  <code> false </code>  to disallow execute operations
 @param ownerOnly If 
  <code> true </code> , the execute permission applies only to the           owner's execute permission; otherwise, it applies to everybody.
            If the underlying file system can not distinguish the owner's
            execute permission from that of others, then the permission will
            apply to everybody, regardless of this value.
 @return <code>true</code> if and only if the operation succeeded.  The
           operation will fail if the user does not have permission to
           change the access permissions of this abstract pathname.  If          
 <code>executable</code> is <code>false</code> and the underlying
           file system does not implement an execute permission, then the
           operation will fail.
 @throw SecurityException
 If a security manager exists and its <code><code>java.lang.SecurityManager.checkWrite(java.lang.String)</code>
 </code>
           method denies write access to the file
 @since 1.6
 */
- (jboolean)setExecutableWithBoolean:(jboolean)executable
                         withBoolean:(jboolean)ownerOnly;

/*!
 @brief Sets the last-modified time of the file or directory named by this
  abstract pathname.
 <p> All platforms support file-modification times to the nearest second,
  but some provide more precision.  The argument will be truncated to fit
  the supported precision.  If the operation succeeds and no intervening
  operations on the file take place, then the next invocation of the 
 <code><code>lastModified</code></code> method will return the (possibly
  truncated) <code>time</code> argument that was passed to this method.
 @param time The new last-modified time, measured in milliseconds since                the epoch (00:00:00 GMT, January 1, 1970)
 @return <code>true</code> if and only if the operation succeeded;
           <code>false</code> otherwise
 @throw IllegalArgumentExceptionIf the argument is negative
 @throw SecurityException
 If a security manager exists and its <code><code>java.lang.SecurityManager.checkWrite(java.lang.String)</code>
 </code>
           method denies write access to the named file
 @since 1.2
 */
- (jboolean)setLastModifiedWithLong:(jlong)time;

/*!
 @brief A convenience method to set the owner's read permission for this abstract
  pathname.
 <p>An invocation of this method of the form <tt>file.setReadable(arg)</tt>
  behaves in exactly the same way as the invocation 
 @code

      file.setReadable(arg, true) 
@endcode
 @param readable If 
  <code> true </code> , sets the access permission to allow read           operations; if 
  <code> false </code>  to disallow read operations
 @return <code>true</code> if and only if the operation succeeded.  The
           operation will fail if the user does not have permission to
           change the access permissions of this abstract pathname.  If          
 <code>readable</code> is <code>false</code> and the underlying
           file system does not implement a read permission, then the
           operation will fail.
 @throw SecurityException
 If a security manager exists and its <code><code>java.lang.SecurityManager.checkWrite(java.lang.String)</code>
 </code>
           method denies write access to the file
 @since 1.6
 */
- (jboolean)setReadableWithBoolean:(jboolean)readable;

/*!
 @brief Sets the owner's or everybody's read permission for this abstract
  pathname.
 <p> The <code>java.nio.file.Files</code> class defines methods that operate on
  file attributes including file permissions. This may be used when finer
  manipulation of file permissions is required.
 @param readable If 
  <code> true </code> , sets the access permission to allow read           operations; if 
  <code> false </code>  to disallow read operations
 @param ownerOnly If 
  <code> true </code> , the read permission applies only to the           owner's read permission; otherwise, it applies to everybody.  If
            the underlying file system can not distinguish the owner's read
            permission from that of others, then the permission will apply to
            everybody, regardless of this value.
 @return <code>true</code> if and only if the operation succeeded.  The
           operation will fail if the user does not have permission to
           change the access permissions of this abstract pathname.  If          
 <code>readable</code> is <code>false</code> and the underlying
           file system does not implement a read permission, then the
           operation will fail.
 @throw SecurityException
 If a security manager exists and its <code><code>java.lang.SecurityManager.checkWrite(java.lang.String)</code>
 </code>
           method denies write access to the file
 @since 1.6
 */
- (jboolean)setReadableWithBoolean:(jboolean)readable
                       withBoolean:(jboolean)ownerOnly;

/*!
 @brief Marks the file or directory named by this abstract pathname so that
  only read operations are allowed.After invoking this method the file
  or directory will not change until it is either deleted or marked
  to allow write access.
 Whether or not a read-only file or
  directory may be deleted depends upon the underlying system.
 @return <code>true</code> if and only if the operation succeeded;
           <code>false</code> otherwise
 @throw SecurityException
 If a security manager exists and its <code><code>java.lang.SecurityManager.checkWrite(java.lang.String)</code>
 </code>
           method denies write access to the named file
 @since 1.2
 */
- (jboolean)setReadOnly;

/*!
 @brief A convenience method to set the owner's write permission for this abstract
  pathname.
 <p> An invocation of this method of the form <tt>file.setWritable(arg)</tt>
  behaves in exactly the same way as the invocation 
 @code

      file.setWritable(arg, true) 
@endcode
 @param writable If 
  <code> true </code> , sets the access permission to allow write           operations; if 
  <code> false </code>  to disallow write operations
 @return <code>true</code> if and only if the operation succeeded.  The
           operation will fail if the user does not have permission to
           change the access permissions of this abstract pathname.
 @throw SecurityException
 If a security manager exists and its <code><code>java.lang.SecurityManager.checkWrite(java.lang.String)</code>
 </code>
           method denies write access to the file
 @since 1.6
 */
- (jboolean)setWritableWithBoolean:(jboolean)writable;

/*!
 @brief Sets the owner's or everybody's write permission for this abstract
  pathname.
 <p> The <code>java.nio.file.Files</code> class defines methods that operate on
  file attributes including file permissions. This may be used when finer
  manipulation of file permissions is required.
 @param writable If 
  <code> true </code> , sets the access permission to allow write           operations; if 
  <code> false </code>  to disallow write operations
 @param ownerOnly If 
  <code> true </code> , the write permission applies only to the           owner's write permission; otherwise, it applies to everybody.  If
            the underlying file system can not distinguish the owner's write
            permission from that of others, then the permission will apply to
            everybody, regardless of this value.
 @return <code>true</code> if and only if the operation succeeded. The
           operation will fail if the user does not have permission to change
           the access permissions of this abstract pathname.
 @throw SecurityException
 If a security manager exists and its <code><code>java.lang.SecurityManager.checkWrite(java.lang.String)</code>
 </code>
           method denies write access to the named file
 @since 1.6
 */
- (jboolean)setWritableWithBoolean:(jboolean)writable
                       withBoolean:(jboolean)ownerOnly;

/*!
 @brief Returns a <code>java.nio.file.Path</code> object constructed from the
  this abstract path.The resulting <code>Path</code> is associated with the 
 <code>default-filesystem</code>.
 <p> The first invocation of this method works as if invoking it were
  equivalent to evaluating the expression: 
 <blockquote>@code

  <code>FileSystems.getDefault</code>().<code>getPath</code>
 (this.<code>getPath</code>());
   
@endcode</blockquote>
  Subsequent invocations of this method return the same <code>Path</code>.
  
 <p> If this abstract pathname is the empty abstract pathname then this
  method returns a <code>Path</code> that may be used to access the current
  user directory.
 @return a <code>Path</code> constructed from this abstract path
 @throw java.nio.file.InvalidPathException
 if a <code>Path</code> object cannot be constructed from the abstract
           path (see <code>FileSystem.getPath</code>)
 @since 1.7
 - seealso: Path#toFile
 */
- (id<JavaNioFilePath> __nonnull)toPath;

/*!
 @brief Returns the pathname string of this abstract pathname.This is just the
  string returned by the <code><code>getPath</code></code> method.
 @return The string form of this abstract pathname
 */
- (NSString * __nonnull)description;

/*!
 @brief Constructs a <tt>file:</tt> URI that represents this abstract pathname.
 <p> The exact form of the URI is system-dependent.  If it can be
  determined that the file denoted by this abstract pathname is a
  directory, then the resulting URI will end with a slash. 
 <p> For a given abstract pathname <i>f</i>, it is guaranteed that 
 <blockquote><tt>
  new <code>File</code>(</tt><i>&nbsp;f</i><tt>.toURI()).equals(</tt><i>&nbsp;f</i><tt>.<code>getAbsoluteFile</code>())
  </tt></blockquote>
  so long as the original abstract pathname, the URI, and the new abstract
  pathname are all created in (possibly different invocations of) the same
  Java virtual machine.  Due to the system-dependent nature of abstract
  pathnames, however, this relationship typically does not hold when a 
 <tt>file:</tt> URI that is created in a virtual machine on one operating
  system is converted into an abstract pathname in a virtual machine on a
  different operating system. 
 <p> Note that when this abstract pathname represents a UNC pathname then
  all components of the UNC (including the server name component) are encoded
  in the <code>URI</code> path. The authority component is undefined, meaning
  that it is represented as <code>null</code>. The <code>Path</code> class defines the 
 <code>toUri</code> method to encode the server name in the authority
  component of the resulting <code>URI</code>. The <code>toPath</code> method
  may be used to obtain a <code>Path</code> representing this abstract pathname.
 @return An absolute, hierarchical URI with a scheme equal to
           <tt>"file"</tt>, a path representing this abstract pathname,
           and undefined authority, query, and fragment components
 @throw SecurityExceptionIf a required system property value cannot
  be accessed.
 - seealso: #File(java.net.URI)
 - seealso: java.net.URI
 - seealso: java.net.URI#toURL()
 @since 1.4
 */
- (JavaNetURI * __nonnull)toURI;

/*!
 @brief Converts this abstract pathname into a <code>file:</code> URL.The
  exact form of the URL is system-dependent.
 If it can be determined that
  the file denoted by this abstract pathname is a directory, then the
  resulting URL will end with a slash.
 @return A URL object representing the equivalent file URL
 @throw MalformedURLException
 If the path cannot be parsed as a URL
 - seealso: #toURI()
 - seealso: java.net.URI
 - seealso: java.net.URI#toURL()
 - seealso: java.net.URL
 @since 1.2
 */
- (JavaNetURL * __nonnull)toURL;

#pragma mark Package-Private

/*!
 @brief Returns the length of this abstract pathname's prefix.
 For use by FileSystem classes.
 */
- (jint)getPrefixLength;

/*!
 @brief Check if the file has an invalid path.Currently, the inspection of
  a file path is very limited, and it only covers Nul character check.
 Returning true means the path is definitely invalid/garbage. But
  returning false does not guarantee that the path is valid.
 @return true if the file path is invalid.
 */
- (jboolean)isInvalid;

// Disallowed inherited constructors, do not use.

- (instancetype __nonnull)init NS_UNAVAILABLE;

@end

J2OBJC_STATIC_INIT(JavaIoFile)

/*!
 @brief The system-dependent default name-separator character.This field is
  initialized to contain the first character of the value of the system
  property <code>file.separator</code>.
 On UNIX systems the value of this
  field is <code>'/'</code>; on Microsoft Windows systems it is <code>'\\'</code>.
 - seealso: java.lang.System#getProperty(java.lang.String)
 */
inline jchar JavaIoFile_get_separatorChar(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT jchar JavaIoFile_separatorChar;
J2OBJC_STATIC_FIELD_PRIMITIVE_FINAL(JavaIoFile, separatorChar, jchar)

/*!
 @brief The system-dependent default name-separator character, represented as a
  string for convenience.This string contains a single character, namely 
 <code><code>separatorChar</code></code>.
 */
inline NSString *JavaIoFile_get_separator(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT NSString *JavaIoFile_separator;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaIoFile, separator, NSString *)

/*!
 @brief The system-dependent path-separator character.This field is
  initialized to contain the first character of the value of the system
  property <code>path.separator</code>.
 This character is used to
  separate filenames in a sequence of files given as a <em>path list</em>.
  On UNIX systems, this character is <code>':'</code>; on Microsoft Windows systems it
  is <code>';'</code>.
 - seealso: java.lang.System#getProperty(java.lang.String)
 */
inline jchar JavaIoFile_get_pathSeparatorChar(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT jchar JavaIoFile_pathSeparatorChar;
J2OBJC_STATIC_FIELD_PRIMITIVE_FINAL(JavaIoFile, pathSeparatorChar, jchar)

/*!
 @brief The system-dependent path-separator character, represented as a string
  for convenience.This string contains a single character, namely 
 <code><code>pathSeparatorChar</code></code>.
 */
inline NSString *JavaIoFile_get_pathSeparator(void);
/*! INTERNAL ONLY - Use accessor function from above. */
FOUNDATION_EXPORT NSString *JavaIoFile_pathSeparator;
J2OBJC_STATIC_FIELD_OBJ_FINAL(JavaIoFile, pathSeparator, NSString *)

FOUNDATION_EXPORT void JavaIoFile_initWithNSString_(JavaIoFile *self, NSString *pathname);

FOUNDATION_EXPORT JavaIoFile *new_JavaIoFile_initWithNSString_(NSString *pathname) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaIoFile *create_JavaIoFile_initWithNSString_(NSString *pathname);

FOUNDATION_EXPORT void JavaIoFile_initWithNSString_withNSString_(JavaIoFile *self, NSString *parent, NSString *child);

FOUNDATION_EXPORT JavaIoFile *new_JavaIoFile_initWithNSString_withNSString_(NSString *parent, NSString *child) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaIoFile *create_JavaIoFile_initWithNSString_withNSString_(NSString *parent, NSString *child);

FOUNDATION_EXPORT void JavaIoFile_initWithJavaIoFile_withNSString_(JavaIoFile *self, JavaIoFile *parent, NSString *child);

FOUNDATION_EXPORT JavaIoFile *new_JavaIoFile_initWithJavaIoFile_withNSString_(JavaIoFile *parent, NSString *child) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaIoFile *create_JavaIoFile_initWithJavaIoFile_withNSString_(JavaIoFile *parent, NSString *child);

FOUNDATION_EXPORT void JavaIoFile_initWithJavaNetURI_(JavaIoFile *self, JavaNetURI *uri);

FOUNDATION_EXPORT JavaIoFile *new_JavaIoFile_initWithJavaNetURI_(JavaNetURI *uri) NS_RETURNS_RETAINED;

FOUNDATION_EXPORT JavaIoFile *create_JavaIoFile_initWithJavaNetURI_(JavaNetURI *uri);

FOUNDATION_EXPORT IOSObjectArray *JavaIoFile_listRoots(void);

FOUNDATION_EXPORT JavaIoFile *JavaIoFile_createTempFileWithNSString_withNSString_withJavaIoFile_(NSString *prefix, NSString *suffix, JavaIoFile *directory);

FOUNDATION_EXPORT JavaIoFile *JavaIoFile_createTempFileWithNSString_withNSString_(NSString *prefix, NSString *suffix);

J2OBJC_TYPE_LITERAL_HEADER(JavaIoFile)

#endif


#if __has_feature(nullability)
#pragma clang diagnostic pop
#endif
#pragma pop_macro("INCLUDE_ALL_JavaIoFile")
